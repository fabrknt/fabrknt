{
  "metadata": {
    "projectName": "@fabriquant/sdk",
    "version": "0.2.0",
    "description": "The Precision Execution Stack — Solana-First, Cross-Chain Enabled - Engineered for Parallelism, Built for Autonomy, Woven for Speed. Now with real DEX integration via Jupiter V6.",
    "keywords": [
      "solana",
      "ai-agents",
      "defi",
      "blockchain",
      "autonomous",
      "security",
      "liquidity",
      "parallel-execution",
      "dex",
      "jupiter",
      "swap",
      "arbitrage",
      "trading"
    ],
    "repository": "https://github.com/fabriquant-labs/fabriquant",
    "builtAt": "2025-12-23T08:26:44.496Z",
    "documentCount": 10,
    "codeExampleCount": 138
  },
  "documents": [
    {
      "path": "BUSINESS_PLAN.md",
      "title": "Fabriquant Business Plan",
      "content": "# Fabriquant Business Plan\n\n**The Precision Execution Stack — Solana-First, Cross-Chain Enabled**\n\n---\n\n## Table of Contents\n\n1. [Executive Summary](#executive-summary)\n2. [Company Description](#company-description)\n3. [Market Analysis](#market-analysis)\n4. [Products & Services](#products--services)\n5. [Technology & Innovation](#technology--innovation)\n6. [Marketing & Sales Strategy](#marketing--sales-strategy)\n7. [Operations Plan](#operations-plan)\n8. [Management Team](#management-team)\n9. [Financial Projections](#financial-projections)\n10. [Funding Requirements](#funding-requirements)\n11. [Risk Analysis](#risk-analysis)\n12. [Growth Strategy](#growth-strategy)\n13. [Cross-Chain Strategy](#cross-chain-strategy)\n14. [Solopreneur Strategy](#solopreneur-strategy)\n15. [Appendices](#appendices)\n\n---\n\n## Executive Summary\n\n### Mission Statement\n\nFabriquant provides the precision execution infrastructure necessary for AI Agents and DeFi protocols to operate safely and efficiently across blockchains. We weave together security, performance, and privacy into a unified development stack that enables autonomous finance at scale, starting with Solana and expanding to EVM chains.\n\n### Vision\n\nTo become the standard cross-chain execution layer for autonomous agents and institutional DeFi, enabling the next generation of decentralized financial applications. We lead on Solana's parallel execution while providing unified security and risk management across all major blockchains.\n\n### Key Highlights\n\n-   **Unified SDK**: Five integrated components (Loom, Guard, Flow, Risk, Privacy) providing end-to-end transaction execution\n-   **Cross-Chain Strategy**: Solana-first positioning with portable components (Guard, Risk, Flow, Patterns) enabling EVM support\n-   **Market Opportunity**: $15B+ blockchain infrastructure market, 4x expansion with cross-chain support\n-   **Competitive Advantage**: First-mover in parallel execution optimization (Solana), comprehensive cross-chain security framework, and ZK compression integration\n-   **Revenue Model**: Open-source SDK with premium enterprise features, infrastructure services, and consulting\n-   **Funding Strategy**: Bootstrap-first approach with optional grants and micro-seed funding\n-   **Operating Model**: Solopreneur with strategic contractors, sustainable growth\n\n### Financial Summary (5-Year Solopreneur Projection)\n\n| Year   | Revenue    | Users  | Team Size                 | Cross-Chain Revenue      | Profitability     |\n| ------ | ---------- | ------ | ------------------------- | ------------------------ | ----------------- |\n| Year 1 | $50K-100K  | 100+   | 1 (solo)                  | $0 (Solana focus)        | Break-even Q4     |\n| Year 2 | $150K-300K | 500+   | 1-2 (contractors)         | $0-50K (EVM prep)        | Profitable        |\n| Year 3 | $300K-600K | 1,500+ | 2-3 (contractors)         | $100K-200K (EVM launch)  | Highly profitable |\n| Year 4 | $500K-1M   | 3,000+ | 3-4 (contractors)         | $200K-400K (Full EVM)    | Highly profitable |\n| Year 5 | $800K-1.5M | 5,000+ | 4-5 (consider first hire) | $400K-800K (Cross-chain) | Scale-ready       |\n\n---\n\n## Company Description\n\n### Company Overview\n\n**Fabriquant** is a solopreneur-led developer infrastructure company building the cross-chain execution layer for DeFi and AI agents. Founded in 2024, we provide open-source tools and enterprise solutions that enable developers to build secure, efficient, and privacy-preserving applications. Operating as a lean, bootstrap-first organization, we lead on Solana's parallel execution while strategically expanding portable components (Guard, Risk, Flow, Patterns) to EVM chains, positioning Fabriquant as the unified execution layer for multi-chain DeFi.\n\n### Legal Structure\n\n-   **Entity Type**: Delaware C-Corp (or appropriate jurisdiction)\n-   **Founding Date**: 2024\n-   **Headquarters**: [Location TBD]\n-   **License**: MIT (open-source core), Proprietary (enterprise features)\n\n### Core Values\n\n1. **Open Source First**: Core SDK remains open-source to drive adoption\n2. **Security by Design**: Every component prioritizes safety and risk management\n3. **Developer Experience**: Intuitive APIs and comprehensive documentation\n4. **Performance Obsession**: Maximize throughput and minimize costs\n5. **Community Driven**: Built by and for the blockchain developer community\n6. **Cross-Chain Enabled**: Portable components work across chains while maintaining Solana leadership\n7. **Sustainable Growth**: Bootstrap-first, lean operations, strategic scaling only when revenue supports it\n\n---\n\n## Market Analysis\n\n### Market Size\n\n#### Total Addressable Market (TAM)\n\n-   **Global Blockchain Infrastructure Market**: $15B+ (2024)\n-   **Solana Ecosystem**: $100B+ TVL potential\n-   **EVM Ecosystem**: $200B+ TVL (Ethereum + L2s)\n-   **DeFi Protocol Market**: $50B+ (2024)\n-   **Cross-Chain Opportunity**: 4x market expansion\n\n#### Serviceable Addressable Market (SAM)\n\n-   **Solana Developers**: 50,000+ active developers\n-   **EVM Developers**: 200,000+ active developers\n-   **DeFi Protocols**: 500+ on Solana, 2,000+ on EVM\n-   **AI Agent Projects**: 1,000+ projects building autonomous agents\n-   **Multi-Chain Protocols**: 500+ protocols operating across chains\n\n#### Serviceable Obtainable Market (SOM)\n\n-   **Year 1 Target**: 100 developers/protocols (Solana focus, 0.2% of Solana SAM) - Solopreneur realistic\n-   **Year 2 Target**: 500 developers/protocols (Solana + community growth, 1% of Solana SAM)\n-   **Year 3 Target**: 1,500 developers/protocols (Solana + EVM Guard/Risk beta, 0.6% of combined SAM)\n-   **Year 4 Target**: 3,000 developers/protocols (Full cross-chain, 1.2% of combined SAM)\n-   **Year 5 Target**: 5,000 developers/protocols (Established cross-chain, 2% of combined SAM)\n\n### Market Trends\n\n1. **Solana Growth**:\n\n    - 400%+ TVL growth in 2024\n    - Increasing institutional adoption\n    - Mainstream DeFi protocol migrations\n\n2. **AI Agent Proliferation**:\n\n    - Autonomous trading agents\n    - AI-powered DeFi strategies\n    - Agent-to-agent commerce\n\n3. **Institutional DeFi**:\n\n    - RWA tokenization\n    - Compliance requirements\n    - Risk management needs\n\n4. **Privacy Demand**:\n\n    - Regulatory compliance\n    - Competitive advantage\n    - User privacy expectations\n\n5. **Cross-Chain Proliferation**:\n    - Multi-chain protocols becoming standard\n    - Enterprise demand for unified solutions\n    - Cross-chain arbitrage and liquidity access\n    - Need for consistent security across chains\n\n### Target Customers\n\n#### Primary Segments\n\n1. **DeFi Protocols** (40% of revenue)\n\n    - DEXs, lending protocols, yield aggregators\n    - Need: Security, performance, risk management\n    - Examples: Jupiter, Raydium, Orca\n\n2. **AI Agent Developers** (30% of revenue)\n\n    - Trading bots, autonomous agents, AI strategies\n    - Need: Parallel execution, security, cost efficiency\n    - Examples: Tensor, Helius, various trading bots\n\n3. **Institutional DeFi** (20% of revenue)\n\n    - RWA protocols, compliance-focused protocols\n    - Need: Risk assessment, compliance, privacy\n    - Examples: Ondo Finance, Maple Finance\n\n4. **Enterprise Integrations** (10% of revenue)\n\n    - Traditional finance entering DeFi\n    - Need: Enterprise support, SLAs, compliance, multi-chain support\n    - Examples: Banks, asset managers, fintech companies\n\n5. **Multi-Chain Protocols** (New segment, 15% of revenue by Year 3)\n    - Protocols operating across Solana and EVM\n    - Need: Unified security, risk assessment, execution layer\n    - Examples: Cross-chain DEXs, multi-chain yield aggregators\n\n### Competitive Analysis\n\n#### Direct Competitors\n\n**Solana Ecosystem:**\n| Competitor | Strengths | Weaknesses | Our Advantage |\n| --------------- | ----------------------------------- | -------------------------------- | ---------------------------------- |\n| **Helius** | RPC infrastructure, developer tools | Limited security features | Comprehensive security + execution |\n| **Jito** | MEV infrastructure | Focus on MEV only | Full transaction lifecycle |\n| **Solana Labs** | Official SDK | Generic, no specialized features | Specialized for DeFi/AI agents |\n\n**EVM Ecosystem (Future Competition):**\n| Competitor | Strengths | Weaknesses | Our Advantage |\n| ----------------- | ---------------------------- | ----------------------------- | ---------------------------------- |\n| **OpenZeppelin** | Security standards, audits | EVM-only, no execution layer | Cross-chain + execution + security |\n| **Tenderly** | Debugging, monitoring | EVM-only, no security layer | Cross-chain security + execution |\n| **Forta** | Threat detection | EVM-only, reactive only | Proactive + cross-chain |\n\n#### Competitive Advantages\n\n1. **First-Mover**: Only comprehensive parallel execution SDK on Solana\n2. **Cross-Chain Security**: Unified Guard and Risk across Solana and EVM\n3. **Security-First**: Built-in Guard and Risk assessment (portable)\n4. **Privacy Integration**: Native ZK compression support (Solana)\n5. **Developer Experience**: Unified API across chains, excellent documentation\n6. **Open Source**: Community trust and rapid adoption\n7. **Solana Leadership**: Deep expertise in parallel execution (differentiator)\n\n---\n\n## Products & Services\n\n### Core Products\n\n#### 1. Fabriquant SDK (Open Source)\n\n**Description**: Unified TypeScript/JavaScript SDK for Solana transaction execution\n\n**Components**:\n\n-   **Loom**: Parallel transaction optimization\n-   **Guard**: Security and validation layer\n-   **Flow**: Multi-DEX liquidity routing\n-   **Risk**: AI-driven risk assessment\n-   **Privacy**: ZK compression integration\n\n**Pricing**: Free (MIT License)\n\n**Target**: All Solana developers\n\n#### 2. Fabriquant Enterprise (Proprietary)\n\n**Description**: Enterprise-grade features and support\n\n**Features**:\n\n-   Advanced analytics and monitoring\n-   Priority support (SLA)\n-   Custom integrations\n-   White-label options\n-   Compliance reporting\n-   Dedicated infrastructure\n\n**Pricing**: $5,000-$50,000/month (tiered)\n\n**Target**: Institutional clients, high-volume protocols\n\n#### 3. Fabriquant Cloud (Infrastructure)\n\n**Description**: Managed infrastructure services\n\n**Services**:\n\n-   Managed RPC endpoints\n-   Risk API access\n-   Privacy compression services\n-   Monitoring and alerting\n-   Auto-scaling infrastructure\n\n**Pricing**: Usage-based + base fee\n\n**Target**: Protocols requiring managed infrastructure\n\n#### 4. Consulting & Integration Services\n\n**Description**: Custom development and integration support\n\n**Services**:\n\n-   Protocol integration\n-   Custom Guard rules\n-   Performance optimization\n-   Security audits\n-   Training and workshops\n\n**Pricing**: $150-$300/hour or project-based\n\n**Target**: Enterprise clients, complex integrations\n\n### Product Roadmap\n\n#### Phase 1: SDK Consolidation (Q1 2025) ✅\n\n-   Merge core modules\n-   Unified API\n-   Comprehensive documentation\n\n#### Phase 2: Pattern Library (Q2 2025)\n\n-   Pre-built execution templates\n-   AI agent patterns\n-   DAO treasury management patterns\n-   **Goal**: Establish Solana leadership\n\n#### Phase 2.5: Chain Abstraction Layer (Q2-Q3 2025)\n\n-   Design and implement chain abstraction architecture\n-   Refactor Guard for chain-agnostic core + adapters\n-   Refactor Risk for multi-chain support\n-   Create Solana and EVM adapters\n-   **Goal**: Prepare for cross-chain expansion\n\n#### Phase 3: EVM Support - Guard & Risk (Q3 2025)\n\n-   Launch Guard for EVM (Ethereum, Polygon, Arbitrum)\n-   Launch Risk for EVM (EVM oracle integrations)\n-   EVM-specific security patterns (reentrancy, flash loans)\n-   **Goal**: Enable cross-chain security and risk assessment\n\n#### Phase 3.5: Full ZK Integration (Q3-Q4 2025)\n\n-   Complete Light Protocol integration (Solana)\n-   Proof generation\n-   Privacy analytics\n-   **Goal**: Complete Solana privacy features\n\n#### Phase 4: EVM Support - Flow & Patterns (Q4 2025)\n\n-   Launch Flow for EVM (Uniswap, Curve, Balancer routing)\n-   EVM pattern library\n-   Cross-chain liquidity access\n-   **Goal**: Enable cross-chain execution\n\n#### Phase 5: Fabriquant Mainnet (Q1 2026)\n\n-   Decentralized vault infrastructure\n-   Governance token\n-   Network effects\n-   Cross-chain vault support\n\n---\n\n## Technology & Innovation\n\n### Technical Architecture\n\n#### Core Stack\n\n-   **Language**: TypeScript\n-   **Runtime**: Node.js 18+\n-   **Blockchain**: Solana (primary), EVM chains (Ethereum, Polygon, Arbitrum, Optimism)\n-   **Privacy**: Light Protocol ZK Stack (Solana), zkSync/Aztec (EVM)\n-   **Infrastructure**: AWS/GCP, distributed nodes\n-   **Architecture**: Chain abstraction layer with adapter pattern\n\n#### Chain Abstraction Architecture\n\n-   **Unified Transaction Interface**: Chain-agnostic transaction model\n-   **Chain Adapters**: Solana and EVM adapters implementing unified interface\n-   **Portable Components**: Guard, Risk, Flow, Patterns work across chains\n-   **Solana-Specific**: Loom (parallel execution), Privacy (Light Protocol)\n-   **EVM-Specific**: Gas optimization, EVM security patterns\n\n#### Key Innovations\n\n1. **Parallel Execution Optimization**\n\n    - Custom data structures for lock contention elimination\n    - CU usage optimization\n    - Transaction bundling algorithms\n\n2. **Security Pattern Detection**\n\n    - Real-time malicious pattern detection\n    - Configurable validation rules\n    - Emergency stop mechanisms\n\n3. **AI-Driven Risk Assessment**\n\n    - Real-time risk scoring\n    - Compliance checking\n    - Oracle integrity validation\n\n4. **ZK Compression Integration**\n\n    - 99%+ cost reduction\n    - Privacy-preserving transactions\n    - Efficient state management\n\n5. **Cross-Chain Architecture**\n    - Chain abstraction layer for multi-chain support\n    - Portable security and risk components\n    - Unified API across Solana and EVM\n    - Chain-specific optimizations while maintaining consistency\n\n### Intellectual Property\n\n-   **Open Source**: Core SDK (MIT License)\n-   **Proprietary**: Enterprise features, advanced analytics\n-   **Patents**: Potential patents on parallel execution algorithms\n-   **Trademarks**: \"Fabriquant\" brand and logo\n\n---\n\n## Marketing & Sales Strategy\n\n### Marketing Channels\n\n#### 1. Developer Community (60% of leads)\n\n-   **Solana Developer Forums**: Active participation (primary focus)\n-   **EVM Developer Communities**: Ethereum, Polygon, Arbitrum forums (Year 2+)\n-   **GitHub**: Open-source contributions, stars\n-   **Twitter/X**: Technical content, updates, cross-chain positioning\n-   **Discord/Telegram**: Community support\n-   **Hackathons**: Sponsor Solana hackathons, participate in EVM events\n-   **Conferences**: Solana Breakpoint, DevCon, ETHGlobal, etc.\n\n#### 2. Content Marketing (20% of leads) - AI-Assisted\n\n-   **Technical Blog**: AI-assisted deep dives, tutorials (AI drafts, human refinement)\n-   **Documentation**: AI-generated comprehensive guides, API docs\n-   **Video Tutorials**: AI-assisted script writing, YouTube channel\n-   **Case Studies**: AI-assisted success story writing\n-   **Webinars**: AI-assisted presentation creation\n-   **SEO**: AI-powered SEO optimization, keyword research\n-   **Social Media**: AI-generated content, scheduling, engagement\n\n#### 3. Partnerships (15% of leads)\n\n-   **Protocol Partnerships**: Integrate with major Solana protocols, then EVM protocols\n-   **Infrastructure Partners**: RPC providers, validators (Solana), node providers (EVM)\n-   **Developer Tools**: Integrate with Solana tools, then EVM tools (Hardhat, Foundry)\n-   **Accelerators**: Partner with Solana-focused accelerators, then multi-chain accelerators\n-   **Bridge Providers**: Partner for cross-chain features\n\n#### 4. Direct Sales (5% of leads)\n\n-   **Enterprise Sales**: Direct outreach to institutions\n-   **Consulting**: Custom integration projects\n-   **Referrals**: Developer referrals\n\n### Sales Process\n\n#### Developer Adoption (Self-Service)\n\n1. Discover via GitHub/docs\n2. Install SDK (`npm install @fabriquant/sdk`)\n3. Follow quickstart guide\n4. Join community for support\n5. Upgrade to Enterprise (if needed)\n\n#### Enterprise Sales (Sales-Assisted)\n\n1. Initial contact (website, referral, event)\n2. Technical demo\n3. Pilot program\n4. Proposal and negotiation\n5. Implementation and onboarding\n6. Ongoing support and expansion\n\n### Pricing Strategy\n\n#### Freemium Model\n\n-   **Free**: Open-source SDK (MIT)\n-   **Pro**: $500/month (advanced features)\n-   **Enterprise**: Custom pricing ($5K-$50K/month)\n-   **Infrastructure**: Usage-based pricing\n\n#### Value-Based Pricing\n\n-   Cost savings from optimization\n-   Risk reduction value\n-   Time-to-market acceleration\n-   Compliance cost avoidance\n\n---\n\n## Operations Plan\n\n### Development Workflow\n\n#### Team Structure (Solopreneur Model)\n\n-   **Founder**: 100% of core work (engineering, product, strategy)\n-   **Contractors**: Strategic part-time support as needed\n    -   **Engineering**: Contractors for specific features (20-30% of dev work)\n    -   **Design**: Contractors for UI/UX (as needed)\n    -   **Marketing**: Contractors for content, SEO (10-20% of marketing)\n    -   **Support**: Community moderators (volunteer or small stipend)\n\n#### Development Process (AI-Enhanced)\n\n-   **Lean Methodology**: Focus on high-impact features\n-   **AI-Assisted Development**: GitHub Copilot, Cursor, ChatGPT for coding\n-   **GitHub Workflow**: Feature branches, AI-assisted code review, community PR reviews\n-   **CI/CD**: Automated testing and deployment (GitHub Actions, AI-assisted test generation)\n-   **Documentation**: AI-generated docs, continuous updates, community contributions\n-   **Community**: Open-source contributions, community-driven support (AI-assisted moderation)\n-   **Automation**: Maximize automation + AI to minimize manual work\n-   **AI Tools**: Integrated AI throughout development workflow\n\n### Infrastructure\n\n#### Hosting (Lean & Cost-Effective)\n\n-   **Cloud Providers**: Start with single provider (Vercel/Netlify for frontend, Railway/Fly.io for backend)\n-   **CDN**: Cloudflare (free tier initially)\n-   **Monitoring**: Sentry (free tier), Better Stack (affordable)\n-   **Analytics**: PostHog (open-source), Plausible (privacy-focused, affordable)\n-   **Cost Optimization**: Use free tiers, scale only when needed\n\n#### Security (Lean Approach)\n\n-   **Code Audits**: Community code reviews, periodic audits when revenue supports\n-   **Bug Bounty**: GitHub Security Advisories, community reporting\n-   **Security Monitoring**: Automated monitoring, community alerts\n-   **Compliance**: Start with basic security practices, add certifications when needed\n\n### Support\n\n#### Community Support (AI-Enhanced)\n\n-   **Discord**: Public community support (AI chatbot for common questions)\n-   **GitHub Issues**: Bug reports and feature requests (AI-assisted triage)\n-   **Documentation**: Self-service help (AI-powered search, FAQ generation)\n-   **Stack Overflow**: Tag monitoring (AI-assisted response drafting)\n-   **AI Chatbot**: 24/7 initial support, escalates to human when needed\n\n#### Enterprise Support (AI-Enhanced Solo)\n\n-   **SLA**: 99% uptime guarantee (realistic for solo)\n-   **Response Times**: <4 hours (critical), <24 hours (high), <48 hours (normal)\n-   **AI Initial Response**: AI chatbot provides immediate responses, escalates to human\n-   **Dedicated Support**: Enterprise customers (async, scheduled calls, AI-assisted prep)\n-   **On-Call**: Business hours + emergency escalation (AI handles initial triage)\n-   **Scaling**: Add dedicated support when revenue supports hiring\n-   **AI Tools**: AI-powered support ticket routing, response drafting, knowledge base\n\n---\n\n## Management Team\n\n### Founding Team\n\n#### Solo Founder - CEO, CTO, Product Lead\n\n-   **Background**: [Relevant experience]\n-   **Role**: Vision, strategy, engineering, product, marketing (full-stack solopreneur)\n-   **LinkedIn**: [Link]\n-   **Approach**: Bootstrap-first, sustainable growth, strategic contractors\n\n### Advisory Board (Optional)\n\n#### [Advisor Name] - [Title]\n\n-   **Background**: [Relevant experience]\n-   **Focus**: [Area of expertise]\n-   **Compensation**: Equity or advisory fee (when revenue supports)\n\n### Team Structure (Solopreneur Model)\n\n#### Year 1: Solo + Strategic Contractors\n\n-   **Founder**: Full-time (engineering, product, marketing, operations)\n-   **Contractors**:\n    -   Part-time developer (20-30% of dev work) - $2-4K/month\n    -   Part-time designer (as needed) - $500-1K/month\n    -   Part-time content writer (10% of marketing) - $500-1K/month\n-   **Total Team Cost**: $3-6K/month (contractors only)\n\n#### Year 2: Solo + Expanded Contractors\n\n-   **Founder**: Full-time\n-   **Contractors**:\n    -   Part-time developer (30-40% of dev work) - $3-5K/month\n    -   Part-time marketer (20% of marketing) - $1-2K/month\n    -   Part-time designer (as needed) - $500-1K/month\n    -   Community moderator (volunteer or small stipend) - $200-500/month\n-   **Total Team Cost**: $5-9K/month\n\n#### Year 3: Solo + Contractors + Consider First Hire\n\n-   **Founder**: Full-time\n-   **Contractors**:\n    -   Part-time developer (40-50% of dev work) - $4-6K/month\n    -   Part-time marketer (30% of marketing) - $2-3K/month\n    -   Part-time designer - $1K/month\n    -   Community moderator - $500/month\n-   **First Hire Consideration**: Part-time or full-time developer if revenue > $50K/month\n-   **Total Team Cost**: $8-11K/month (or $15-20K/month with first hire)\n\n#### Year 4-5: Scale Gradually\n\n-   **Founder**: Full-time\n-   **First Employee**: Full-time developer or marketer ($80-120K/year)\n-   **Contractors**: Continue strategic contractors for specialized work\n-   **Total Team Cost**: $20-30K/month\n\n### Leverage Strategy\n\n-   **Open Source Community**: Leverage community contributions, PR reviews\n-   **Automation**: Maximize CI/CD, automated testing, self-service onboarding\n-   **Self-Service**: Documentation, community forums, async support\n-   **Strategic Partnerships**: Integrate with existing tools, leverage partner marketing\n\n---\n\n## Financial Projections\n\n### Revenue Model (Solopreneur-Optimized)\n\n#### Revenue Streams (Priority Order for Solo)\n\n1. **Consulting & Integration** (40-50% of revenue initially)\n\n    - Project-based fees ($5K-50K per project)\n    - Hourly consulting ($150-300/hour)\n    - Training workshops ($1K-5K per workshop)\n    - **Why First**: Immediate cash flow, high leverage, builds relationships\n\n2. **Enterprise Subscriptions** (30-40% of revenue)\n\n    - Monthly/annual subscriptions\n    - Tiered pricing ($500-5K/month)\n    - Volume discounts\n    - **Why Second**: Recurring revenue but requires support capacity\n\n3. **Infrastructure Services** (10-20% of revenue)\n\n    - Usage-based pricing (automated, low maintenance)\n    - Managed services\n    - API access\n    - **Why Third**: Automated, scales well, but lower margins initially\n\n4. **Other** (5-10% of revenue)\n    - Grants (Solana Foundation, etc.)\n    - Partnerships (revenue share)\n    - Licensing (if applicable)\n\n### 5-Year Financial Projections (Solopreneur Model)\n\n#### Year 1 (2025)\n\n| Metric                   | Value                  |\n| ------------------------ | ---------------------- |\n| **Revenue**              | $50,000 - $100,000     |\n| **Enterprise Customers** | 2-5                    |\n| **Free Users**           | 100-200+               |\n| **Team Size**            | 1 (solo) + contractors |\n| **Burn Rate**            | $3,000 - $5,000/month  |\n| **Profitability**        | Break-even Q4          |\n| **Cross-Chain Revenue**  | $0 (Solana focus)      |\n\n**Revenue Breakdown**:\n\n-   Consulting: $25,000 - $50,000 (50%)\n-   Enterprise: $15,000 - $30,000 (30%)\n-   Infrastructure: $5,000 - $15,000 (15%)\n-   Other (grants): $5,000 - $5,000 (5%)\n\n#### Year 2 (2026)\n\n| Metric                   | Value                 |\n| ------------------------ | --------------------- |\n| **Revenue**              | $150,000 - $300,000   |\n| **Enterprise Customers** | 5-10                  |\n| **Free Users**           | 500-1,000+            |\n| **Team Size**            | 1-2 (contractors)     |\n| **Burn Rate**            | $5,000 - $8,000/month |\n| **Profitability**        | Profitable            |\n| **Cross-Chain Revenue**  | $0-50K (EVM prep)     |\n\n**Revenue Breakdown**:\n\n-   Consulting: $60,000 - $120,000 (40%)\n-   Enterprise: $60,000 - $120,000 (40%)\n-   Infrastructure: $20,000 - $50,000 (15%)\n-   Other: $10,000 - $10,000 (5%)\n\n#### Year 3 (2027)\n\n| Metric                   | Value                   |\n| ------------------------ | ----------------------- |\n| **Revenue**              | $300,000 - $600,000     |\n| **Enterprise Customers** | 10-20                   |\n| **Free Users**           | 1,500-3,000+            |\n| **Team Size**            | 2-3 (contractors)       |\n| **Burn Rate**            | $8,000 - $12,000/month  |\n| **Profit Margin**        | 40-50%                  |\n| **Cross-Chain Revenue**  | $100K-200K (EVM launch) |\n\n**Revenue Breakdown**:\n\n-   Enterprise: $150,000 - $300,000 (50%)\n-   Consulting: $90,000 - $180,000 (30%)\n-   Infrastructure: $45,000 - $90,000 (15%)\n-   Other: $15,000 - $30,000 (5%)\n\n**Cross-Chain Breakdown** (of $100-200K):\n\n-   EVM Guard: $60,000 - $120,000 (60%)\n-   EVM Risk: $30,000 - $60,000 (30%)\n-   Cross-chain consulting: $10,000 - $20,000 (10%)\n\n#### Year 4 (2028)\n\n| Metric                   | Value                   |\n| ------------------------ | ----------------------- |\n| **Revenue**              | $500,000 - $1,000,000   |\n| **Enterprise Customers** | 20-40                   |\n| **Free Users**           | 3,000-5,000+            |\n| **Team Size**            | 3-4 (contractors)       |\n| **Burn Rate**            | $12,000 - $18,000/month |\n| **Profit Margin**        | 45-55%                  |\n| **Cross-Chain Revenue**  | $200K-400K (Full EVM)   |\n\n**Revenue Breakdown**:\n\n-   Enterprise: $300,000 - $600,000 (60%)\n-   Consulting: $125,000 - $250,000 (25%)\n-   Infrastructure: $50,000 - $100,000 (10%)\n-   Other: $25,000 - $50,000 (5%)\n\n#### Year 5 (2029)\n\n| Metric                   | Value                     |\n| ------------------------ | ------------------------- |\n| **Revenue**              | $800,000 - $1,500,000     |\n| **Enterprise Customers** | 40-80                     |\n| **Free Users**           | 5,000-10,000+             |\n| **Team Size**            | 4-5 (consider first hire) |\n| **Burn Rate**            | $18,000 - $30,000/month   |\n| **Profit Margin**        | 50%+                      |\n| **Cross-Chain Revenue**  | $400K-800K (Cross-chain)  |\n\n**Revenue Breakdown**:\n\n-   Enterprise: $480,000 - $900,000 (60%)\n-   Consulting: $200,000 - $375,000 (25%)\n-   Infrastructure: $80,000 - $150,000 (10%)\n-   Other: $40,000 - $75,000 (5%)\n\n### Unit Economics (Solopreneur Model)\n\n#### Customer Acquisition Cost (CAC)\n\n-   **Year 1**: $500-1,000 (community-driven, organic)\n-   **Year 2**: $1,000-2,000 (content marketing, SEO)\n-   **Year 3**: $2,000-3,000 (scaling marketing)\n-   **Year 4-5**: $3,000-5,000 (enterprise focus)\n\n#### Lifetime Value (LTV)\n\n-   **Average Contract Value**: $30,000-60,000/year (conservative)\n-   **Average Contract Length**: 2-3 years\n-   **LTV**: $60,000-180,000\n-   **LTV:CAC Ratio**: 60:1 (Year 1), 30:1 (Year 2), 20:1 (Year 3)\n\n#### Payback Period\n\n-   **Year 1**: 1-2 months (low CAC, community-driven)\n-   **Year 2**: 2-3 months\n-   **Year 3**: 3-4 months\n\n---\n\n## Funding Requirements (Bootstrap-First Strategy)\n\n### Funding Strategy\n\n**Primary Approach**: Bootstrap with personal investment + grants  \n**Optional**: Micro-seed ($100-300K) if scaling faster desired  \n**Future**: Consider seed round ($500K-1M) only if revenue > $50K/month and scaling needed\n\n### Bootstrap Capital Requirements\n\n**Year 1**: $15,000 - $30,000 personal investment (reduced with AI)\n\n-   AI Tools: $2,400-4,800/year (GitHub Copilot, ChatGPT Plus, Cursor, etc.)\n-   Hosting & tools: $2,000/year\n-   Contractors: $15,000-25,000/year (reduced due to AI assistance)\n-   Marketing (AI-assisted content, design): $3,000-6,000/year (reduced with AI)\n-   Legal/incorporation: $3,000-5,000 (one-time)\n\n**Year 2**: $30,000 - $60,000 (revenue + personal)\n\n-   Hosting & tools: $5,000/year\n-   Contractors: $40,000-50,000/year\n-   Marketing: $10,000-15,000/year\n\n**Year 3**: Self-sustaining from revenue\n\n### Grant Opportunities\n\n-   **Solana Foundation**: $10-50K grants for ecosystem development\n-   **Ethereum Foundation**: $5-25K grants for EVM work\n-   **Protocol Grants**: Jupiter, Uniswap, etc. ($5-20K each)\n-   **Total Potential**: $30-100K in grants over 2-3 years\n\n### Optional Micro-Seed ($100-300K)\n\n**Use of Funds** (if raising):\n\n| Category        | Amount          | Percentage |\n| --------------- | --------------- | ---------- |\n| **Contractors** | $60,000-120,000 | 60%        |\n| **Marketing**   | $20,000-60,000  | 20%        |\n| **Operations**  | $10,000-60,000  | 15%        |\n| **Reserve**     | $10,000-60,000  | 5%         |\n\n### Milestones (Solopreneur Timeline)\n\n#### 6 Months\n\n-   Complete Phase 2 (Pattern Library)\n-   2-5 enterprise customers\n-   $10-20K ARR\n-   100-200 free users\n-   Break-even or close\n\n#### 12 Months\n\n-   Complete Phase 2.5 (Chain Abstraction)\n-   5-10 enterprise customers\n-   $50-100K ARR\n-   500-1,000 free users\n-   Profitable\n\n#### 18 Months\n\n-   Launch Phase 3 (EVM Guard/Risk beta)\n-   10-15 enterprise customers\n-   $100-200K ARR\n-   1,000-2,000 free users\n-   Consider first contractor hire\n\n#### 24 Months\n\n-   Full EVM Guard/Risk launch\n-   15-25 enterprise customers\n-   $200-400K ARR\n-   2,000-3,000 free users\n-   Consider micro-seed if scaling needed\n\n### Previous Funding\n\n-   **Bootstrap**: $20-40K personal investment (Year 1)\n-   **Grants**: $10-30K from Solana Foundation, protocols (Year 1-2)\n-   **Use**: Initial development, contractors, marketing\n\n---\n\n## Risk Analysis\n\n### Technical Risks\n\n| Risk                         | Impact | Probability | Mitigation                           |\n| ---------------------------- | ------ | ----------- | ------------------------------------ |\n| **Solana network issues**    | High   | Medium      | Multi-chain strategy (future)        |\n| **Security vulnerabilities** | High   | Low         | Regular audits, bug bounty           |\n| **Technology obsolescence**  | Medium | Low         | Continuous innovation                |\n| **Integration complexity**   | Medium | Medium      | Comprehensive documentation, support |\n\n### Market Risks\n\n| Risk                              | Impact | Probability | Mitigation                       |\n| --------------------------------- | ------ | ----------- | -------------------------------- |\n| **Market downturn**               | High   | Medium      | Diversified revenue streams      |\n| **Competition**                   | Medium | High        | First-mover advantage, community |\n| **Regulatory changes**            | High   | Low         | Compliance focus, legal counsel  |\n| **Adoption slower than expected** | Medium | Medium      | Strong marketing, partnerships   |\n\n### Operational Risks\n\n| Risk                        | Impact | Probability | Mitigation (Solopreneur)                                                   |\n| --------------------------- | ------ | ----------- | -------------------------------------------------------------------------- |\n| **Key person risk**         | High   | High        | Comprehensive documentation, community support, contractors for continuity |\n| **Scaling challenges**      | Medium | Medium      | Gradual contractor scaling, automated processes, self-service              |\n| **Customer churn**          | Medium | Medium      | Strong support (async), value delivery, community-driven help              |\n| **Infrastructure failures** | High   | Low         | Managed services, redundancy, monitoring                                   |\n| **Burnout**                 | High   | Medium      | Sustainable pace, automation, strategic contractors, work-life balance     |\n| **Limited capacity**        | Medium | High        | Focus on high-leverage activities, automate, self-service, community       |\n\n### Financial Risks\n\n| Risk                              | Impact | Probability | Mitigation                       |\n| --------------------------------- | ------ | ----------- | -------------------------------- |\n| **Funding shortfall**             | High   | Low         | Multiple funding sources         |\n| **Burn rate too high**            | Medium | Medium      | Regular monitoring, adjustments  |\n| **Revenue slower than projected** | Medium | Medium      | Conservative projections, pivots |\n\n---\n\n## Growth Strategy\n\n### Short-Term (0-12 months) - Solopreneur Focus\n\n1. **Product Development**\n\n    - Complete SDK consolidation ✅\n    - Launch pattern library (Q2 2025)\n    - Begin chain abstraction design\n    - **Focus**: High-impact features only\n\n2. **Community Building**\n\n    - Reach 100-500 GitHub stars (realistic for solo)\n    - Active Discord community (50-200 members)\n    - 3-5 protocol integrations\n    - **Focus**: Quality over quantity\n\n3. **Customer Acquisition**\n    - 2-5 enterprise customers (realistic)\n    - $50-100K ARR\n    - 1-2 case studies\n    - **Focus**: Consulting + small enterprise deals\n\n### Medium-Term (12-36 months) - Sustainable Growth\n\n1. **Market Expansion**\n\n    - **EVM chain support** (Ethereum, Polygon, Arbitrum) - Year 3\n    - **Cross-chain features** (unified liquidity) - Year 4\n    - Vertical-specific solutions - Year 4-5\n\n2. **Product Enhancement**\n\n    - Chain abstraction layer (Year 2)\n    - **EVM Guard and Risk** (Year 3)\n    - **EVM Flow and Patterns** (Year 4)\n    - Full ZK stack integration (Solana) - Year 3-4\n    - **Focus**: One major feature per year\n\n3. **Partnerships**\n    - Major Solana protocol partnerships (Year 2-3)\n    - **EVM protocol partnerships** (Year 3-4)\n    - Infrastructure provider partnerships (Year 3+)\n    - **Focus**: Strategic, high-impact partnerships\n\n### Long-Term (36+ months) - Scale When Ready\n\n1. **Platform Evolution**\n\n    - Fabriquant Mainnet launch (Year 5+)\n    - Governance token (if/when needed)\n    - Decentralized network (if/when needed)\n\n2. **Market Leadership**\n\n    - #1 Solana execution SDK (Year 3-4)\n    - #1 Cross-chain security layer (Year 4-5)\n    - 5,000+ developers (Year 5)\n    - $1M+ ARR (Year 5)\n\n3. **Scaling Decision**\n    - **Year 3-4**: Consider first employee if revenue > $50K/month\n    - **Year 4-5**: Consider micro-seed if scaling needed\n    - **Year 5+**: Consider seed round or continue solo\n    - **Exit Strategy**: Strategic acquisition, continue solo, or scale with funding\n\n---\n\n## Cross-Chain Strategy\n\n### Strategic Positioning\n\n**\"Solana-First, Cross-Chain Enabled\"**\n\nFabriquant maintains leadership in Solana's parallel execution while expanding portable components (Guard, Risk, Flow, Patterns) to EVM chains. This hybrid approach maximizes market opportunity while preserving competitive differentiation.\n\n### Why Cross-Chain?\n\n#### Market Opportunity\n\n1. **4x Market Expansion**\n\n    - Solana: 50,000 developers, $100B TVL potential\n    - EVM: 200,000 developers, $200B+ TVL\n    - Combined: 250,000 developers, $300B+ TVL\n\n2. **Enterprise Demand**\n\n    - Multi-chain protocols prefer unified solutions\n    - Enterprise deals 2-3x larger with cross-chain support\n    - Reduces single-chain risk for customers\n\n3. **Competitive Positioning**\n    - No strong cross-chain execution layer exists\n    - First-mover advantage with portable components\n    - Solana expertise differentiates from EVM-only tools\n\n### Portable Components Strategy\n\n#### High Priority (80% Portable)\n\n1. **Guard (Security Layer)**\n\n    - **Portability**: ~80% logic is chain-agnostic\n    - **Chain-Specific**: Pattern detection (Solana instructions vs EVM calls)\n    - **Market Need**: Universal security demand\n    - **Revenue Potential**: High (enterprise security)\n    - **Timeline**: Q3 2025\n\n2. **Risk (Pulsar)**\n\n    - **Portability**: ~90% logic is chain-agnostic\n    - **Chain-Specific**: Oracle integrations, asset formats\n    - **Market Need**: Universal risk assessment\n    - **Revenue Potential**: High (institutional demand)\n    - **Timeline**: Q3 2025\n\n3. **Flow (Liquidity Routing)**\n\n    - **Portability**: Concepts transfer, implementations differ\n    - **Chain-Specific**: DEX integrations (Solana vs Uniswap/Curve)\n    - **Market Need**: Multi-DEX routing on all chains\n    - **Revenue Potential**: Medium-High (DeFi protocols)\n    - **Timeline**: Q4 2025\n\n4. **Pattern Library**\n    - **Portability**: ~70% patterns are chain-agnostic\n    - **Chain-Specific**: Implementation details\n    - **Market Need**: Reusable execution patterns\n    - **Revenue Potential**: Medium (developer tools)\n    - **Timeline**: Q4 2025\n\n#### Solana-Specific (Maintain Leadership)\n\n1. **Loom (Parallel Execution)**\n\n    - **Solana-Only**: True parallel execution unique to Solana\n    - **EVM Adaptation**: Focus on bundling/optimization (not parallelism)\n    - **Differentiator**: Core competitive advantage\n    - **Strategy**: Maintain Solana leadership, adapt for EVM L2s\n\n2. **Privacy (ZK Compression)**\n    - **Solana**: Light Protocol (native)\n    - **EVM**: Multiple solutions (zkSync, Aztec, Polygon zkEVM)\n    - **Strategy**: Support multiple ZK stacks, maintain Solana advantage\n\n### Implementation Phases\n\n#### Phase 1: Foundation (Q2-Q3 2025)\n\n**Goal**: Strengthen Solana position, prepare for cross-chain\n\n-   Complete Solana Pattern Library (Phase 2)\n-   Design chain abstraction architecture\n-   Refactor Guard for chain-agnostic core\n-   Refactor Risk for multi-chain support\n-   Create chain adapter interfaces\n\n**Success Metrics**:\n\n-   Solana: 1,000+ GitHub stars, 500+ developers\n-   Architecture: Chain abstraction layer designed\n-   Code: Guard/Risk refactored for portability\n\n#### Phase 2: EVM Launch (Q3-Q4 2025)\n\n**Goal**: Launch Guard and Risk for EVM\n\n-   Implement EVM adapter for Guard\n-   Implement EVM adapter for Risk\n-   Add EVM-specific security patterns\n-   Integrate EVM oracles (Chainlink, etc.)\n-   Launch beta for Ethereum, Polygon, Arbitrum\n\n**Success Metrics**:\n\n-   EVM: 100+ developer signups, 3+ protocol integrations\n-   Revenue: $200K+ EVM revenue (Q4)\n-   Quality: EVM Guard/Risk production-ready\n\n#### Phase 3: Full Cross-Chain (Q4 2025 - Q1 2026)\n\n**Goal**: Complete cross-chain support\n\n-   Launch Flow for EVM (Uniswap, Curve routing)\n-   EVM pattern library\n-   Cross-chain liquidity access\n-   Cross-chain arbitrage patterns\n-   Unified API documentation\n\n**Success Metrics**:\n\n-   EVM: 500+ developers, 10+ protocol integrations\n-   Revenue: $600K+ EVM revenue (Year 2)\n-   Features: Full cross-chain execution layer\n\n### Technical Architecture\n\n#### Chain Abstraction Layer\n\n```typescript\n// Unified chain interface\ninterface ChainAdapter {\n    chain: \"solana\" | \"ethereum\" | \"polygon\" | \"arbitrum\";\n    buildTransaction(tx: UnifiedTransaction): ChainTransaction;\n    executeTransaction(tx: ChainTransaction): Promise<TransactionResult>;\n    estimateCost(tx: ChainTransaction): Promise<bigint>;\n}\n\n// Portable components work with unified interface\nclass Guard {\n    validateTransaction(\n        tx: UnifiedTransaction,\n        chain: ChainAdapter\n    ): ValidationResult {\n        // Chain-agnostic validation logic\n        // Chain-specific patterns via adapter\n    }\n}\n```\n\n#### Component Portability Matrix\n\n| Component    | Portability | Solana-Specific     | EVM-Specific             | Timeline |\n| ------------ | ----------- | ------------------- | ------------------------ | -------- |\n| **Guard**    | 80%         | Pattern detection   | Reentrancy, flash loans  | Q3 2025  |\n| **Risk**     | 90%         | Oracle integrations | Chainlink, asset formats | Q3 2025  |\n| **Flow**     | 60%         | DEX integrations    | Uniswap, Curve routing   | Q4 2025  |\n| **Patterns** | 70%         | Implementation      | EVM patterns             | Q4 2025  |\n| **Loom**     | 20%         | Parallel execution  | Bundling only            | TBD      |\n| **Privacy**  | 30%         | Light Protocol      | Multiple ZK stacks       | TBD      |\n\n### Risk Mitigation\n\n#### Technical Risks\n\n-   **Architecture Complexity**: Mitigated by phased approach, adapter pattern\n-   **Resource Dilution**: Dedicated EVM team, maintain Solana focus\n-   **Performance**: Chain-specific optimizations, unified API\n\n#### Business Risks\n\n-   **Identity Confusion**: \"Solana-First\" messaging, clear positioning\n-   **Market Timing**: Start with highest-demand components (Guard/Risk)\n-   **Competition**: First-mover advantage, Solana differentiation\n\n### Success Metrics (Solopreneur Realistic)\n\n#### Solana Metrics (Maintain Leadership)\n\n-   GitHub stars: 100-500 (Year 1), 1,000+ (Year 3), 3,000+ (Year 5)\n-   Solana developer adoption: 100+ (Year 1), 1,000+ (Year 3), 3,000+ (Year 5)\n-   Solana protocol integrations: 3-5 (Year 1), 10+ (Year 3), 20+ (Year 5)\n-   Solana revenue: $50-100K (Year 1), $200-400K (Year 3), $500K+ (Year 5)\n\n#### Cross-Chain Metrics (New Growth)\n\n-   EVM developer signups: 0 (Year 1), 50+ (Year 3), 500+ (Year 5)\n-   EVM protocol integrations: 0 (Year 1), 3+ (Year 3), 10+ (Year 5)\n-   Cross-chain revenue: $0 (Year 1), $100-200K (Year 3), $400-800K (Year 5)\n-   Enterprise inquiries: 2-5 (Year 1), 10+ (Year 3), 20+ (Year 5)\n\n### Competitive Advantages\n\n1. **Solana Leadership**: Deep expertise in parallel execution\n2. **Cross-Chain Security**: Unified Guard across chains\n3. **Cross-Chain Risk**: Unified Risk assessment\n4. **Unified API**: One SDK for Solana and EVM\n5. **First-Mover**: Only cross-chain execution layer with Solana expertise\n\n---\n\n## Solopreneur Strategy\n\n### Operating Model\n\n**Core Philosophy**: Bootstrap-first, sustainable growth, strategic scaling only when revenue supports it.\n\n### Key Principles\n\n1. **High-Leverage Activities First**\n\n    - Open-source SDK → Community → Leads\n    - Content marketing → SEO → Organic growth\n    - Consulting → Cash flow → Product development\n\n2. **Leverage AI Tools Extensively** (NEW)\n\n    - **Development**: AI code generation, debugging, documentation\n    - **Marketing**: AI content creation, SEO optimization, social media\n    - **Support**: AI chatbots, automated responses, FAQ generation\n    - **Operations**: AI analytics, reporting, automation\n    - **Sales**: AI email writing, lead qualification, follow-ups\n    - **Research**: AI research assistants, competitive analysis\n\n3. **Automate Everything**\n\n    - CI/CD, automated testing\n    - Self-service onboarding\n    - Community-driven support\n    - Automated billing and invoicing\n    - AI-powered workflows and automations\n\n4. **Focus on What You're Best At**\n\n    - If technical: Focus on product, use AI for marketing/content\n    - If marketing: Focus on growth, use AI for development assistance\n    - Always: Use AI to amplify your strengths, fill your gaps\n    - Always: Focus on high-impact, high-value work\n\n5. **Build in Public**\n\n    - Share progress, build community\n    - Leverage community for feedback, contributions\n    - Creates natural marketing and trust\n    - Use AI to help with content creation and sharing\n\n6. **Start Small, Scale Gradually**\n    - Don't hire until you can afford it\n    - Use AI tools + contractors before employees\n    - Only scale when revenue supports it\n    - Maintain work-life balance\n\n### Resource Allocation\n\n#### Time Allocation (Typical Week - AI-Assisted)\n\n-   **Development** (40-50%): Core product, features, bug fixes (AI-assisted coding)\n-   **Marketing** (15-20%): Strategy, review AI-generated content, community engagement\n-   **Sales/Support** (15-20%): Customer calls, support, consulting (AI-assisted responses)\n-   **Operations** (10-15%): Admin, planning, contractor management (AI-assisted)\n-   **AI Tool Management** (5-10%): Prompting, reviewing AI outputs, optimizing workflows\n\n**AI Impact**: Reduces time needed for marketing (content creation), support (initial responses), and operations (reporting, analysis) by 50-70%\n\n#### Financial Allocation\n\n-   **Year 1**: $3-5K/month burn\n\n    -   AI Tools: $200-400/month (GitHub Copilot, ChatGPT Plus, Cursor, etc.)\n    -   Contractors: $1.5-2.5K/month (reduced due to AI assistance)\n    -   Tools/Hosting: $500/month\n    -   Marketing: $300-600/month (reduced due to AI content creation)\n    -   Buffer: $500-1K/month\n\n-   **Year 2**: $5-8K/month burn\n\n    -   AI Tools: $300-600/month (expanded AI tool suite)\n    -   Contractors: $2.5-4K/month (strategic use, AI-assisted)\n    -   Tools/Hosting: $1K/month\n    -   Marketing: $800-1.5K/month (AI-assisted, more efficient)\n    -   Buffer: $1K/month\n\n-   **Year 3**: $8-12K/month burn\n    -   AI Tools: $400-800/month (premium AI tools, API access)\n    -   Contractors: $4-6K/month (focused on high-value work)\n    -   Tools/Hosting: $1-2K/month\n    -   Marketing: $1.5-2.5K/month (AI-powered campaigns)\n    -   Buffer: $1-2K/month\n\n### Leverage Strategies\n\n#### Community Leverage\n\n-   **Open Source**: Community contributions, PR reviews, bug reports\n-   **Documentation**: Community improvements, translations\n-   **Support**: Community moderators, Discord helpers\n-   **Marketing**: Community shares, word-of-mouth\n\n#### Automation Leverage\n\n-   **CI/CD**: GitHub Actions (free), automated testing\n-   **Deployment**: Vercel/Netlify (free tier), Railway (affordable)\n-   **Monitoring**: Sentry (free tier), Better Stack (affordable)\n-   **Analytics**: PostHog (open-source), Plausible (affordable)\n\n#### AI Tool Leverage (Primary Multiplier)\n\n**Development & Engineering**:\n\n-   **Code Generation**: GitHub Copilot ($10-20/month), Cursor ($20/month), ChatGPT Plus ($20/month)\n-   **Code Review**: AI-powered PR reviews, security scanning\n-   **Documentation**: AI-generated API docs, tutorials, guides\n-   **Testing**: AI-assisted test generation, bug detection\n-   **Debugging**: AI-powered debugging assistance\n-   **Time Savings**: 40-60% reduction in development time\n\n**Marketing & Content**:\n\n-   **Content Creation**: ChatGPT, Claude, Jasper ($50-100/month)\n-   **SEO**: AI SEO tools, keyword research, content optimization\n-   **Social Media**: AI scheduling, content generation, engagement\n-   **Email Marketing**: AI email writing, personalization\n-   **Time Savings**: 60-80% reduction in content creation time\n\n**Customer Support**:\n\n-   **Chatbots**: AI-powered support bots (Intercom AI, custom GPTs)\n-   **FAQ Generation**: AI-generated FAQs from documentation\n-   **Email Responses**: AI-assisted response drafting\n-   **Time Savings**: 70-90% reduction in support time\n\n**Operations & Analytics**:\n\n-   **Data Analysis**: AI-powered insights, reporting\n-   **Research**: AI research assistants, competitive analysis\n-   **Automation**: AI-powered workflow automation\n-   **Time Savings**: 50-70% reduction in operational tasks\n\n**Cost-Benefit**: $200-800/month in AI tools replaces $5-15K/month in contractor costs\n\n#### Contractor Leverage\n\n-   **Development**: Part-time contractors for specific features (AI-assisted)\n-   **Design**: Contractors for complex UI/UX, branding (AI for initial drafts)\n-   **Marketing**: Contractors for strategy, complex campaigns (AI for content)\n-   **Support**: Community moderators (volunteer or small stipend)\n\n### AI Tool Stack (Recommended)\n\n#### Development Tools\n\n-   **GitHub Copilot** ($10-20/month): Code generation, autocomplete\n-   **Cursor** ($20/month): AI-powered IDE, code editing\n-   **ChatGPT Plus** ($20/month): Code assistance, debugging, documentation\n-   **Claude** ($20/month): Code review, technical writing\n-   **Codeium** (Free tier available): Alternative code generation\n\n#### Marketing & Content Tools\n\n-   **ChatGPT Plus** ($20/month): Content creation, blog posts, social media\n-   **Claude** ($20/month): Long-form content, documentation\n-   **Jasper** ($50-100/month): Marketing copy, SEO content\n-   **Copy.ai** ($50/month): Marketing copy, email writing\n-   **Grammarly** ($12/month): Writing assistance, editing\n\n#### Support & Operations Tools\n\n-   **Intercom AI** ($100+/month): AI chatbot for customer support\n-   **Zapier AI** ($50+/month): AI-powered workflow automation\n-   **Make.com AI** ($20+/month): AI automation workflows\n-   **Custom GPTs**: Build custom AI assistants for specific tasks\n\n#### Analytics & Research Tools\n\n-   **ChatGPT Plus**: Market research, competitive analysis\n-   **Perplexity** ($20/month): AI research assistant\n-   **Notion AI** ($10/month): AI-powered note-taking, research\n-   **Claude**: Data analysis, insights\n\n#### Total AI Tool Cost\n\n-   **Year 1**: $200-400/month ($2,400-4,800/year)\n-   **Year 2**: $300-600/month ($3,600-7,200/year)\n-   **Year 3**: $400-800/month ($4,800-9,600/year)\n\n**ROI**: $200-800/month in AI tools replaces $5-15K/month in contractor costs, 10-20x ROI\n\n### AI Workflow Examples\n\n#### Development Workflow\n\n1. **Planning**: Use AI to generate feature specs, user stories\n2. **Coding**: Use Copilot/Cursor for code generation\n3. **Testing**: Use AI to generate test cases\n4. **Documentation**: Use AI to generate API docs, guides\n5. **Review**: Use AI for initial code review, then human review\n\n#### Marketing Workflow\n\n1. **Strategy**: Use AI for content strategy, keyword research\n2. **Creation**: Use AI to draft blog posts, social media content\n3. **Optimization**: Use AI for SEO optimization, A/B testing ideas\n4. **Distribution**: Use AI for scheduling, engagement\n5. **Analysis**: Use AI for content performance analysis\n\n#### Support Workflow\n\n1. **Initial Response**: AI chatbot handles common questions\n2. **Escalation**: AI routes complex issues to human\n3. **Response Drafting**: AI drafts responses, human reviews\n4. **Knowledge Base**: AI generates FAQs from support tickets\n5. **Analysis**: AI analyzes support patterns, identifies issues\n\n### Scaling Decision Framework\n\n#### When to Hire First Employee\n\n**Consider hiring when**:\n\n-   Revenue consistently > $50K/month\n-   Can afford $80-120K/year salary\n-   Have 6+ months runway after hiring\n-   Workload consistently > 60 hours/week\n-   Clear role definition and need\n\n**Don't hire if**:\n\n-   Revenue < $30K/month\n-   Can't afford 6+ months runway\n-   Workload manageable with contractors\n-   Unclear role or need\n\n#### When to Raise Funding\n\n**Consider raising when**:\n\n-   Revenue > $50K/month consistently\n-   Clear path to $200K+ ARR\n-   Need capital to accelerate growth\n-   Have product-market fit\n-   Can demonstrate traction\n\n**Don't raise if**:\n\n-   Can bootstrap to profitability\n-   Revenue < $20K/month\n-   Unclear product-market fit\n-   No clear use for capital\n-   Prefer independence\n\n### Risk Mitigation (Solopreneur-Specific)\n\n#### Burnout Prevention\n\n-   **Sustainable Pace**: 40-50 hours/week max\n-   **Time Blocking**: Dedicated time for deep work\n-   **Automation**: Reduce manual work\n-   **Delegation**: Use contractors for non-core work\n-   **Breaks**: Regular time off, vacations\n\n#### Single Point of Failure\n\n-   **Documentation**: Comprehensive docs for continuity\n-   **Community**: Build community that can help\n-   **Contractors**: Have backup contractors\n-   **Processes**: Document processes and workflows\n-   **Backup Plans**: Plan for illness, emergencies\n\n#### Revenue Volatility\n\n-   **Diversify**: Multiple revenue streams\n-   **Retainers**: Prefer retainer contracts\n-   **Emergency Fund**: 6+ months expenses saved\n-   **Consulting Buffer**: Consulting for cash flow\n-   **Grants**: Apply for grants as buffer\n\n### Success Metrics (Solopreneur)\n\n#### Year 1 Success\n\n-   ✅ Break-even or profitable\n-   ✅ 100+ GitHub stars\n-   ✅ 2-5 paying customers\n-   ✅ $50-100K revenue\n-   ✅ Sustainable work pace\n\n#### Year 2 Success\n\n-   ✅ Profitable, growing\n-   ✅ 500+ GitHub stars\n-   ✅ 5-10 paying customers\n-   ✅ $150-300K revenue\n-   ✅ Established community\n\n#### Year 3 Success\n\n-   ✅ Highly profitable\n-   ✅ 1,000+ GitHub stars\n-   ✅ 10-20 paying customers\n-   ✅ $300-600K revenue\n-   ✅ Consider first hire or continue solo\n\n### Long-Term Vision\n\n**Path 1: Continue Solo**\n\n-   Maintain solo + contractors model\n-   Focus on profitability and lifestyle\n-   Scale revenue to $1-2M/year solo\n-   Consider as lifestyle business\n\n**Path 2: Strategic Hire**\n\n-   Hire first employee at Year 3-4\n-   Scale to $2-5M/year with small team\n-   Maintain lean operations\n-   Consider micro-seed if needed\n\n**Path 3: Scale with Funding**\n\n-   Raise seed round at Year 4-5\n-   Build team of 5-10 people\n-   Scale to $5-10M/year\n-   Consider exit or continue growth\n\n**Decision Point**: Re-evaluate at Year 3 based on revenue, market opportunity, and personal goals.\n\n---\n\n## Appendices\n\n### Appendix A: Market Research\n\n-   Solana ecosystem growth data\n-   EVM ecosystem growth data\n-   Cross-chain protocol statistics\n-   DeFi protocol statistics\n-   AI agent market analysis\n-   Competitive landscape analysis (Solana + EVM)\n\n### Appendix B: Technical Documentation\n\n-   Architecture diagrams (Solana + cross-chain)\n-   Chain abstraction architecture\n-   API specifications (unified + chain-specific)\n-   Security audit reports\n-   Performance benchmarks (Solana + EVM)\n\n### Appendix C: Financial Details\n\n-   Detailed P&L projections\n-   Cash flow statements\n-   Balance sheet projections\n-   Unit economics analysis\n\n### Appendix D: Team Resumes\n\n-   Founder backgrounds\n-   Key team member profiles\n-   Advisory board members\n\n### Appendix E: Customer Testimonials\n\n-   Early adopter quotes\n-   Case studies\n-   Integration success stories\n\n### Appendix F: Legal Documents\n\n-   Terms of Service\n-   Privacy Policy\n-   Enterprise agreements\n-   Partnership agreements\n\n---\n\n## Contact Information\n\n**Company**: Fabriquant  \n**Website**: https://github.com/fabriquant-labs/fabriquant  \n**Email**: [Contact Email]  \n**Twitter**: [@psyto](https://x.com/psyto)  \n**GitHub**: [fabriquant-labs/fabriquant](https://github.com/fabriquant-labs/fabriquant)\n\n---\n\n**Document Version**: 3.1  \n**Last Updated**: January 2025  \n**Confidentiality**: This document contains confidential and proprietary information.\n\n### Document History\n\n-   **v1.0** (January 2025): Initial business plan, Solana-focused\n-   **v2.0** (January 2025): Added cross-chain strategy, updated positioning to \"Solana-First, Cross-Chain Enabled\"\n-   **v3.0** (January 2025): Revised for solopreneur model - bootstrap-first, sustainable growth, realistic projections\n-   **v3.1** (January 2025): Added comprehensive AI tool leverage strategy - maximizing generative AI throughout operations\n",
      "sections": [
        {
          "heading": "# Fabriquant Business Plan",
          "body": "**The Precision Execution Stack — Solana-First, Cross-Chain Enabled**\n\n---"
        },
        {
          "heading": "Table of Contents",
          "body": "1. [Executive Summary](#executive-summary)\n2. [Company Description](#company-description)\n3. [Market Analysis](#market-analysis)\n4. [Products & Services](#products--services)\n5. [Technology & Innovation](#technology--innovation)\n6. [Marketing & Sales Strategy](#marketing--sales-strategy)\n7. [Operations Plan](#operations-plan)\n8. [Management Team](#management-team)\n9. [Financial Projections](#financial-projections)\n10. [Funding Requirements](#funding-requirements)\n11. [Risk Analysis](#risk-analysis)\n12. [Growth Strategy](#growth-strategy)\n13. [Cross-Chain Strategy](#cross-chain-strategy)\n14. [Solopreneur Strategy](#solopreneur-strategy)\n15. [Appendices](#appendices)\n\n---"
        },
        {
          "heading": "Executive Summary",
          "body": "### Mission Statement\n\nFabriquant provides the precision execution infrastructure necessary for AI Agents and DeFi protocols to operate safely and efficiently across blockchains. We weave together security, performance, and privacy into a unified development stack that enables autonomous finance at scale, starting with Solana and expanding to EVM chains.\n\n### Vision\n\nTo become the standard cross-chain execution layer for autonomous agents and institutional DeFi, enabling the next generation of decentralized financial applications. We lead on Solana's parallel execution while providing unified security and risk management across all major blockchains.\n\n### Key Highlights\n\n-   **Unified SDK**: Five integrated components (Loom, Guard, Flow, Risk, Privacy) providing end-to-end transaction execution\n-   **Cross-Chain Strategy**: Solana-first positioning with portable components (Guard, Risk, Flow, Patterns) enabling EVM support\n-   **Market Opportunity**: $15B+ blockchain infrastructure market, 4x expansion with cross-chain support\n-   **Competitive Advantage**: First-mover in parallel execution optimization (Solana), comprehensive cross-chain security framework, and ZK compression integration\n-   **Revenue Model**: Open-source SDK with premium enterprise features, infrastructure services, and consulting\n-   **Funding Strategy**: Bootstrap-first approach with optional grants and micro-seed funding\n-   **Operating Model**: Solopreneur with strategic contractors, sustainable growth\n\n### Financial Summary (5-Year Solopreneur Projection)\n\n| Year   | Revenue    | Users  | Team Size                 | Cross-Chain Revenue      | Profitability     |\n| ------ | ---------- | ------ | ------------------------- | ------------------------ | ----------------- |\n| Year 1 | $50K-100K  | 100+   | 1 (solo)                  | $0 (Solana focus)        | Break-even Q4     |\n| Year 2 | $150K-300K | 500+   | 1-2 (contractors)         | $0-50K (EVM prep)        | Profitable        |\n| Year 3 | $300K-600K | 1,500+ | 2-3 (contractors)         | $100K-200K (EVM launch)  | Highly profitable |\n| Year 4 | $500K-1M   | 3,000+ | 3-4 (contractors)         | $200K-400K (Full EVM)    | Highly profitable |\n| Year 5 | $800K-1.5M | 5,000+ | 4-5 (consider first hire) | $400K-800K (Cross-chain) | Scale-ready       |\n\n---"
        },
        {
          "heading": "Company Description",
          "body": "### Company Overview\n\n**Fabriquant** is a solopreneur-led developer infrastructure company building the cross-chain execution layer for DeFi and AI agents. Founded in 2024, we provide open-source tools and enterprise solutions that enable developers to build secure, efficient, and privacy-preserving applications. Operating as a lean, bootstrap-first organization, we lead on Solana's parallel execution while strategically expanding portable components (Guard, Risk, Flow, Patterns) to EVM chains, positioning Fabriquant as the unified execution layer for multi-chain DeFi.\n\n### Legal Structure\n\n-   **Entity Type**: Delaware C-Corp (or appropriate jurisdiction)\n-   **Founding Date**: 2024\n-   **Headquarters**: [Location TBD]\n-   **License**: MIT (open-source core), Proprietary (enterprise features)\n\n### Core Values\n\n1. **Open Source First**: Core SDK remains open-source to drive adoption\n2. **Security by Design**: Every component prioritizes safety and risk management\n3. **Developer Experience**: Intuitive APIs and comprehensive documentation\n4. **Performance Obsession**: Maximize throughput and minimize costs\n5. **Community Driven**: Built by and for the blockchain developer community\n6. **Cross-Chain Enabled**: Portable components work across chains while maintaining Solana leadership\n7. **Sustainable Growth**: Bootstrap-first, lean operations, strategic scaling only when revenue supports it\n\n---"
        },
        {
          "heading": "Market Analysis",
          "body": "### Market Size\n\n#### Total Addressable Market (TAM)\n\n-   **Global Blockchain Infrastructure Market**: $15B+ (2024)\n-   **Solana Ecosystem**: $100B+ TVL potential\n-   **EVM Ecosystem**: $200B+ TVL (Ethereum + L2s)\n-   **DeFi Protocol Market**: $50B+ (2024)\n-   **Cross-Chain Opportunity**: 4x market expansion\n\n#### Serviceable Addressable Market (SAM)\n\n-   **Solana Developers**: 50,000+ active developers\n-   **EVM Developers**: 200,000+ active developers\n-   **DeFi Protocols**: 500+ on Solana, 2,000+ on EVM\n-   **AI Agent Projects**: 1,000+ projects building autonomous agents\n-   **Multi-Chain Protocols**: 500+ protocols operating across chains\n\n#### Serviceable Obtainable Market (SOM)\n\n-   **Year 1 Target**: 100 developers/protocols (Solana focus, 0.2% of Solana SAM) - Solopreneur realistic\n-   **Year 2 Target**: 500 developers/protocols (Solana + community growth, 1% of Solana SAM)\n-   **Year 3 Target**: 1,500 developers/protocols (Solana + EVM Guard/Risk beta, 0.6% of combined SAM)\n-   **Year 4 Target**: 3,000 developers/protocols (Full cross-chain, 1.2% of combined SAM)\n-   **Year 5 Target**: 5,000 developers/protocols (Established cross-chain, 2% of combined SAM)\n\n### Market Trends\n\n1. **Solana Growth**:\n\n    - 400%+ TVL growth in 2024\n    - Increasing institutional adoption\n    - Mainstream DeFi protocol migrations\n\n2. **AI Agent Proliferation**:\n\n    - Autonomous trading agents\n    - AI-powered DeFi strategies\n    - Agent-to-agent commerce\n\n3. **Institutional DeFi**:\n\n    - RWA tokenization\n    - Compliance requirements\n    - Risk management needs\n\n4. **Privacy Demand**:\n\n    - Regulatory compliance\n    - Competitive advantage\n    - User privacy expectations\n\n5. **Cross-Chain Proliferation**:\n    - Multi-chain protocols becoming standard\n    - Enterprise demand for unified solutions\n    - Cross-chain arbitrage and liquidity access\n    - Need for consistent security across chains\n\n### Target Customers\n\n#### Primary Segments\n\n1. **DeFi Protocols** (40% of revenue)\n\n    - DEXs, lending protocols, yield aggregators\n    - Need: Security, performance, risk management\n    - Examples: Jupiter, Raydium, Orca\n\n2. **AI Agent Developers** (30% of revenue)\n\n    - Trading bots, autonomous agents, AI strategies\n    - Need: Parallel execution, security, cost efficiency\n    - Examples: Tensor, Helius, various trading bots\n\n3. **Institutional DeFi** (20% of revenue)\n\n    - RWA protocols, compliance-focused protocols\n    - Need: Risk assessment, compliance, privacy\n    - Examples: Ondo Finance, Maple Finance\n\n4. **Enterprise Integrations** (10% of revenue)\n\n    - Traditional finance entering DeFi\n    - Need: Enterprise support, SLAs, compliance, multi-chain support\n    - Examples: Banks, asset managers, fintech companies\n\n5. **Multi-Chain Protocols** (New segment, 15% of revenue by Year 3)\n    - Protocols operating across Solana and EVM\n    - Need: Unified security, risk assessment, execution layer\n    - Examples: Cross-chain DEXs, multi-chain yield aggregators\n\n### Competitive Analysis\n\n#### Direct Competitors\n\n**Solana Ecosystem:**\n| Competitor | Strengths | Weaknesses | Our Advantage |\n| --------------- | ----------------------------------- | -------------------------------- | ---------------------------------- |\n| **Helius** | RPC infrastructure, developer tools | Limited security features | Comprehensive security + execution |\n| **Jito** | MEV infrastructure | Focus on MEV only | Full transaction lifecycle |\n| **Solana Labs** | Official SDK | Generic, no specialized features | Specialized for DeFi/AI agents |\n\n**EVM Ecosystem (Future Competition):**\n| Competitor | Strengths | Weaknesses | Our Advantage |\n| ----------------- | ---------------------------- | ----------------------------- | ---------------------------------- |\n| **OpenZeppelin** | Security standards, audits | EVM-only, no execution layer | Cross-chain + execution + security |\n| **Tenderly** | Debugging, monitoring | EVM-only, no security layer | Cross-chain security + execution |\n| **Forta** | Threat detection | EVM-only, reactive only | Proactive + cross-chain |\n\n#### Competitive Advantages\n\n1. **First-Mover**: Only comprehensive parallel execution SDK on Solana\n2. **Cross-Chain Security**: Unified Guard and Risk across Solana and EVM\n3. **Security-First**: Built-in Guard and Risk assessment (portable)\n4. **Privacy Integration**: Native ZK compression support (Solana)\n5. **Developer Experience**: Unified API across chains, excellent documentation\n6. **Open Source**: Community trust and rapid adoption\n7. **Solana Leadership**: Deep expertise in parallel execution (differentiator)\n\n---"
        },
        {
          "heading": "Products & Services",
          "body": "### Core Products\n\n#### 1. Fabriquant SDK (Open Source)\n\n**Description**: Unified TypeScript/JavaScript SDK for Solana transaction execution\n\n**Components**:\n\n-   **Loom**: Parallel transaction optimization\n-   **Guard**: Security and validation layer\n-   **Flow**: Multi-DEX liquidity routing\n-   **Risk**: AI-driven risk assessment\n-   **Privacy**: ZK compression integration\n\n**Pricing**: Free (MIT License)\n\n**Target**: All Solana developers\n\n#### 2. Fabriquant Enterprise (Proprietary)\n\n**Description**: Enterprise-grade features and support\n\n**Features**:\n\n-   Advanced analytics and monitoring\n-   Priority support (SLA)\n-   Custom integrations\n-   White-label options\n-   Compliance reporting\n-   Dedicated infrastructure\n\n**Pricing**: $5,000-$50,000/month (tiered)\n\n**Target**: Institutional clients, high-volume protocols\n\n#### 3. Fabriquant Cloud (Infrastructure)\n\n**Description**: Managed infrastructure services\n\n**Services**:\n\n-   Managed RPC endpoints\n-   Risk API access\n-   Privacy compression services\n-   Monitoring and alerting\n-   Auto-scaling infrastructure\n\n**Pricing**: Usage-based + base fee\n\n**Target**: Protocols requiring managed infrastructure\n\n#### 4. Consulting & Integration Services\n\n**Description**: Custom development and integration support\n\n**Services**:\n\n-   Protocol integration\n-   Custom Guard rules\n-   Performance optimization\n-   Security audits\n-   Training and workshops\n\n**Pricing**: $150-$300/hour or project-based\n\n**Target**: Enterprise clients, complex integrations\n\n### Product Roadmap\n\n#### Phase 1: SDK Consolidation (Q1 2025) ✅\n\n-   Merge core modules\n-   Unified API\n-   Comprehensive documentation\n\n#### Phase 2: Pattern Library (Q2 2025)\n\n-   Pre-built execution templates\n-   AI agent patterns\n-   DAO treasury management patterns\n-   **Goal**: Establish Solana leadership\n\n#### Phase 2.5: Chain Abstraction Layer (Q2-Q3 2025)\n\n-   Design and implement chain abstraction architecture\n-   Refactor Guard for chain-agnostic core + adapters\n-   Refactor Risk for multi-chain support\n-   Create Solana and EVM adapters\n-   **Goal**: Prepare for cross-chain expansion\n\n#### Phase 3: EVM Support - Guard & Risk (Q3 2025)\n\n-   Launch Guard for EVM (Ethereum, Polygon, Arbitrum)\n-   Launch Risk for EVM (EVM oracle integrations)\n-   EVM-specific security patterns (reentrancy, flash loans)\n-   **Goal**: Enable cross-chain security and risk assessment\n\n#### Phase 3.5: Full ZK Integration (Q3-Q4 2025)\n\n-   Complete Light Protocol integration (Solana)\n-   Proof generation\n-   Privacy analytics\n-   **Goal**: Complete Solana privacy features\n\n#### Phase 4: EVM Support - Flow & Patterns (Q4 2025)\n\n-   Launch Flow for EVM (Uniswap, Curve, Balancer routing)\n-   EVM pattern library\n-   Cross-chain liquidity access\n-   **Goal**: Enable cross-chain execution\n\n#### Phase 5: Fabriquant Mainnet (Q1 2026)\n\n-   Decentralized vault infrastructure\n-   Governance token\n-   Network effects\n-   Cross-chain vault support\n\n---"
        },
        {
          "heading": "Technology & Innovation",
          "body": "### Technical Architecture\n\n#### Core Stack\n\n-   **Language**: TypeScript\n-   **Runtime**: Node.js 18+\n-   **Blockchain**: Solana (primary), EVM chains (Ethereum, Polygon, Arbitrum, Optimism)\n-   **Privacy**: Light Protocol ZK Stack (Solana), zkSync/Aztec (EVM)\n-   **Infrastructure**: AWS/GCP, distributed nodes\n-   **Architecture**: Chain abstraction layer with adapter pattern\n\n#### Chain Abstraction Architecture\n\n-   **Unified Transaction Interface**: Chain-agnostic transaction model\n-   **Chain Adapters**: Solana and EVM adapters implementing unified interface\n-   **Portable Components**: Guard, Risk, Flow, Patterns work across chains\n-   **Solana-Specific**: Loom (parallel execution), Privacy (Light Protocol)\n-   **EVM-Specific**: Gas optimization, EVM security patterns\n\n#### Key Innovations\n\n1. **Parallel Execution Optimization**\n\n    - Custom data structures for lock contention elimination\n    - CU usage optimization\n    - Transaction bundling algorithms\n\n2. **Security Pattern Detection**\n\n    - Real-time malicious pattern detection\n    - Configurable validation rules\n    - Emergency stop mechanisms\n\n3. **AI-Driven Risk Assessment**\n\n    - Real-time risk scoring\n    - Compliance checking\n    - Oracle integrity validation\n\n4. **ZK Compression Integration**\n\n    - 99%+ cost reduction\n    - Privacy-preserving transactions\n    - Efficient state management\n\n5. **Cross-Chain Architecture**\n    - Chain abstraction layer for multi-chain support\n    - Portable security and risk components\n    - Unified API across Solana and EVM\n    - Chain-specific optimizations while maintaining consistency\n\n### Intellectual Property\n\n-   **Open Source**: Core SDK (MIT License)\n-   **Proprietary**: Enterprise features, advanced analytics\n-   **Patents**: Potential patents on parallel execution algorithms\n-   **Trademarks**: \"Fabriquant\" brand and logo\n\n---"
        },
        {
          "heading": "Marketing & Sales Strategy",
          "body": "### Marketing Channels\n\n#### 1. Developer Community (60% of leads)\n\n-   **Solana Developer Forums**: Active participation (primary focus)\n-   **EVM Developer Communities**: Ethereum, Polygon, Arbitrum forums (Year 2+)\n-   **GitHub**: Open-source contributions, stars\n-   **Twitter/X**: Technical content, updates, cross-chain positioning\n-   **Discord/Telegram**: Community support\n-   **Hackathons**: Sponsor Solana hackathons, participate in EVM events\n-   **Conferences**: Solana Breakpoint, DevCon, ETHGlobal, etc.\n\n#### 2. Content Marketing (20% of leads) - AI-Assisted\n\n-   **Technical Blog**: AI-assisted deep dives, tutorials (AI drafts, human refinement)\n-   **Documentation**: AI-generated comprehensive guides, API docs\n-   **Video Tutorials**: AI-assisted script writing, YouTube channel\n-   **Case Studies**: AI-assisted success story writing\n-   **Webinars**: AI-assisted presentation creation\n-   **SEO**: AI-powered SEO optimization, keyword research\n-   **Social Media**: AI-generated content, scheduling, engagement\n\n#### 3. Partnerships (15% of leads)\n\n-   **Protocol Partnerships**: Integrate with major Solana protocols, then EVM protocols\n-   **Infrastructure Partners**: RPC providers, validators (Solana), node providers (EVM)\n-   **Developer Tools**: Integrate with Solana tools, then EVM tools (Hardhat, Foundry)\n-   **Accelerators**: Partner with Solana-focused accelerators, then multi-chain accelerators\n-   **Bridge Providers**: Partner for cross-chain features\n\n#### 4. Direct Sales (5% of leads)\n\n-   **Enterprise Sales**: Direct outreach to institutions\n-   **Consulting**: Custom integration projects\n-   **Referrals**: Developer referrals\n\n### Sales Process\n\n#### Developer Adoption (Self-Service)\n\n1. Discover via GitHub/docs\n2. Install SDK (`npm install @fabriquant/sdk`)\n3. Follow quickstart guide\n4. Join community for support\n5. Upgrade to Enterprise (if needed)\n\n#### Enterprise Sales (Sales-Assisted)\n\n1. Initial contact (website, referral, event)\n2. Technical demo\n3. Pilot program\n4. Proposal and negotiation\n5. Implementation and onboarding\n6. Ongoing support and expansion\n\n### Pricing Strategy\n\n#### Freemium Model\n\n-   **Free**: Open-source SDK (MIT)\n-   **Pro**: $500/month (advanced features)\n-   **Enterprise**: Custom pricing ($5K-$50K/month)\n-   **Infrastructure**: Usage-based pricing\n\n#### Value-Based Pricing\n\n-   Cost savings from optimization\n-   Risk reduction value\n-   Time-to-market acceleration\n-   Compliance cost avoidance\n\n---"
        },
        {
          "heading": "Operations Plan",
          "body": "### Development Workflow\n\n#### Team Structure (Solopreneur Model)\n\n-   **Founder**: 100% of core work (engineering, product, strategy)\n-   **Contractors**: Strategic part-time support as needed\n    -   **Engineering**: Contractors for specific features (20-30% of dev work)\n    -   **Design**: Contractors for UI/UX (as needed)\n    -   **Marketing**: Contractors for content, SEO (10-20% of marketing)\n    -   **Support**: Community moderators (volunteer or small stipend)\n\n#### Development Process (AI-Enhanced)\n\n-   **Lean Methodology**: Focus on high-impact features\n-   **AI-Assisted Development**: GitHub Copilot, Cursor, ChatGPT for coding\n-   **GitHub Workflow**: Feature branches, AI-assisted code review, community PR reviews\n-   **CI/CD**: Automated testing and deployment (GitHub Actions, AI-assisted test generation)\n-   **Documentation**: AI-generated docs, continuous updates, community contributions\n-   **Community**: Open-source contributions, community-driven support (AI-assisted moderation)\n-   **Automation**: Maximize automation + AI to minimize manual work\n-   **AI Tools**: Integrated AI throughout development workflow\n\n### Infrastructure\n\n#### Hosting (Lean & Cost-Effective)\n\n-   **Cloud Providers**: Start with single provider (Vercel/Netlify for frontend, Railway/Fly.io for backend)\n-   **CDN**: Cloudflare (free tier initially)\n-   **Monitoring**: Sentry (free tier), Better Stack (affordable)\n-   **Analytics**: PostHog (open-source), Plausible (privacy-focused, affordable)\n-   **Cost Optimization**: Use free tiers, scale only when needed\n\n#### Security (Lean Approach)\n\n-   **Code Audits**: Community code reviews, periodic audits when revenue supports\n-   **Bug Bounty**: GitHub Security Advisories, community reporting\n-   **Security Monitoring**: Automated monitoring, community alerts\n-   **Compliance**: Start with basic security practices, add certifications when needed\n\n### Support\n\n#### Community Support (AI-Enhanced)\n\n-   **Discord**: Public community support (AI chatbot for common questions)\n-   **GitHub Issues**: Bug reports and feature requests (AI-assisted triage)\n-   **Documentation**: Self-service help (AI-powered search, FAQ generation)\n-   **Stack Overflow**: Tag monitoring (AI-assisted response drafting)\n-   **AI Chatbot**: 24/7 initial support, escalates to human when needed\n\n#### Enterprise Support (AI-Enhanced Solo)\n\n-   **SLA**: 99% uptime guarantee (realistic for solo)\n-   **Response Times**: <4 hours (critical), <24 hours (high), <48 hours (normal)\n-   **AI Initial Response**: AI chatbot provides immediate responses, escalates to human\n-   **Dedicated Support**: Enterprise customers (async, scheduled calls, AI-assisted prep)\n-   **On-Call**: Business hours + emergency escalation (AI handles initial triage)\n-   **Scaling**: Add dedicated support when revenue supports hiring\n-   **AI Tools**: AI-powered support ticket routing, response drafting, knowledge base\n\n---"
        },
        {
          "heading": "Management Team",
          "body": "### Founding Team\n\n#### Solo Founder - CEO, CTO, Product Lead\n\n-   **Background**: [Relevant experience]\n-   **Role**: Vision, strategy, engineering, product, marketing (full-stack solopreneur)\n-   **LinkedIn**: [Link]\n-   **Approach**: Bootstrap-first, sustainable growth, strategic contractors\n\n### Advisory Board (Optional)\n\n#### [Advisor Name] - [Title]\n\n-   **Background**: [Relevant experience]\n-   **Focus**: [Area of expertise]\n-   **Compensation**: Equity or advisory fee (when revenue supports)\n\n### Team Structure (Solopreneur Model)\n\n#### Year 1: Solo + Strategic Contractors\n\n-   **Founder**: Full-time (engineering, product, marketing, operations)\n-   **Contractors**:\n    -   Part-time developer (20-30% of dev work) - $2-4K/month\n    -   Part-time designer (as needed) - $500-1K/month\n    -   Part-time content writer (10% of marketing) - $500-1K/month\n-   **Total Team Cost**: $3-6K/month (contractors only)\n\n#### Year 2: Solo + Expanded Contractors\n\n-   **Founder**: Full-time\n-   **Contractors**:\n    -   Part-time developer (30-40% of dev work) - $3-5K/month\n    -   Part-time marketer (20% of marketing) - $1-2K/month\n    -   Part-time designer (as needed) - $500-1K/month\n    -   Community moderator (volunteer or small stipend) - $200-500/month\n-   **Total Team Cost**: $5-9K/month\n\n#### Year 3: Solo + Contractors + Consider First Hire\n\n-   **Founder**: Full-time\n-   **Contractors**:\n    -   Part-time developer (40-50% of dev work) - $4-6K/month\n    -   Part-time marketer (30% of marketing) - $2-3K/month\n    -   Part-time designer - $1K/month\n    -   Community moderator - $500/month\n-   **First Hire Consideration**: Part-time or full-time developer if revenue > $50K/month\n-   **Total Team Cost**: $8-11K/month (or $15-20K/month with first hire)\n\n#### Year 4-5: Scale Gradually\n\n-   **Founder**: Full-time\n-   **First Employee**: Full-time developer or marketer ($80-120K/year)\n-   **Contractors**: Continue strategic contractors for specialized work\n-   **Total Team Cost**: $20-30K/month\n\n### Leverage Strategy\n\n-   **Open Source Community**: Leverage community contributions, PR reviews\n-   **Automation**: Maximize CI/CD, automated testing, self-service onboarding\n-   **Self-Service**: Documentation, community forums, async support\n-   **Strategic Partnerships**: Integrate with existing tools, leverage partner marketing\n\n---"
        },
        {
          "heading": "Financial Projections",
          "body": "### Revenue Model (Solopreneur-Optimized)\n\n#### Revenue Streams (Priority Order for Solo)\n\n1. **Consulting & Integration** (40-50% of revenue initially)\n\n    - Project-based fees ($5K-50K per project)\n    - Hourly consulting ($150-300/hour)\n    - Training workshops ($1K-5K per workshop)\n    - **Why First**: Immediate cash flow, high leverage, builds relationships\n\n2. **Enterprise Subscriptions** (30-40% of revenue)\n\n    - Monthly/annual subscriptions\n    - Tiered pricing ($500-5K/month)\n    - Volume discounts\n    - **Why Second**: Recurring revenue but requires support capacity\n\n3. **Infrastructure Services** (10-20% of revenue)\n\n    - Usage-based pricing (automated, low maintenance)\n    - Managed services\n    - API access\n    - **Why Third**: Automated, scales well, but lower margins initially\n\n4. **Other** (5-10% of revenue)\n    - Grants (Solana Foundation, etc.)\n    - Partnerships (revenue share)\n    - Licensing (if applicable)\n\n### 5-Year Financial Projections (Solopreneur Model)\n\n#### Year 1 (2025)\n\n| Metric                   | Value                  |\n| ------------------------ | ---------------------- |\n| **Revenue**              | $50,000 - $100,000     |\n| **Enterprise Customers** | 2-5                    |\n| **Free Users**           | 100-200+               |\n| **Team Size**            | 1 (solo) + contractors |\n| **Burn Rate**            | $3,000 - $5,000/month  |\n| **Profitability**        | Break-even Q4          |\n| **Cross-Chain Revenue**  | $0 (Solana focus)      |\n\n**Revenue Breakdown**:\n\n-   Consulting: $25,000 - $50,000 (50%)\n-   Enterprise: $15,000 - $30,000 (30%)\n-   Infrastructure: $5,000 - $15,000 (15%)\n-   Other (grants): $5,000 - $5,000 (5%)\n\n#### Year 2 (2026)\n\n| Metric                   | Value                 |\n| ------------------------ | --------------------- |\n| **Revenue**              | $150,000 - $300,000   |\n| **Enterprise Customers** | 5-10                  |\n| **Free Users**           | 500-1,000+            |\n| **Team Size**            | 1-2 (contractors)     |\n| **Burn Rate**            | $5,000 - $8,000/month |\n| **Profitability**        | Profitable            |\n| **Cross-Chain Revenue**  | $0-50K (EVM prep)     |\n\n**Revenue Breakdown**:\n\n-   Consulting: $60,000 - $120,000 (40%)\n-   Enterprise: $60,000 - $120,000 (40%)\n-   Infrastructure: $20,000 - $50,000 (15%)\n-   Other: $10,000 - $10,000 (5%)\n\n#### Year 3 (2027)\n\n| Metric                   | Value                   |\n| ------------------------ | ----------------------- |\n| **Revenue**              | $300,000 - $600,000     |\n| **Enterprise Customers** | 10-20                   |\n| **Free Users**           | 1,500-3,000+            |\n| **Team Size**            | 2-3 (contractors)       |\n| **Burn Rate**            | $8,000 - $12,000/month  |\n| **Profit Margin**        | 40-50%                  |\n| **Cross-Chain Revenue**  | $100K-200K (EVM launch) |\n\n**Revenue Breakdown**:\n\n-   Enterprise: $150,000 - $300,000 (50%)\n-   Consulting: $90,000 - $180,000 (30%)\n-   Infrastructure: $45,000 - $90,000 (15%)\n-   Other: $15,000 - $30,000 (5%)\n\n**Cross-Chain Breakdown** (of $100-200K):\n\n-   EVM Guard: $60,000 - $120,000 (60%)\n-   EVM Risk: $30,000 - $60,000 (30%)\n-   Cross-chain consulting: $10,000 - $20,000 (10%)\n\n#### Year 4 (2028)\n\n| Metric                   | Value                   |\n| ------------------------ | ----------------------- |\n| **Revenue**              | $500,000 - $1,000,000   |\n| **Enterprise Customers** | 20-40                   |\n| **Free Users**           | 3,000-5,000+            |\n| **Team Size**            | 3-4 (contractors)       |\n| **Burn Rate**            | $12,000 - $18,000/month |\n| **Profit Margin**        | 45-55%                  |\n| **Cross-Chain Revenue**  | $200K-400K (Full EVM)   |\n\n**Revenue Breakdown**:\n\n-   Enterprise: $300,000 - $600,000 (60%)\n-   Consulting: $125,000 - $250,000 (25%)\n-   Infrastructure: $50,000 - $100,000 (10%)\n-   Other: $25,000 - $50,000 (5%)\n\n#### Year 5 (2029)\n\n| Metric                   | Value                     |\n| ------------------------ | ------------------------- |\n| **Revenue**              | $800,000 - $1,500,000     |\n| **Enterprise Customers** | 40-80                     |\n| **Free Users**           | 5,000-10,000+             |\n| **Team Size**            | 4-5 (consider first hire) |\n| **Burn Rate**            | $18,000 - $30,000/month   |\n| **Profit Margin**        | 50%+                      |\n| **Cross-Chain Revenue**  | $400K-800K (Cross-chain)  |\n\n**Revenue Breakdown**:\n\n-   Enterprise: $480,000 - $900,000 (60%)\n-   Consulting: $200,000 - $375,000 (25%)\n-   Infrastructure: $80,000 - $150,000 (10%)\n-   Other: $40,000 - $75,000 (5%)\n\n### Unit Economics (Solopreneur Model)\n\n#### Customer Acquisition Cost (CAC)\n\n-   **Year 1**: $500-1,000 (community-driven, organic)\n-   **Year 2**: $1,000-2,000 (content marketing, SEO)\n-   **Year 3**: $2,000-3,000 (scaling marketing)\n-   **Year 4-5**: $3,000-5,000 (enterprise focus)\n\n#### Lifetime Value (LTV)\n\n-   **Average Contract Value**: $30,000-60,000/year (conservative)\n-   **Average Contract Length**: 2-3 years\n-   **LTV**: $60,000-180,000\n-   **LTV:CAC Ratio**: 60:1 (Year 1), 30:1 (Year 2), 20:1 (Year 3)\n\n#### Payback Period\n\n-   **Year 1**: 1-2 months (low CAC, community-driven)\n-   **Year 2**: 2-3 months\n-   **Year 3**: 3-4 months\n\n---"
        },
        {
          "heading": "Funding Requirements (Bootstrap-First Strategy)",
          "body": "### Funding Strategy\n\n**Primary Approach**: Bootstrap with personal investment + grants  \n**Optional**: Micro-seed ($100-300K) if scaling faster desired  \n**Future**: Consider seed round ($500K-1M) only if revenue > $50K/month and scaling needed\n\n### Bootstrap Capital Requirements\n\n**Year 1**: $15,000 - $30,000 personal investment (reduced with AI)\n\n-   AI Tools: $2,400-4,800/year (GitHub Copilot, ChatGPT Plus, Cursor, etc.)\n-   Hosting & tools: $2,000/year\n-   Contractors: $15,000-25,000/year (reduced due to AI assistance)\n-   Marketing (AI-assisted content, design): $3,000-6,000/year (reduced with AI)\n-   Legal/incorporation: $3,000-5,000 (one-time)\n\n**Year 2**: $30,000 - $60,000 (revenue + personal)\n\n-   Hosting & tools: $5,000/year\n-   Contractors: $40,000-50,000/year\n-   Marketing: $10,000-15,000/year\n\n**Year 3**: Self-sustaining from revenue\n\n### Grant Opportunities\n\n-   **Solana Foundation**: $10-50K grants for ecosystem development\n-   **Ethereum Foundation**: $5-25K grants for EVM work\n-   **Protocol Grants**: Jupiter, Uniswap, etc. ($5-20K each)\n-   **Total Potential**: $30-100K in grants over 2-3 years\n\n### Optional Micro-Seed ($100-300K)\n\n**Use of Funds** (if raising):\n\n| Category        | Amount          | Percentage |\n| --------------- | --------------- | ---------- |\n| **Contractors** | $60,000-120,000 | 60%        |\n| **Marketing**   | $20,000-60,000  | 20%        |\n| **Operations**  | $10,000-60,000  | 15%        |\n| **Reserve**     | $10,000-60,000  | 5%         |\n\n### Milestones (Solopreneur Timeline)\n\n#### 6 Months\n\n-   Complete Phase 2 (Pattern Library)\n-   2-5 enterprise customers\n-   $10-20K ARR\n-   100-200 free users\n-   Break-even or close\n\n#### 12 Months\n\n-   Complete Phase 2.5 (Chain Abstraction)\n-   5-10 enterprise customers\n-   $50-100K ARR\n-   500-1,000 free users\n-   Profitable\n\n#### 18 Months\n\n-   Launch Phase 3 (EVM Guard/Risk beta)\n-   10-15 enterprise customers\n-   $100-200K ARR\n-   1,000-2,000 free users\n-   Consider first contractor hire\n\n#### 24 Months\n\n-   Full EVM Guard/Risk launch\n-   15-25 enterprise customers\n-   $200-400K ARR\n-   2,000-3,000 free users\n-   Consider micro-seed if scaling needed\n\n### Previous Funding\n\n-   **Bootstrap**: $20-40K personal investment (Year 1)\n-   **Grants**: $10-30K from Solana Foundation, protocols (Year 1-2)\n-   **Use**: Initial development, contractors, marketing\n\n---"
        },
        {
          "heading": "Risk Analysis",
          "body": "### Technical Risks\n\n| Risk                         | Impact | Probability | Mitigation                           |\n| ---------------------------- | ------ | ----------- | ------------------------------------ |\n| **Solana network issues**    | High   | Medium      | Multi-chain strategy (future)        |\n| **Security vulnerabilities** | High   | Low         | Regular audits, bug bounty           |\n| **Technology obsolescence**  | Medium | Low         | Continuous innovation                |\n| **Integration complexity**   | Medium | Medium      | Comprehensive documentation, support |\n\n### Market Risks\n\n| Risk                              | Impact | Probability | Mitigation                       |\n| --------------------------------- | ------ | ----------- | -------------------------------- |\n| **Market downturn**               | High   | Medium      | Diversified revenue streams      |\n| **Competition**                   | Medium | High        | First-mover advantage, community |\n| **Regulatory changes**            | High   | Low         | Compliance focus, legal counsel  |\n| **Adoption slower than expected** | Medium | Medium      | Strong marketing, partnerships   |\n\n### Operational Risks\n\n| Risk                        | Impact | Probability | Mitigation (Solopreneur)                                                   |\n| --------------------------- | ------ | ----------- | -------------------------------------------------------------------------- |\n| **Key person risk**         | High   | High        | Comprehensive documentation, community support, contractors for continuity |\n| **Scaling challenges**      | Medium | Medium      | Gradual contractor scaling, automated processes, self-service              |\n| **Customer churn**          | Medium | Medium      | Strong support (async), value delivery, community-driven help              |\n| **Infrastructure failures** | High   | Low         | Managed services, redundancy, monitoring                                   |\n| **Burnout**                 | High   | Medium      | Sustainable pace, automation, strategic contractors, work-life balance     |\n| **Limited capacity**        | Medium | High        | Focus on high-leverage activities, automate, self-service, community       |\n\n### Financial Risks\n\n| Risk                              | Impact | Probability | Mitigation                       |\n| --------------------------------- | ------ | ----------- | -------------------------------- |\n| **Funding shortfall**             | High   | Low         | Multiple funding sources         |\n| **Burn rate too high**            | Medium | Medium      | Regular monitoring, adjustments  |\n| **Revenue slower than projected** | Medium | Medium      | Conservative projections, pivots |\n\n---"
        },
        {
          "heading": "Growth Strategy",
          "body": "### Short-Term (0-12 months) - Solopreneur Focus\n\n1. **Product Development**\n\n    - Complete SDK consolidation ✅\n    - Launch pattern library (Q2 2025)\n    - Begin chain abstraction design\n    - **Focus**: High-impact features only\n\n2. **Community Building**\n\n    - Reach 100-500 GitHub stars (realistic for solo)\n    - Active Discord community (50-200 members)\n    - 3-5 protocol integrations\n    - **Focus**: Quality over quantity\n\n3. **Customer Acquisition**\n    - 2-5 enterprise customers (realistic)\n    - $50-100K ARR\n    - 1-2 case studies\n    - **Focus**: Consulting + small enterprise deals\n\n### Medium-Term (12-36 months) - Sustainable Growth\n\n1. **Market Expansion**\n\n    - **EVM chain support** (Ethereum, Polygon, Arbitrum) - Year 3\n    - **Cross-chain features** (unified liquidity) - Year 4\n    - Vertical-specific solutions - Year 4-5\n\n2. **Product Enhancement**\n\n    - Chain abstraction layer (Year 2)\n    - **EVM Guard and Risk** (Year 3)\n    - **EVM Flow and Patterns** (Year 4)\n    - Full ZK stack integration (Solana) - Year 3-4\n    - **Focus**: One major feature per year\n\n3. **Partnerships**\n    - Major Solana protocol partnerships (Year 2-3)\n    - **EVM protocol partnerships** (Year 3-4)\n    - Infrastructure provider partnerships (Year 3+)\n    - **Focus**: Strategic, high-impact partnerships\n\n### Long-Term (36+ months) - Scale When Ready\n\n1. **Platform Evolution**\n\n    - Fabriquant Mainnet launch (Year 5+)\n    - Governance token (if/when needed)\n    - Decentralized network (if/when needed)\n\n2. **Market Leadership**\n\n    - #1 Solana execution SDK (Year 3-4)\n    - #1 Cross-chain security layer (Year 4-5)\n    - 5,000+ developers (Year 5)\n    - $1M+ ARR (Year 5)\n\n3. **Scaling Decision**\n    - **Year 3-4**: Consider first employee if revenue > $50K/month\n    - **Year 4-5**: Consider micro-seed if scaling needed\n    - **Year 5+**: Consider seed round or continue solo\n    - **Exit Strategy**: Strategic acquisition, continue solo, or scale with funding\n\n---"
        },
        {
          "heading": "Cross-Chain Strategy",
          "body": "### Strategic Positioning\n\n**\"Solana-First, Cross-Chain Enabled\"**\n\nFabriquant maintains leadership in Solana's parallel execution while expanding portable components (Guard, Risk, Flow, Patterns) to EVM chains. This hybrid approach maximizes market opportunity while preserving competitive differentiation.\n\n### Why Cross-Chain?\n\n#### Market Opportunity\n\n1. **4x Market Expansion**\n\n    - Solana: 50,000 developers, $100B TVL potential\n    - EVM: 200,000 developers, $200B+ TVL\n    - Combined: 250,000 developers, $300B+ TVL\n\n2. **Enterprise Demand**\n\n    - Multi-chain protocols prefer unified solutions\n    - Enterprise deals 2-3x larger with cross-chain support\n    - Reduces single-chain risk for customers\n\n3. **Competitive Positioning**\n    - No strong cross-chain execution layer exists\n    - First-mover advantage with portable components\n    - Solana expertise differentiates from EVM-only tools\n\n### Portable Components Strategy\n\n#### High Priority (80% Portable)\n\n1. **Guard (Security Layer)**\n\n    - **Portability**: ~80% logic is chain-agnostic\n    - **Chain-Specific**: Pattern detection (Solana instructions vs EVM calls)\n    - **Market Need**: Universal security demand\n    - **Revenue Potential**: High (enterprise security)\n    - **Timeline**: Q3 2025\n\n2. **Risk (Pulsar)**\n\n    - **Portability**: ~90% logic is chain-agnostic\n    - **Chain-Specific**: Oracle integrations, asset formats\n    - **Market Need**: Universal risk assessment\n    - **Revenue Potential**: High (institutional demand)\n    - **Timeline**: Q3 2025\n\n3. **Flow (Liquidity Routing)**\n\n    - **Portability**: Concepts transfer, implementations differ\n    - **Chain-Specific**: DEX integrations (Solana vs Uniswap/Curve)\n    - **Market Need**: Multi-DEX routing on all chains\n    - **Revenue Potential**: Medium-High (DeFi protocols)\n    - **Timeline**: Q4 2025\n\n4. **Pattern Library**\n    - **Portability**: ~70% patterns are chain-agnostic\n    - **Chain-Specific**: Implementation details\n    - **Market Need**: Reusable execution patterns\n    - **Revenue Potential**: Medium (developer tools)\n    - **Timeline**: Q4 2025\n\n#### Solana-Specific (Maintain Leadership)\n\n1. **Loom (Parallel Execution)**\n\n    - **Solana-Only**: True parallel execution unique to Solana\n    - **EVM Adaptation**: Focus on bundling/optimization (not parallelism)\n    - **Differentiator**: Core competitive advantage\n    - **Strategy**: Maintain Solana leadership, adapt for EVM L2s\n\n2. **Privacy (ZK Compression)**\n    - **Solana**: Light Protocol (native)\n    - **EVM**: Multiple solutions (zkSync, Aztec, Polygon zkEVM)\n    - **Strategy**: Support multiple ZK stacks, maintain Solana advantage\n\n### Implementation Phases\n\n#### Phase 1: Foundation (Q2-Q3 2025)\n\n**Goal**: Strengthen Solana position, prepare for cross-chain\n\n-   Complete Solana Pattern Library (Phase 2)\n-   Design chain abstraction architecture\n-   Refactor Guard for chain-agnostic core\n-   Refactor Risk for multi-chain support\n-   Create chain adapter interfaces\n\n**Success Metrics**:\n\n-   Solana: 1,000+ GitHub stars, 500+ developers\n-   Architecture: Chain abstraction layer designed\n-   Code: Guard/Risk refactored for portability\n\n#### Phase 2: EVM Launch (Q3-Q4 2025)\n\n**Goal**: Launch Guard and Risk for EVM\n\n-   Implement EVM adapter for Guard\n-   Implement EVM adapter for Risk\n-   Add EVM-specific security patterns\n-   Integrate EVM oracles (Chainlink, etc.)\n-   Launch beta for Ethereum, Polygon, Arbitrum\n\n**Success Metrics**:\n\n-   EVM: 100+ developer signups, 3+ protocol integrations\n-   Revenue: $200K+ EVM revenue (Q4)\n-   Quality: EVM Guard/Risk production-ready\n\n#### Phase 3: Full Cross-Chain (Q4 2025 - Q1 2026)\n\n**Goal**: Complete cross-chain support\n\n-   Launch Flow for EVM (Uniswap, Curve routing)\n-   EVM pattern library\n-   Cross-chain liquidity access\n-   Cross-chain arbitrage patterns\n-   Unified API documentation\n\n**Success Metrics**:\n\n-   EVM: 500+ developers, 10+ protocol integrations\n-   Revenue: $600K+ EVM revenue (Year 2)\n-   Features: Full cross-chain execution layer\n\n### Technical Architecture\n\n#### Chain Abstraction Layer\n\n```typescript\n// Unified chain interface\ninterface ChainAdapter {\n    chain: \"solana\" | \"ethereum\" | \"polygon\" | \"arbitrum\";\n    buildTransaction(tx: UnifiedTransaction): ChainTransaction;\n    executeTransaction(tx: ChainTransaction): Promise<TransactionResult>;\n    estimateCost(tx: ChainTransaction): Promise<bigint>;\n}\n\n// Portable components work with unified interface\nclass Guard {\n    validateTransaction(\n        tx: UnifiedTransaction,\n        chain: ChainAdapter\n    ): ValidationResult {\n        // Chain-agnostic validation logic\n        // Chain-specific patterns via adapter\n    }\n}\n```\n\n#### Component Portability Matrix\n\n| Component    | Portability | Solana-Specific     | EVM-Specific             | Timeline |\n| ------------ | ----------- | ------------------- | ------------------------ | -------- |\n| **Guard**    | 80%         | Pattern detection   | Reentrancy, flash loans  | Q3 2025  |\n| **Risk**     | 90%         | Oracle integrations | Chainlink, asset formats | Q3 2025  |\n| **Flow**     | 60%         | DEX integrations    | Uniswap, Curve routing   | Q4 2025  |\n| **Patterns** | 70%         | Implementation      | EVM patterns             | Q4 2025  |\n| **Loom**     | 20%         | Parallel execution  | Bundling only            | TBD      |\n| **Privacy**  | 30%         | Light Protocol      | Multiple ZK stacks       | TBD      |\n\n### Risk Mitigation\n\n#### Technical Risks\n\n-   **Architecture Complexity**: Mitigated by phased approach, adapter pattern\n-   **Resource Dilution**: Dedicated EVM team, maintain Solana focus\n-   **Performance**: Chain-specific optimizations, unified API\n\n#### Business Risks\n\n-   **Identity Confusion**: \"Solana-First\" messaging, clear positioning\n-   **Market Timing**: Start with highest-demand components (Guard/Risk)\n-   **Competition**: First-mover advantage, Solana differentiation\n\n### Success Metrics (Solopreneur Realistic)\n\n#### Solana Metrics (Maintain Leadership)\n\n-   GitHub stars: 100-500 (Year 1), 1,000+ (Year 3), 3,000+ (Year 5)\n-   Solana developer adoption: 100+ (Year 1), 1,000+ (Year 3), 3,000+ (Year 5)\n-   Solana protocol integrations: 3-5 (Year 1), 10+ (Year 3), 20+ (Year 5)\n-   Solana revenue: $50-100K (Year 1), $200-400K (Year 3), $500K+ (Year 5)\n\n#### Cross-Chain Metrics (New Growth)\n\n-   EVM developer signups: 0 (Year 1), 50+ (Year 3), 500+ (Year 5)\n-   EVM protocol integrations: 0 (Year 1), 3+ (Year 3), 10+ (Year 5)\n-   Cross-chain revenue: $0 (Year 1), $100-200K (Year 3), $400-800K (Year 5)\n-   Enterprise inquiries: 2-5 (Year 1), 10+ (Year 3), 20+ (Year 5)\n\n### Competitive Advantages\n\n1. **Solana Leadership**: Deep expertise in parallel execution\n2. **Cross-Chain Security**: Unified Guard across chains\n3. **Cross-Chain Risk**: Unified Risk assessment\n4. **Unified API**: One SDK for Solana and EVM\n5. **First-Mover**: Only cross-chain execution layer with Solana expertise\n\n---"
        },
        {
          "heading": "Solopreneur Strategy",
          "body": "### Operating Model\n\n**Core Philosophy**: Bootstrap-first, sustainable growth, strategic scaling only when revenue supports it.\n\n### Key Principles\n\n1. **High-Leverage Activities First**\n\n    - Open-source SDK → Community → Leads\n    - Content marketing → SEO → Organic growth\n    - Consulting → Cash flow → Product development\n\n2. **Leverage AI Tools Extensively** (NEW)\n\n    - **Development**: AI code generation, debugging, documentation\n    - **Marketing**: AI content creation, SEO optimization, social media\n    - **Support**: AI chatbots, automated responses, FAQ generation\n    - **Operations**: AI analytics, reporting, automation\n    - **Sales**: AI email writing, lead qualification, follow-ups\n    - **Research**: AI research assistants, competitive analysis\n\n3. **Automate Everything**\n\n    - CI/CD, automated testing\n    - Self-service onboarding\n    - Community-driven support\n    - Automated billing and invoicing\n    - AI-powered workflows and automations\n\n4. **Focus on What You're Best At**\n\n    - If technical: Focus on product, use AI for marketing/content\n    - If marketing: Focus on growth, use AI for development assistance\n    - Always: Use AI to amplify your strengths, fill your gaps\n    - Always: Focus on high-impact, high-value work\n\n5. **Build in Public**\n\n    - Share progress, build community\n    - Leverage community for feedback, contributions\n    - Creates natural marketing and trust\n    - Use AI to help with content creation and sharing\n\n6. **Start Small, Scale Gradually**\n    - Don't hire until you can afford it\n    - Use AI tools + contractors before employees\n    - Only scale when revenue supports it\n    - Maintain work-life balance\n\n### Resource Allocation\n\n#### Time Allocation (Typical Week - AI-Assisted)\n\n-   **Development** (40-50%): Core product, features, bug fixes (AI-assisted coding)\n-   **Marketing** (15-20%): Strategy, review AI-generated content, community engagement\n-   **Sales/Support** (15-20%): Customer calls, support, consulting (AI-assisted responses)\n-   **Operations** (10-15%): Admin, planning, contractor management (AI-assisted)\n-   **AI Tool Management** (5-10%): Prompting, reviewing AI outputs, optimizing workflows\n\n**AI Impact**: Reduces time needed for marketing (content creation), support (initial responses), and operations (reporting, analysis) by 50-70%\n\n#### Financial Allocation\n\n-   **Year 1**: $3-5K/month burn\n\n    -   AI Tools: $200-400/month (GitHub Copilot, ChatGPT Plus, Cursor, etc.)\n    -   Contractors: $1.5-2.5K/month (reduced due to AI assistance)\n    -   Tools/Hosting: $500/month\n    -   Marketing: $300-600/month (reduced due to AI content creation)\n    -   Buffer: $500-1K/month\n\n-   **Year 2**: $5-8K/month burn\n\n    -   AI Tools: $300-600/month (expanded AI tool suite)\n    -   Contractors: $2.5-4K/month (strategic use, AI-assisted)\n    -   Tools/Hosting: $1K/month\n    -   Marketing: $800-1.5K/month (AI-assisted, more efficient)\n    -   Buffer: $1K/month\n\n-   **Year 3**: $8-12K/month burn\n    -   AI Tools: $400-800/month (premium AI tools, API access)\n    -   Contractors: $4-6K/month (focused on high-value work)\n    -   Tools/Hosting: $1-2K/month\n    -   Marketing: $1.5-2.5K/month (AI-powered campaigns)\n    -   Buffer: $1-2K/month\n\n### Leverage Strategies\n\n#### Community Leverage\n\n-   **Open Source**: Community contributions, PR reviews, bug reports\n-   **Documentation**: Community improvements, translations\n-   **Support**: Community moderators, Discord helpers\n-   **Marketing**: Community shares, word-of-mouth\n\n#### Automation Leverage\n\n-   **CI/CD**: GitHub Actions (free), automated testing\n-   **Deployment**: Vercel/Netlify (free tier), Railway (affordable)\n-   **Monitoring**: Sentry (free tier), Better Stack (affordable)\n-   **Analytics**: PostHog (open-source), Plausible (affordable)\n\n#### AI Tool Leverage (Primary Multiplier)\n\n**Development & Engineering**:\n\n-   **Code Generation**: GitHub Copilot ($10-20/month), Cursor ($20/month), ChatGPT Plus ($20/month)\n-   **Code Review**: AI-powered PR reviews, security scanning\n-   **Documentation**: AI-generated API docs, tutorials, guides\n-   **Testing**: AI-assisted test generation, bug detection\n-   **Debugging**: AI-powered debugging assistance\n-   **Time Savings**: 40-60% reduction in development time\n\n**Marketing & Content**:\n\n-   **Content Creation**: ChatGPT, Claude, Jasper ($50-100/month)\n-   **SEO**: AI SEO tools, keyword research, content optimization\n-   **Social Media**: AI scheduling, content generation, engagement\n-   **Email Marketing**: AI email writing, personalization\n-   **Time Savings**: 60-80% reduction in content creation time\n\n**Customer Support**:\n\n-   **Chatbots**: AI-powered support bots (Intercom AI, custom GPTs)\n-   **FAQ Generation**: AI-generated FAQs from documentation\n-   **Email Responses**: AI-assisted response drafting\n-   **Time Savings**: 70-90% reduction in support time\n\n**Operations & Analytics**:\n\n-   **Data Analysis**: AI-powered insights, reporting\n-   **Research**: AI research assistants, competitive analysis\n-   **Automation**: AI-powered workflow automation\n-   **Time Savings**: 50-70% reduction in operational tasks\n\n**Cost-Benefit**: $200-800/month in AI tools replaces $5-15K/month in contractor costs\n\n#### Contractor Leverage\n\n-   **Development**: Part-time contractors for specific features (AI-assisted)\n-   **Design**: Contractors for complex UI/UX, branding (AI for initial drafts)\n-   **Marketing**: Contractors for strategy, complex campaigns (AI for content)\n-   **Support**: Community moderators (volunteer or small stipend)\n\n### AI Tool Stack (Recommended)\n\n#### Development Tools\n\n-   **GitHub Copilot** ($10-20/month): Code generation, autocomplete\n-   **Cursor** ($20/month): AI-powered IDE, code editing\n-   **ChatGPT Plus** ($20/month): Code assistance, debugging, documentation\n-   **Claude** ($20/month): Code review, technical writing\n-   **Codeium** (Free tier available): Alternative code generation\n\n#### Marketing & Content Tools\n\n-   **ChatGPT Plus** ($20/month): Content creation, blog posts, social media\n-   **Claude** ($20/month): Long-form content, documentation\n-   **Jasper** ($50-100/month): Marketing copy, SEO content\n-   **Copy.ai** ($50/month): Marketing copy, email writing\n-   **Grammarly** ($12/month): Writing assistance, editing\n\n#### Support & Operations Tools\n\n-   **Intercom AI** ($100+/month): AI chatbot for customer support\n-   **Zapier AI** ($50+/month): AI-powered workflow automation\n-   **Make.com AI** ($20+/month): AI automation workflows\n-   **Custom GPTs**: Build custom AI assistants for specific tasks\n\n#### Analytics & Research Tools\n\n-   **ChatGPT Plus**: Market research, competitive analysis\n-   **Perplexity** ($20/month): AI research assistant\n-   **Notion AI** ($10/month): AI-powered note-taking, research\n-   **Claude**: Data analysis, insights\n\n#### Total AI Tool Cost\n\n-   **Year 1**: $200-400/month ($2,400-4,800/year)\n-   **Year 2**: $300-600/month ($3,600-7,200/year)\n-   **Year 3**: $400-800/month ($4,800-9,600/year)\n\n**ROI**: $200-800/month in AI tools replaces $5-15K/month in contractor costs, 10-20x ROI\n\n### AI Workflow Examples\n\n#### Development Workflow\n\n1. **Planning**: Use AI to generate feature specs, user stories\n2. **Coding**: Use Copilot/Cursor for code generation\n3. **Testing**: Use AI to generate test cases\n4. **Documentation**: Use AI to generate API docs, guides\n5. **Review**: Use AI for initial code review, then human review\n\n#### Marketing Workflow\n\n1. **Strategy**: Use AI for content strategy, keyword research\n2. **Creation**: Use AI to draft blog posts, social media content\n3. **Optimization**: Use AI for SEO optimization, A/B testing ideas\n4. **Distribution**: Use AI for scheduling, engagement\n5. **Analysis**: Use AI for content performance analysis\n\n#### Support Workflow\n\n1. **Initial Response**: AI chatbot handles common questions\n2. **Escalation**: AI routes complex issues to human\n3. **Response Drafting**: AI drafts responses, human reviews\n4. **Knowledge Base**: AI generates FAQs from support tickets\n5. **Analysis**: AI analyzes support patterns, identifies issues\n\n### Scaling Decision Framework\n\n#### When to Hire First Employee\n\n**Consider hiring when**:\n\n-   Revenue consistently > $50K/month\n-   Can afford $80-120K/year salary\n-   Have 6+ months runway after hiring\n-   Workload consistently > 60 hours/week\n-   Clear role definition and need\n\n**Don't hire if**:\n\n-   Revenue < $30K/month\n-   Can't afford 6+ months runway\n-   Workload manageable with contractors\n-   Unclear role or need\n\n#### When to Raise Funding\n\n**Consider raising when**:\n\n-   Revenue > $50K/month consistently\n-   Clear path to $200K+ ARR\n-   Need capital to accelerate growth\n-   Have product-market fit\n-   Can demonstrate traction\n\n**Don't raise if**:\n\n-   Can bootstrap to profitability\n-   Revenue < $20K/month\n-   Unclear product-market fit\n-   No clear use for capital\n-   Prefer independence\n\n### Risk Mitigation (Solopreneur-Specific)\n\n#### Burnout Prevention\n\n-   **Sustainable Pace**: 40-50 hours/week max\n-   **Time Blocking**: Dedicated time for deep work\n-   **Automation**: Reduce manual work\n-   **Delegation**: Use contractors for non-core work\n-   **Breaks**: Regular time off, vacations\n\n#### Single Point of Failure\n\n-   **Documentation**: Comprehensive docs for continuity\n-   **Community**: Build community that can help\n-   **Contractors**: Have backup contractors\n-   **Processes**: Document processes and workflows\n-   **Backup Plans**: Plan for illness, emergencies\n\n#### Revenue Volatility\n\n-   **Diversify**: Multiple revenue streams\n-   **Retainers**: Prefer retainer contracts\n-   **Emergency Fund**: 6+ months expenses saved\n-   **Consulting Buffer**: Consulting for cash flow\n-   **Grants**: Apply for grants as buffer\n\n### Success Metrics (Solopreneur)\n\n#### Year 1 Success\n\n-   ✅ Break-even or profitable\n-   ✅ 100+ GitHub stars\n-   ✅ 2-5 paying customers\n-   ✅ $50-100K revenue\n-   ✅ Sustainable work pace\n\n#### Year 2 Success\n\n-   ✅ Profitable, growing\n-   ✅ 500+ GitHub stars\n-   ✅ 5-10 paying customers\n-   ✅ $150-300K revenue\n-   ✅ Established community\n\n#### Year 3 Success\n\n-   ✅ Highly profitable\n-   ✅ 1,000+ GitHub stars\n-   ✅ 10-20 paying customers\n-   ✅ $300-600K revenue\n-   ✅ Consider first hire or continue solo\n\n### Long-Term Vision\n\n**Path 1: Continue Solo**\n\n-   Maintain solo + contractors model\n-   Focus on profitability and lifestyle\n-   Scale revenue to $1-2M/year solo\n-   Consider as lifestyle business\n\n**Path 2: Strategic Hire**\n\n-   Hire first employee at Year 3-4\n-   Scale to $2-5M/year with small team\n-   Maintain lean operations\n-   Consider micro-seed if needed\n\n**Path 3: Scale with Funding**\n\n-   Raise seed round at Year 4-5\n-   Build team of 5-10 people\n-   Scale to $5-10M/year\n-   Consider exit or continue growth\n\n**Decision Point**: Re-evaluate at Year 3 based on revenue, market opportunity, and personal goals.\n\n---"
        },
        {
          "heading": "Appendices",
          "body": "### Appendix A: Market Research\n\n-   Solana ecosystem growth data\n-   EVM ecosystem growth data\n-   Cross-chain protocol statistics\n-   DeFi protocol statistics\n-   AI agent market analysis\n-   Competitive landscape analysis (Solana + EVM)\n\n### Appendix B: Technical Documentation\n\n-   Architecture diagrams (Solana + cross-chain)\n-   Chain abstraction architecture\n-   API specifications (unified + chain-specific)\n-   Security audit reports\n-   Performance benchmarks (Solana + EVM)\n\n### Appendix C: Financial Details\n\n-   Detailed P&L projections\n-   Cash flow statements\n-   Balance sheet projections\n-   Unit economics analysis\n\n### Appendix D: Team Resumes\n\n-   Founder backgrounds\n-   Key team member profiles\n-   Advisory board members\n\n### Appendix E: Customer Testimonials\n\n-   Early adopter quotes\n-   Case studies\n-   Integration success stories\n\n### Appendix F: Legal Documents\n\n-   Terms of Service\n-   Privacy Policy\n-   Enterprise agreements\n-   Partnership agreements\n\n---"
        },
        {
          "heading": "Contact Information",
          "body": "**Company**: Fabriquant  \n**Website**: https://github.com/fabriquant-labs/fabriquant  \n**Email**: [Contact Email]  \n**Twitter**: [@psyto](https://x.com/psyto)  \n**GitHub**: [fabriquant-labs/fabriquant](https://github.com/fabriquant-labs/fabriquant)\n\n---\n\n**Document Version**: 3.1  \n**Last Updated**: January 2025  \n**Confidentiality**: This document contains confidential and proprietary information.\n\n### Document History\n\n-   **v1.0** (January 2025): Initial business plan, Solana-focused\n-   **v2.0** (January 2025): Added cross-chain strategy, updated positioning to \"Solana-First, Cross-Chain Enabled\"\n-   **v3.0** (January 2025): Revised for solopreneur model - bootstrap-first, sustainable growth, realistic projections\n-   **v3.1** (January 2025): Added comprehensive AI tool leverage strategy - maximizing generative AI throughout operations"
        }
      ],
      "wordCount": 6889
    },
    {
      "path": "CHANGELOG.md",
      "title": "Changelog",
      "content": "# Changelog\n\nAll notable changes to the Fabriquant SDK will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [0.1.0] - 2025-12-22\n\n### Major Rebranding\n\nThis release represents a complete rebranding of the project from \"Fabricant\" to \"Fabriquant\" with updated naming conventions for all components.\n\n#### Project Naming\n- **BREAKING**: Renamed project from `fabricant` to `fabriquant`\n- **BREAKING**: Package name changed from `@fabricant/sdk` to `@fabriquant/sdk`\n- Updated all documentation and examples to reflect new branding\n\n#### Component Naming Changes\n\nThe component naming has been simplified and clarified:\n\n| Old Name | New Name | Backward Compatibility |\n|----------|----------|------------------------|\n| Fabric Pulse | Risk | Class still exported as `Pulsar` |\n| Fabric Weave | Privacy | Provider identifier remains `\"arbor\"` |\n| Fabric Core | FabricCore | ✅ No change needed |\n| Fabricant Suite | Fabriquant Suite | Updated to new name |\n\n**Note**: Backward compatibility is maintained for the `Pulsar` class export and `\"arbor\"` provider identifier to minimize breaking changes for early adopters.\n\n### Added\n\n#### Core Features\n- Unified SDK structure consolidating Guard, Risk (Pulsar), Privacy (Arbor), Loom, and FabricCore\n- Main `Fabriquant` orchestration class for transaction execution\n- `Fabriquant.execute()` - Execute transactions with Guard validation\n- `Fabriquant.executePrivate()` - Execute privacy-enabled transactions with ZK Compression\n\n#### Guard (Security Layer)\n- Transaction validation with configurable security rules\n- Pattern detection for 4 security threats:\n  - P-101: Excessive Slippage Detection\n  - P-102: Unauthorized Drain Prevention\n  - P-103: Malicious CPI Call Detection\n  - P-104: Reentrancy Attack Detection\n- Configurable enforcement modes: `\"block\"`, `\"warn\"`, `\"monitor\"`\n- Risk integration for real-time asset validation\n- Custom pattern detection support\n\n#### Risk (formerly Pulsar)\n- AI-driven risk assessment for RWA and asset integrity\n- Real-time risk scoring and compliance checks\n- Intelligent caching with configurable TTL\n- Seamless Guard integration for automated transaction blocking\n- Fallback handling for API errors\n\n#### Privacy (formerly Arbor - via FabricCore)\n- ZK Compression support for massive cost reduction (99.98% savings)\n- Transaction optimization with privacy settings\n- Cost estimation tools for compression savings\n- Shielded state management (placeholder for future integration)\n- Support for Light Protocol integration\n\n#### Loom (Liquidity Engine)\n- High-velocity liquidity routing (placeholder implementation)\n- Transaction weaving with parallel optimization\n- Multi-DEX routing preparation\n\n### Changed\n\n#### Breaking Changes\n- Project name: `fabricant` → `fabriquant`\n- Package name: `@fabricant/sdk` → `@fabriquant/sdk`\n- Import paths updated to reflect new package name\n\n#### Backward Compatible Changes\n- `Pulsar` class name retained for backward compatibility (represents Risk component)\n- `\"arbor\"` provider identifier retained (represents Privacy component)\n- All documentation updated to explain old vs new naming\n\n#### Documentation Updates\n- Complete rewrite of README.md with new branding and philosophy\n- Created comprehensive GUARD.md documentation\n- Created comprehensive RISK.md documentation\n- Created comprehensive PRIVACY.md documentation\n- Added CONTRIBUTING.md with development guidelines\n- Added MIGRATION.md guide for name changes\n- Updated all code examples to use new terminology\n\n### Fixed\n- ESLint error in `FabricCore.compressWithArbor()` - added explicit Promise.resolve()\n- Unused parameter warnings properly suppressed with void operator\n\n### Development\n\n#### Project Structure\n```\nfabriquant/\n├── src/\n│   ├── core/           # Fabriquant orchestration class\n│   ├── guard/          # Security layer (Guard)\n│   ├── pulsar/         # Risk assessment (Risk/Pulsar)\n│   ├── fabric/         # Performance & Privacy (FabricCore)\n│   ├── loom/           # Liquidity engine (Loom)\n│   └── types/          # Shared TypeScript types\n├── docs/               # Component documentation\n├── examples/           # Usage examples\n└── tests/              # Unit tests\n```\n\n#### Dependencies\n- `@solana/web3.js` ^1.87.6 - Solana blockchain integration\n- TypeScript 5.3+ for strict type checking\n- Vitest for testing framework\n- ESLint for code quality\n\n#### Testing & Quality\n- Comprehensive test suite for Guard and pattern detection\n- ESLint with TypeScript support and strict rules\n- Vitest coverage reporting\n- Strict TypeScript configuration\n\n### Roadmap\n\n#### Phase 1: SDK Consolidation ✅\n- Merged core modules into unified `@fabriquant/sdk`\n- Established consistent naming and branding\n\n#### Phase 1.5: Risk & Privacy Integration ✅\n- Risk oracle integration complete\n- Privacy layer scaffolding in place\n\n#### Phase 2: Pattern Library ✅ (v0.2.0)\n- Pre-built execution templates for AI agents\n- DAO treasury management patterns\n- Automated trading strategies\n- Real DEX integration with Jupiter V6\n\n#### Phase 2.5: Full ZK Stack Integration (Upcoming)\n- Complete Privacy/Light Protocol integration\n- ZK proof generation and verification\n- Shielded state management\n\n#### Phase 3: Fabriquant Mainnet (Future)\n- Decentralized autonomous vault infrastructure\n- Full stack deployment on Solana mainnet\n\n### Migration Guide\n\nFor users upgrading from pre-0.1.0 versions, see [MIGRATION.md](./MIGRATION.md) for detailed migration instructions.\n\n### Links\n\n- [Repository](https://github.com/fabriquant-labs/fabriquant)\n- [Issues](https://github.com/fabriquant-labs/fabriquant/issues)\n- [Documentation](./docs/)\n\n### Contributors\n\n- **Psyto** - Project creator and maintainer\n\n---\n\n## [0.2.0] - 2025-12-23\n\n### Added\n\n#### DEX Integration Module\n- **Jupiter V6 Integration**: Real-time price feeds, swap routing, and quote fetching from Solana's leading DEX aggregator\n  - `JupiterAdapter` class with quote/price/route API support\n  - Configurable caching with TTL (30s default) for optimal performance\n  - Timeout handling and error recovery\n  - Support for multiple token pairs\n\n- **Price Feed Service**: Multi-source price aggregation and management\n  - `PriceFeedService` class for aggregating prices from multiple DEX adapters\n  - Real-time price subscriptions with polling support\n  - Automatic fallback between adapters for reliability\n  - Cache management with statistics tracking\n  - Parallel price fetching for multiple tokens\n\n- **DEX Adapter Interface**: Swappable integration pattern\n  - Abstract `DEXAdapter` interface for adding custom DEX integrations\n  - Common types for `TokenMint`, `PriceQuote`, `SwapRoute`, `TokenPrice`, `MarketInfo`\n  - `COMMON_TOKENS` export with Solana token mint addresses (SOL, USDC, USDT, RAY, SRM, MNGO, ORCA)\n\n#### Pattern Library Enhancements\n- **ArbitragePattern**: Real DEX integration support\n  - Optional `enableRealDEX` flag to switch between simulated and live price feeds\n  - Custom `dexAdapter` configuration support\n  - Real-time multi-DEX price comparison using Jupiter\n  - Backward compatible with existing simulated tests\n\n- **SwapPattern**: Real routing optimization\n  - Optional `enableRealDEX` flag for live route fetching\n  - Automatic route optimization via Jupiter V6 API\n  - Conversion of Jupiter market infos to internal route format\n  - Fallback to configured routes if API unavailable\n\n#### Documentation\n- New module exports in `src/index.ts`:\n  - `JupiterAdapter`, `PriceFeedService`, `COMMON_TOKENS`\n  - DEX types: `TokenMint`, `PriceQuote`, `MarketInfo`, `SwapRoute`, `TokenPrice`, `DEXAdapter`, `PriceFeed`, `DEXConfig`\n- Complete API documentation for DEX integration in main index file\n\n#### Testing\n- **28 new DEX integration tests** (tests/dex-integration.test.ts - 616 lines)\n  - JupiterAdapter: quote fetching, price retrieval, route optimization, caching, error handling\n  - PriceFeedService: multi-adapter aggregation, subscriptions, fallback behavior, cache management\n  - Mock-based tests for reliable CI/CD without external API dependencies\n- **Test Coverage**: 417 total tests passing (389 existing + 28 new)\n\n### Changed\n\n#### Pattern Library\n- `ArbitrageConfig` interface: Added optional `enableRealDEX` and `dexAdapter` fields\n- `SwapConfig` interface: Added optional `enableRealDEX`, `dexAdapter` fields; made `routes` optional\n- Patterns now support both simulated (testing) and real DEX (production) execution modes\n\n#### Infrastructure\n- New `/src/dex/` directory with modular DEX integration architecture\n- Jupiter V6 API endpoints integrated: `https://quote-api.jup.ag/v6` and `https://price.jup.ag/v4`\n\n### Technical Details\n\n#### Architecture\n```\nsrc/dex/\n├── types.ts          # DEX adapter interfaces and common types (190 lines)\n├── jupiter.ts        # Jupiter V6 API client implementation (298 lines)\n├── price-feed.ts     # Price aggregation service (223 lines)\n└── index.ts          # Module exports (21 lines)\n```\n\n#### API Integration\n- Jupiter Quote API: Real-time swap quotes with route plans and price impact\n- Jupiter Price API: Token price data with vs-token comparison\n- Caching layer to minimize API calls and improve performance\n- AbortController support for request timeouts\n\n#### Backward Compatibility\n- All existing tests pass without modification\n- Patterns default to simulated mode (`enableRealDEX: false`)\n- Opt-in approach ensures zero breaking changes\n\n### Fixed\n- None - this is a feature-only release\n\n### Files Changed\n- 8 files modified, 1,483 insertions, 6 deletions\n- New files: `src/dex/*`, `tests/dex-integration.test.ts`\n- Modified: `src/index.ts`, `src/patterns/ai-agents/arbitrage.ts`, `src/patterns/defi/swap-pattern.ts`\n\n## [Unreleased]\n\nFuture releases will be documented here.\n\n### Planned\n- Complete Loom liquidity routing implementation\n- Enhanced error handling with custom error types\n- Performance benchmarking suite\n- API documentation site with TypeDoc\n- Additional security patterns (P-105+)\n- Integration with actual x402 protocol for Risk\n- Full Privacy/Light Protocol ZK stack integration\n- TypeScript SDK examples for common use cases\n- Chain abstraction layer for cross-chain support\n- EVM support for Guard and Risk components\n\n### Business & Operations\n- **Business Plan v3.1** (January 2025): Added comprehensive AI tool leverage strategy\n  - Updated operating model to emphasize AI-assisted development, marketing, and operations\n  - Added AI tool stack recommendations and ROI analysis\n  - Updated financial projections to reflect AI tool cost savings\n  - Cross-chain strategy documented: \"Solana-First, Cross-Chain Enabled\"\n\n---\n\n[0.2.0]: https://github.com/fabriquant-labs/fabriquant/releases/tag/v0.2.0\n[0.1.0]: https://github.com/fabriquant-labs/fabriquant/releases/tag/v0.1.0\n",
      "sections": [
        {
          "heading": "# Changelog",
          "body": "All notable changes to the Fabriquant SDK will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html)."
        },
        {
          "heading": "[0.1.0] - 2025-12-22",
          "body": "### Major Rebranding\n\nThis release represents a complete rebranding of the project from \"Fabricant\" to \"Fabriquant\" with updated naming conventions for all components.\n\n#### Project Naming\n- **BREAKING**: Renamed project from `fabricant` to `fabriquant`\n- **BREAKING**: Package name changed from `@fabricant/sdk` to `@fabriquant/sdk`\n- Updated all documentation and examples to reflect new branding\n\n#### Component Naming Changes\n\nThe component naming has been simplified and clarified:\n\n| Old Name | New Name | Backward Compatibility |\n|----------|----------|------------------------|\n| Fabric Pulse | Risk | Class still exported as `Pulsar` |\n| Fabric Weave | Privacy | Provider identifier remains `\"arbor\"` |\n| Fabric Core | FabricCore | ✅ No change needed |\n| Fabricant Suite | Fabriquant Suite | Updated to new name |\n\n**Note**: Backward compatibility is maintained for the `Pulsar` class export and `\"arbor\"` provider identifier to minimize breaking changes for early adopters.\n\n### Added\n\n#### Core Features\n- Unified SDK structure consolidating Guard, Risk (Pulsar), Privacy (Arbor), Loom, and FabricCore\n- Main `Fabriquant` orchestration class for transaction execution\n- `Fabriquant.execute()` - Execute transactions with Guard validation\n- `Fabriquant.executePrivate()` - Execute privacy-enabled transactions with ZK Compression\n\n#### Guard (Security Layer)\n- Transaction validation with configurable security rules\n- Pattern detection for 4 security threats:\n  - P-101: Excessive Slippage Detection\n  - P-102: Unauthorized Drain Prevention\n  - P-103: Malicious CPI Call Detection\n  - P-104: Reentrancy Attack Detection\n- Configurable enforcement modes: `\"block\"`, `\"warn\"`, `\"monitor\"`\n- Risk integration for real-time asset validation\n- Custom pattern detection support\n\n#### Risk (formerly Pulsar)\n- AI-driven risk assessment for RWA and asset integrity\n- Real-time risk scoring and compliance checks\n- Intelligent caching with configurable TTL\n- Seamless Guard integration for automated transaction blocking\n- Fallback handling for API errors\n\n#### Privacy (formerly Arbor - via FabricCore)\n- ZK Compression support for massive cost reduction (99.98% savings)\n- Transaction optimization with privacy settings\n- Cost estimation tools for compression savings\n- Shielded state management (placeholder for future integration)\n- Support for Light Protocol integration\n\n#### Loom (Liquidity Engine)\n- High-velocity liquidity routing (placeholder implementation)\n- Transaction weaving with parallel optimization\n- Multi-DEX routing preparation\n\n### Changed\n\n#### Breaking Changes\n- Project name: `fabricant` → `fabriquant`\n- Package name: `@fabricant/sdk` → `@fabriquant/sdk`\n- Import paths updated to reflect new package name\n\n#### Backward Compatible Changes\n- `Pulsar` class name retained for backward compatibility (represents Risk component)\n- `\"arbor\"` provider identifier retained (represents Privacy component)\n- All documentation updated to explain old vs new naming\n\n#### Documentation Updates\n- Complete rewrite of README.md with new branding and philosophy\n- Created comprehensive GUARD.md documentation\n- Created comprehensive RISK.md documentation\n- Created comprehensive PRIVACY.md documentation\n- Added CONTRIBUTING.md with development guidelines\n- Added MIGRATION.md guide for name changes\n- Updated all code examples to use new terminology\n\n### Fixed\n- ESLint error in `FabricCore.compressWithArbor()` - added explicit Promise.resolve()\n- Unused parameter warnings properly suppressed with void operator\n\n### Development\n\n#### Project Structure\n```\nfabriquant/\n├── src/\n│   ├── core/           # Fabriquant orchestration class\n│   ├── guard/          # Security layer (Guard)\n│   ├── pulsar/         # Risk assessment (Risk/Pulsar)\n│   ├── fabric/         # Performance & Privacy (FabricCore)\n│   ├── loom/           # Liquidity engine (Loom)\n│   └── types/          # Shared TypeScript types\n├── docs/               # Component documentation\n├── examples/           # Usage examples\n└── tests/              # Unit tests\n```\n\n#### Dependencies\n- `@solana/web3.js` ^1.87.6 - Solana blockchain integration\n- TypeScript 5.3+ for strict type checking\n- Vitest for testing framework\n- ESLint for code quality\n\n#### Testing & Quality\n- Comprehensive test suite for Guard and pattern detection\n- ESLint with TypeScript support and strict rules\n- Vitest coverage reporting\n- Strict TypeScript configuration\n\n### Roadmap\n\n#### Phase 1: SDK Consolidation ✅\n- Merged core modules into unified `@fabriquant/sdk`\n- Established consistent naming and branding\n\n#### Phase 1.5: Risk & Privacy Integration ✅\n- Risk oracle integration complete\n- Privacy layer scaffolding in place\n\n#### Phase 2: Pattern Library ✅ (v0.2.0)\n- Pre-built execution templates for AI agents\n- DAO treasury management patterns\n- Automated trading strategies\n- Real DEX integration with Jupiter V6\n\n#### Phase 2.5: Full ZK Stack Integration (Upcoming)\n- Complete Privacy/Light Protocol integration\n- ZK proof generation and verification\n- Shielded state management\n\n#### Phase 3: Fabriquant Mainnet (Future)\n- Decentralized autonomous vault infrastructure\n- Full stack deployment on Solana mainnet\n\n### Migration Guide\n\nFor users upgrading from pre-0.1.0 versions, see [MIGRATION.md](./MIGRATION.md) for detailed migration instructions.\n\n### Links\n\n- [Repository](https://github.com/fabriquant-labs/fabriquant)\n- [Issues](https://github.com/fabriquant-labs/fabriquant/issues)\n- [Documentation](./docs/)\n\n### Contributors\n\n- **Psyto** - Project creator and maintainer\n\n---"
        },
        {
          "heading": "[0.2.0] - 2025-12-23",
          "body": "### Added\n\n#### DEX Integration Module\n- **Jupiter V6 Integration**: Real-time price feeds, swap routing, and quote fetching from Solana's leading DEX aggregator\n  - `JupiterAdapter` class with quote/price/route API support\n  - Configurable caching with TTL (30s default) for optimal performance\n  - Timeout handling and error recovery\n  - Support for multiple token pairs\n\n- **Price Feed Service**: Multi-source price aggregation and management\n  - `PriceFeedService` class for aggregating prices from multiple DEX adapters\n  - Real-time price subscriptions with polling support\n  - Automatic fallback between adapters for reliability\n  - Cache management with statistics tracking\n  - Parallel price fetching for multiple tokens\n\n- **DEX Adapter Interface**: Swappable integration pattern\n  - Abstract `DEXAdapter` interface for adding custom DEX integrations\n  - Common types for `TokenMint`, `PriceQuote`, `SwapRoute`, `TokenPrice`, `MarketInfo`\n  - `COMMON_TOKENS` export with Solana token mint addresses (SOL, USDC, USDT, RAY, SRM, MNGO, ORCA)\n\n#### Pattern Library Enhancements\n- **ArbitragePattern**: Real DEX integration support\n  - Optional `enableRealDEX` flag to switch between simulated and live price feeds\n  - Custom `dexAdapter` configuration support\n  - Real-time multi-DEX price comparison using Jupiter\n  - Backward compatible with existing simulated tests\n\n- **SwapPattern**: Real routing optimization\n  - Optional `enableRealDEX` flag for live route fetching\n  - Automatic route optimization via Jupiter V6 API\n  - Conversion of Jupiter market infos to internal route format\n  - Fallback to configured routes if API unavailable\n\n#### Documentation\n- New module exports in `src/index.ts`:\n  - `JupiterAdapter`, `PriceFeedService`, `COMMON_TOKENS`\n  - DEX types: `TokenMint`, `PriceQuote`, `MarketInfo`, `SwapRoute`, `TokenPrice`, `DEXAdapter`, `PriceFeed`, `DEXConfig`\n- Complete API documentation for DEX integration in main index file\n\n#### Testing\n- **28 new DEX integration tests** (tests/dex-integration.test.ts - 616 lines)\n  - JupiterAdapter: quote fetching, price retrieval, route optimization, caching, error handling\n  - PriceFeedService: multi-adapter aggregation, subscriptions, fallback behavior, cache management\n  - Mock-based tests for reliable CI/CD without external API dependencies\n- **Test Coverage**: 417 total tests passing (389 existing + 28 new)\n\n### Changed\n\n#### Pattern Library\n- `ArbitrageConfig` interface: Added optional `enableRealDEX` and `dexAdapter` fields\n- `SwapConfig` interface: Added optional `enableRealDEX`, `dexAdapter` fields; made `routes` optional\n- Patterns now support both simulated (testing) and real DEX (production) execution modes\n\n#### Infrastructure\n- New `/src/dex/` directory with modular DEX integration architecture\n- Jupiter V6 API endpoints integrated: `https://quote-api.jup.ag/v6` and `https://price.jup.ag/v4`\n\n### Technical Details\n\n#### Architecture\n```\nsrc/dex/\n├── types.ts          # DEX adapter interfaces and common types (190 lines)\n├── jupiter.ts        # Jupiter V6 API client implementation (298 lines)\n├── price-feed.ts     # Price aggregation service (223 lines)\n└── index.ts          # Module exports (21 lines)\n```\n\n#### API Integration\n- Jupiter Quote API: Real-time swap quotes with route plans and price impact\n- Jupiter Price API: Token price data with vs-token comparison\n- Caching layer to minimize API calls and improve performance\n- AbortController support for request timeouts\n\n#### Backward Compatibility\n- All existing tests pass without modification\n- Patterns default to simulated mode (`enableRealDEX: false`)\n- Opt-in approach ensures zero breaking changes\n\n### Fixed\n- None - this is a feature-only release\n\n### Files Changed\n- 8 files modified, 1,483 insertions, 6 deletions\n- New files: `src/dex/*`, `tests/dex-integration.test.ts`\n- Modified: `src/index.ts`, `src/patterns/ai-agents/arbitrage.ts`, `src/patterns/defi/swap-pattern.ts`"
        },
        {
          "heading": "[Unreleased]",
          "body": "Future releases will be documented here.\n\n### Planned\n- Complete Loom liquidity routing implementation\n- Enhanced error handling with custom error types\n- Performance benchmarking suite\n- API documentation site with TypeDoc\n- Additional security patterns (P-105+)\n- Integration with actual x402 protocol for Risk\n- Full Privacy/Light Protocol ZK stack integration\n- TypeScript SDK examples for common use cases\n- Chain abstraction layer for cross-chain support\n- EVM support for Guard and Risk components\n\n### Business & Operations\n- **Business Plan v3.1** (January 2025): Added comprehensive AI tool leverage strategy\n  - Updated operating model to emphasize AI-assisted development, marketing, and operations\n  - Added AI tool stack recommendations and ROI analysis\n  - Updated financial projections to reflect AI tool cost savings\n  - Cross-chain strategy documented: \"Solana-First, Cross-Chain Enabled\"\n\n---\n\n[0.2.0]: https://github.com/fabriquant-labs/fabriquant/releases/tag/v0.2.0\n[0.1.0]: https://github.com/fabriquant-labs/fabriquant/releases/tag/v0.1.0"
        }
      ],
      "wordCount": 1424
    },
    {
      "path": "CONTRIBUTING.md",
      "title": "Contributing to Fabriquant",
      "content": "# Contributing to Fabriquant\n\nThank you for your interest in contributing to Fabriquant! This document provides guidelines and standards for contributing to the Precision Execution Stack for Solana.\n\n## Table of Contents\n\n- [Code of Conduct](#code-of-conduct)\n- [Getting Started](#getting-started)\n- [Development Workflow](#development-workflow)\n- [Code Standards](#code-standards)\n- [Testing Requirements](#testing-requirements)\n- [Commit Guidelines](#commit-guidelines)\n- [Pull Request Process](#pull-request-process)\n- [Documentation](#documentation)\n\n## Code of Conduct\n\n- Be respectful and constructive in all interactions\n- Focus on technical merit and project goals\n- Welcome newcomers and help them get started\n- Maintain a professional and collaborative environment\n\n## Getting Started\n\n### Prerequisites\n\n- Node.js 18+ and npm\n- TypeScript knowledge\n- Familiarity with Solana development\n- Understanding of blockchain security principles\n\n### Setup\n\n1. Fork the repository\n2. Clone your fork:\n   ```bash\n   git clone https://github.com/YOUR_USERNAME/fabriquant.git\n   cd fabriquant\n   ```\n3. Install dependencies:\n   ```bash\n   npm install\n   ```\n4. Run tests to ensure everything works:\n   ```bash\n   npm test\n   ```\n5. Run linter:\n   ```bash\n   npm run lint\n   ```\n\n## Development Workflow\n\n**Note**: This project leverages AI-assisted development tools (GitHub Copilot, Cursor, ChatGPT) to maximize productivity. Contributors are encouraged to use AI tools for code generation, documentation, and testing while maintaining code quality and human review.\n\n1. **Create a branch** for your feature or fix:\n   ```bash\n   git checkout -b feature/your-feature-name\n   # or\n   git checkout -b fix/issue-description\n   ```\n\n2. **Make your changes** following the code standards below\n   - Use AI tools for code generation, but always review and understand the generated code\n   - AI-generated code must pass all tests and linting\n   - Maintain code quality standards regardless of code source\n\n3. **Write or update tests** for your changes\n   - Use AI to generate test cases, but ensure comprehensive coverage\n   - Test both success and failure scenarios\n\n4. **Run the test suite** to ensure nothing breaks:\n   ```bash\n   npm test\n   npm run lint\n   ```\n\n5. **Commit your changes** following the commit guidelines\n\n6. **Push to your fork** and create a pull request\n\n## Code Standards\n\n### TypeScript\n\n- Use **strict TypeScript** - the project uses strict mode\n- Provide **explicit types** for all public APIs\n- Avoid `any` types unless absolutely necessary\n- Use **readonly** for immutable data structures\n- Export types from `src/types/index.ts` for shared interfaces\n\n### File Organization\n\n```\nsrc/\n├── core/           # Core orchestration (Fabriquant class)\n├── guard/          # Security layer\n├── pulsar/         # Risk assessment (backward compat: still named Pulsar)\n├── fabric/         # Performance & Privacy layer\n├── loom/           # Liquidity engine\n└── types/          # Shared TypeScript types\n```\n\n### Naming Conventions\n\n- **Classes**: PascalCase (e.g., `Guard`, `FabricCore`)\n- **Functions/Methods**: camelCase (e.g., `validateTransaction`, `weave`)\n- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_SLIPPAGE`)\n- **Interfaces**: PascalCase with descriptive names (e.g., `GuardConfig`, `Transaction`)\n- **Files**: kebab-case (e.g., `detector.ts`, `validator.ts`)\n\n### Code Style\n\n- Use **2 spaces** for indentation\n- Use **double quotes** for strings\n- Include **semicolons** at the end of statements\n- Maximum line length: **100 characters** (flexible for readability)\n- Use **async/await** for asynchronous operations (not Promise.then())\n- Add **JSDoc comments** for all public APIs\n\n### ESLint\n\nThe project uses ESLint with TypeScript support. Run the linter before committing:\n\n```bash\nnpm run lint\n```\n\nKey rules:\n- `@typescript-eslint/no-unused-vars` - No unused variables\n- `@typescript-eslint/require-await` - Async functions must use await\n- `@typescript-eslint/no-explicit-any` - Avoid `any` type\n- `@typescript-eslint/explicit-module-boundary-types` - Explicit return types\n\n## Testing Requirements\n\n### Writing Tests\n\n- Use **Vitest** for unit tests\n- Place tests in the `tests/` directory\n- Name test files with `.test.ts` suffix\n- Aim for **high test coverage** on critical paths\n- Test both success and failure cases\n\n### Test Structure\n\n```typescript\nimport { describe, it, expect } from \"vitest\";\nimport { Guard } from \"../src/guard\";\n\ndescribe(\"Guard\", () => {\n    it(\"should validate transaction within slippage limits\", () => {\n        const guard = new Guard({ maxSlippage: 0.1 });\n        const result = guard.validateTransaction(mockTransaction);\n        expect(result.isValid).toBe(true);\n    });\n\n    it(\"should reject transaction exceeding slippage limits\", () => {\n        const guard = new Guard({ maxSlippage: 0.1 });\n        const result = guard.validateTransaction(highSlippageTx);\n        expect(result.isValid).toBe(false);\n    });\n});\n```\n\n### Running Tests\n\n```bash\n# Run all tests\nnpm test\n\n# Run tests in watch mode\nnpm run test:watch\n\n# Run with coverage\nnpm run test:coverage\n```\n\n## Commit Guidelines\n\nWe follow **Conventional Commits** for clear and consistent commit history.\n\n### Commit Format\n\n```\n<type>(<scope>): <subject>\n\n<body>\n\n<footer>\n```\n\n### Types\n\n- `feat`: New feature\n- `fix`: Bug fix\n- `docs`: Documentation changes\n- `style`: Code style changes (formatting, no logic change)\n- `refactor`: Code refactoring (no feature/fix)\n- `test`: Adding or updating tests\n- `chore`: Maintenance tasks (dependencies, build config)\n- `perf`: Performance improvements\n\n### Scopes\n\n- `guard`: Guard security layer\n- `risk`: Risk assessment (Pulsar)\n- `privacy`: Privacy layer (Arbor/FabricCore)\n- `loom`: Liquidity engine\n- `core`: Core orchestration (Fabriquant class)\n- `types`: Type definitions\n- `docs`: Documentation\n- `tests`: Test suite\n\n### Examples\n\n```bash\nfeat(guard): add custom pattern detection for CPI calls\n\nImplement support for user-defined security patterns to detect\nsuspicious Cross-Program Invocation patterns.\n\nCloses #42\n\n---\n\nfix(risk): correct cache TTL calculation\n\nThe cache was expiring too early due to millisecond conversion error.\n\n---\n\ndocs(readme): update installation instructions\n\nAdd npm and yarn installation commands to README.\n\n---\n\nrefactor(fabric): simplify transaction optimization logic\n\nRemove redundant conditional checks and improve readability.\n```\n\n## Pull Request Process\n\n### Before Submitting\n\n1. Ensure all tests pass (`npm test`)\n2. Run the linter and fix all issues (`npm run lint`)\n3. Update documentation if needed\n4. Add tests for new features\n5. Update CHANGELOG.md if applicable\n\n### PR Title Format\n\nFollow the same format as commit messages:\n\n```\nfeat(guard): add support for custom validation rules\nfix(risk): resolve race condition in cache updates\ndocs: improve Guard API documentation\n```\n\n### PR Description Template\n\n```markdown\n## Description\nBrief description of what this PR does.\n\n## Type of Change\n- [ ] Bug fix (non-breaking change fixing an issue)\n- [ ] New feature (non-breaking change adding functionality)\n- [ ] Breaking change (fix or feature causing existing functionality to change)\n- [ ] Documentation update\n\n## Testing\nDescribe the tests you ran and how to reproduce them.\n\n## Checklist\n- [ ] My code follows the project's code standards\n- [ ] I have performed a self-review of my code\n- [ ] I have commented my code, particularly in hard-to-understand areas\n- [ ] I have updated the documentation accordingly\n- [ ] My changes generate no new warnings or errors\n- [ ] I have added tests that prove my fix is effective or that my feature works\n- [ ] New and existing unit tests pass locally with my changes\n\n## Related Issues\nCloses #(issue number)\n```\n\n### Review Process\n\n1. A maintainer will review your PR within a few days\n2. Address any requested changes\n3. Once approved, a maintainer will merge your PR\n4. Your contribution will be included in the next release\n\n## Documentation\n\n### Code Comments\n\n- Add **JSDoc comments** for all public APIs\n- Include `@param` and `@returns` tags\n- Provide usage examples for complex functions\n- **AI-Assisted Documentation**: Use AI tools to generate initial documentation, but always review and refine for accuracy and clarity\n\nExample:\n\n```typescript\n/**\n * Validate a transaction against configured security rules\n * @param transaction - The transaction to validate\n * @returns Validation result with isValid flag and optional reasons\n * @example\n * ```typescript\n * const guard = new Guard({ maxSlippage: 0.1 });\n * const result = guard.validateTransaction(tx);\n * if (!result.isValid) {\n *   console.log('Validation failed:', result.reason);\n * }\n * ```\n */\npublic validateTransaction(transaction: Transaction): ValidationResult {\n    // Implementation\n}\n```\n\n### Documentation Files\n\n- Update relevant docs in `docs/` directory\n- Add examples to `examples/` for new features\n- Update README.md for significant changes\n- Keep CHANGELOG.md updated\n\n### Component Documentation\n\nEach major component has dedicated documentation:\n\n- **Guard**: `docs/GUARD.md` - Security layer documentation\n- **Risk**: `docs/RISK.md` - Risk assessment documentation\n- **Privacy**: `docs/PRIVACY.md` - Privacy layer documentation\n\nUpdate these files when making changes to their respective components.\n\n## Questions or Need Help?\n\n- Open an issue on GitHub\n- Tag your issue with `question` or `help wanted`\n- Provide context and relevant code snippets\n- Be patient and respectful\n\n## License\n\nBy contributing to Fabriquant, you agree that your contributions will be licensed under the same license as the project.\n\n---\n\nThank you for contributing to Fabriquant! Together we're weaving the future of autonomous finance on Solana.\n",
      "sections": [
        {
          "heading": "# Contributing to Fabriquant",
          "body": "Thank you for your interest in contributing to Fabriquant! This document provides guidelines and standards for contributing to the Precision Execution Stack for Solana."
        },
        {
          "heading": "Table of Contents",
          "body": "- [Code of Conduct](#code-of-conduct)\n- [Getting Started](#getting-started)\n- [Development Workflow](#development-workflow)\n- [Code Standards](#code-standards)\n- [Testing Requirements](#testing-requirements)\n- [Commit Guidelines](#commit-guidelines)\n- [Pull Request Process](#pull-request-process)\n- [Documentation](#documentation)"
        },
        {
          "heading": "Code of Conduct",
          "body": "- Be respectful and constructive in all interactions\n- Focus on technical merit and project goals\n- Welcome newcomers and help them get started\n- Maintain a professional and collaborative environment"
        },
        {
          "heading": "Getting Started",
          "body": "### Prerequisites\n\n- Node.js 18+ and npm\n- TypeScript knowledge\n- Familiarity with Solana development\n- Understanding of blockchain security principles\n\n### Setup\n\n1. Fork the repository\n2. Clone your fork:\n   ```bash\n   git clone https://github.com/YOUR_USERNAME/fabriquant.git\n   cd fabriquant\n   ```\n3. Install dependencies:\n   ```bash\n   npm install\n   ```\n4. Run tests to ensure everything works:\n   ```bash\n   npm test\n   ```\n5. Run linter:\n   ```bash\n   npm run lint\n   ```"
        },
        {
          "heading": "Development Workflow",
          "body": "**Note**: This project leverages AI-assisted development tools (GitHub Copilot, Cursor, ChatGPT) to maximize productivity. Contributors are encouraged to use AI tools for code generation, documentation, and testing while maintaining code quality and human review.\n\n1. **Create a branch** for your feature or fix:\n   ```bash\n   git checkout -b feature/your-feature-name\n   # or\n   git checkout -b fix/issue-description\n   ```\n\n2. **Make your changes** following the code standards below\n   - Use AI tools for code generation, but always review and understand the generated code\n   - AI-generated code must pass all tests and linting\n   - Maintain code quality standards regardless of code source\n\n3. **Write or update tests** for your changes\n   - Use AI to generate test cases, but ensure comprehensive coverage\n   - Test both success and failure scenarios\n\n4. **Run the test suite** to ensure nothing breaks:\n   ```bash\n   npm test\n   npm run lint\n   ```\n\n5. **Commit your changes** following the commit guidelines\n\n6. **Push to your fork** and create a pull request"
        },
        {
          "heading": "Code Standards",
          "body": "### TypeScript\n\n- Use **strict TypeScript** - the project uses strict mode\n- Provide **explicit types** for all public APIs\n- Avoid `any` types unless absolutely necessary\n- Use **readonly** for immutable data structures\n- Export types from `src/types/index.ts` for shared interfaces\n\n### File Organization\n\n```\nsrc/\n├── core/           # Core orchestration (Fabriquant class)\n├── guard/          # Security layer\n├── pulsar/         # Risk assessment (backward compat: still named Pulsar)\n├── fabric/         # Performance & Privacy layer\n├── loom/           # Liquidity engine\n└── types/          # Shared TypeScript types\n```\n\n### Naming Conventions\n\n- **Classes**: PascalCase (e.g., `Guard`, `FabricCore`)\n- **Functions/Methods**: camelCase (e.g., `validateTransaction`, `weave`)\n- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_SLIPPAGE`)\n- **Interfaces**: PascalCase with descriptive names (e.g., `GuardConfig`, `Transaction`)\n- **Files**: kebab-case (e.g., `detector.ts`, `validator.ts`)\n\n### Code Style\n\n- Use **2 spaces** for indentation\n- Use **double quotes** for strings\n- Include **semicolons** at the end of statements\n- Maximum line length: **100 characters** (flexible for readability)\n- Use **async/await** for asynchronous operations (not Promise.then())\n- Add **JSDoc comments** for all public APIs\n\n### ESLint\n\nThe project uses ESLint with TypeScript support. Run the linter before committing:\n\n```bash\nnpm run lint\n```\n\nKey rules:\n- `@typescript-eslint/no-unused-vars` - No unused variables\n- `@typescript-eslint/require-await` - Async functions must use await\n- `@typescript-eslint/no-explicit-any` - Avoid `any` type\n- `@typescript-eslint/explicit-module-boundary-types` - Explicit return types"
        },
        {
          "heading": "Testing Requirements",
          "body": "### Writing Tests\n\n- Use **Vitest** for unit tests\n- Place tests in the `tests/` directory\n- Name test files with `.test.ts` suffix\n- Aim for **high test coverage** on critical paths\n- Test both success and failure cases\n\n### Test Structure\n\n```typescript\nimport { describe, it, expect } from \"vitest\";\nimport { Guard } from \"../src/guard\";\n\ndescribe(\"Guard\", () => {\n    it(\"should validate transaction within slippage limits\", () => {\n        const guard = new Guard({ maxSlippage: 0.1 });\n        const result = guard.validateTransaction(mockTransaction);\n        expect(result.isValid).toBe(true);\n    });\n\n    it(\"should reject transaction exceeding slippage limits\", () => {\n        const guard = new Guard({ maxSlippage: 0.1 });\n        const result = guard.validateTransaction(highSlippageTx);\n        expect(result.isValid).toBe(false);\n    });\n});\n```\n\n### Running Tests\n\n```bash\n# Run all tests\nnpm test\n\n# Run tests in watch mode\nnpm run test:watch\n\n# Run with coverage\nnpm run test:coverage\n```"
        },
        {
          "heading": "Commit Guidelines",
          "body": "We follow **Conventional Commits** for clear and consistent commit history.\n\n### Commit Format\n\n```\n<type>(<scope>): <subject>\n\n<body>\n\n<footer>\n```\n\n### Types\n\n- `feat`: New feature\n- `fix`: Bug fix\n- `docs`: Documentation changes\n- `style`: Code style changes (formatting, no logic change)\n- `refactor`: Code refactoring (no feature/fix)\n- `test`: Adding or updating tests\n- `chore`: Maintenance tasks (dependencies, build config)\n- `perf`: Performance improvements\n\n### Scopes\n\n- `guard`: Guard security layer\n- `risk`: Risk assessment (Pulsar)\n- `privacy`: Privacy layer (Arbor/FabricCore)\n- `loom`: Liquidity engine\n- `core`: Core orchestration (Fabriquant class)\n- `types`: Type definitions\n- `docs`: Documentation\n- `tests`: Test suite\n\n### Examples\n\n```bash\nfeat(guard): add custom pattern detection for CPI calls\n\nImplement support for user-defined security patterns to detect\nsuspicious Cross-Program Invocation patterns.\n\nCloses #42\n\n---\n\nfix(risk): correct cache TTL calculation\n\nThe cache was expiring too early due to millisecond conversion error.\n\n---\n\ndocs(readme): update installation instructions\n\nAdd npm and yarn installation commands to README.\n\n---\n\nrefactor(fabric): simplify transaction optimization logic\n\nRemove redundant conditional checks and improve readability.\n```"
        },
        {
          "heading": "Pull Request Process",
          "body": "### Before Submitting\n\n1. Ensure all tests pass (`npm test`)\n2. Run the linter and fix all issues (`npm run lint`)\n3. Update documentation if needed\n4. Add tests for new features\n5. Update CHANGELOG.md if applicable\n\n### PR Title Format\n\nFollow the same format as commit messages:\n\n```\nfeat(guard): add support for custom validation rules\nfix(risk): resolve race condition in cache updates\ndocs: improve Guard API documentation\n```\n\n### PR Description Template\n\n```markdown"
        },
        {
          "heading": "Description",
          "body": "Brief description of what this PR does."
        },
        {
          "heading": "Type of Change",
          "body": "- [ ] Bug fix (non-breaking change fixing an issue)\n- [ ] New feature (non-breaking change adding functionality)\n- [ ] Breaking change (fix or feature causing existing functionality to change)\n- [ ] Documentation update"
        },
        {
          "heading": "Testing",
          "body": "Describe the tests you ran and how to reproduce them."
        },
        {
          "heading": "Checklist",
          "body": "- [ ] My code follows the project's code standards\n- [ ] I have performed a self-review of my code\n- [ ] I have commented my code, particularly in hard-to-understand areas\n- [ ] I have updated the documentation accordingly\n- [ ] My changes generate no new warnings or errors\n- [ ] I have added tests that prove my fix is effective or that my feature works\n- [ ] New and existing unit tests pass locally with my changes"
        },
        {
          "heading": "Related Issues",
          "body": "Closes #(issue number)\n```\n\n### Review Process\n\n1. A maintainer will review your PR within a few days\n2. Address any requested changes\n3. Once approved, a maintainer will merge your PR\n4. Your contribution will be included in the next release"
        },
        {
          "heading": "Documentation",
          "body": "### Code Comments\n\n- Add **JSDoc comments** for all public APIs\n- Include `@param` and `@returns` tags\n- Provide usage examples for complex functions\n- **AI-Assisted Documentation**: Use AI tools to generate initial documentation, but always review and refine for accuracy and clarity\n\nExample:\n\n```typescript\n/**\n * Validate a transaction against configured security rules\n * @param transaction - The transaction to validate\n * @returns Validation result with isValid flag and optional reasons\n * @example\n * ```typescript\n * const guard = new Guard({ maxSlippage: 0.1 });\n * const result = guard.validateTransaction(tx);\n * if (!result.isValid) {\n *   console.log('Validation failed:', result.reason);\n * }\n * ```\n */\npublic validateTransaction(transaction: Transaction): ValidationResult {\n    // Implementation\n}\n```\n\n### Documentation Files\n\n- Update relevant docs in `docs/` directory\n- Add examples to `examples/` for new features\n- Update README.md for significant changes\n- Keep CHANGELOG.md updated\n\n### Component Documentation\n\nEach major component has dedicated documentation:\n\n- **Guard**: `docs/GUARD.md` - Security layer documentation\n- **Risk**: `docs/RISK.md` - Risk assessment documentation\n- **Privacy**: `docs/PRIVACY.md` - Privacy layer documentation\n\nUpdate these files when making changes to their respective components."
        },
        {
          "heading": "Questions or Need Help?",
          "body": "- Open an issue on GitHub\n- Tag your issue with `question` or `help wanted`\n- Provide context and relevant code snippets\n- Be patient and respectful"
        },
        {
          "heading": "License",
          "body": "By contributing to Fabriquant, you agree that your contributions will be licensed under the same license as the project.\n\n---\n\nThank you for contributing to Fabriquant! Together we're weaving the future of autonomous finance on Solana."
        }
      ],
      "wordCount": 1378
    },
    {
      "path": "MIGRATION.md",
      "title": "Migration Guide",
      "content": "# Migration Guide\n\nThis guide helps you migrate from older naming conventions to the new **Fabriquant** branding introduced in v0.1.0.\n\n## Overview of Changes\n\nThe v0.1.0 release includes a complete rebranding with simplified, clearer component names. This guide covers:\n\n1. Package name changes\n2. Component naming updates\n3. Code migration examples\n4. Backward compatibility notes\n\n## Package Name Change\n\n### Old Package Name\n```json\n{\n  \"dependencies\": {\n    \"@fabricant/sdk\": \"^0.0.x\"\n  }\n}\n```\n\n### New Package Name\n```json\n{\n  \"dependencies\": {\n    \"@fabriquant/sdk\": \"^0.1.0\"\n  }\n}\n```\n\n### Migration Steps\n\n1. **Uninstall the old package:**\n   ```bash\n   npm uninstall @fabricant/sdk\n   ```\n\n2. **Install the new package:**\n   ```bash\n   npm install @fabriquant/sdk\n   ```\n\n3. **Update import statements:**\n   ```typescript\n   // Old\n   import { Guard, Pulsar } from \"@fabricant/sdk\";\n\n   // New\n   import { Guard, Pulsar } from \"@fabriquant/sdk\";\n   ```\n\n## Component Naming Changes\n\n### Summary Table\n\n| Category | Old Name | New Name | Class/Export | Backward Compatible? |\n|----------|----------|----------|--------------|---------------------|\n| **Project** | Fabricant | Fabriquant | - | ❌ Breaking change |\n| **Package** | `@fabricant/sdk` | `@fabriquant/sdk` | - | ❌ Breaking change |\n| **Risk Component** | Fabric Pulse | Risk | `Pulsar` | ✅ Yes (class name unchanged) |\n| **Privacy Component** | Fabric Weave | Privacy | - | ✅ Yes (identifier unchanged) |\n| **Suite Name** | Fabricant Suite | Fabriquant Suite | - | ❌ Documentation only |\n| **Main Class** | Fabricant | Fabriquant | `Fabriquant` | ❌ Breaking change |\n\n### Detailed Component Changes\n\n#### 1. Risk Component (formerly \"Fabric Pulse\")\n\n**Terminology Change:**\n- **Old Name**: Fabric Pulse\n- **New Name**: Risk\n- **Implementation**: Still uses `Pulsar` class name for backward compatibility\n\n**No Code Changes Required** ✅\n\nThe class is still exported as `Pulsar`, so your existing code continues to work:\n\n```typescript\n// This works in both old and new versions\nimport { Pulsar } from \"@fabriquant/sdk\";\n\nconst pulsar = new Pulsar({\n  apiKey: \"your-api-key\",\n  environment: \"mainnet\",\n});\n```\n\n**Documentation References:**\n- In documentation, we now refer to this as the \"Risk\" component\n- The class name `Pulsar` is retained for backward compatibility\n- When reading docs, \"Risk\" = \"Pulsar\" = \"Fabric Pulse\" (all refer to the same component)\n\n#### 2. Privacy Component (formerly \"Fabric Weave\")\n\n**Terminology Change:**\n- **Old Name**: Fabric Weave\n- **New Name**: Privacy\n- **Implementation**: Provider identifier remains `\"arbor\"`\n\n**No Code Changes Required** ✅\n\nThe provider identifier is unchanged, so your existing code works:\n\n```typescript\n// This works in both old and new versions\nimport { FabricCore } from \"@fabriquant/sdk\";\n\nconst tx = FabricCore.optimize(transaction, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\", // Identifier unchanged\n});\n\nawait Fabriquant.executePrivate(tx, {\n  with: guard,\n  privacy: {\n    provider: \"arbor\", // Identifier unchanged\n    compression: true,\n  },\n});\n```\n\n**Documentation References:**\n- In documentation, we now refer to this as the \"Privacy\" component\n- The `\"arbor\"` identifier is retained for backward compatibility\n- When reading docs, \"Privacy\" = \"Arbor\" = \"Fabric Weave\" (all refer to the same component)\n\n#### 3. Main Orchestration Class\n\n**Class Name Change:**\n- **Old Name**: `Fabricant`\n- **New Name**: `Fabriquant`\n\n**Code Changes Required** ❌\n\nUpdate all references to the main class:\n\n```typescript\n// Old\nimport { Fabricant } from \"@fabricant/sdk\";\nawait Fabricant.execute(tx, { with: guard });\n\n// New\nimport { Fabriquant } from \"@fabriquant/sdk\";\nawait Fabriquant.execute(tx, { with: guard });\n```\n\n## Migration Examples\n\n### Example 1: Basic Guard Usage\n\n**Before (v0.0.x):**\n```typescript\nimport { Fabricant, Guard } from \"@fabricant/sdk\";\n\nconst guard = new Guard({\n  maxSlippage: 0.1,\n  riskTolerance: \"moderate\",\n  mode: \"block\",\n});\n\nconst result = await Fabricant.execute(transaction, { with: guard });\n```\n\n**After (v0.1.0):**\n```typescript\nimport { Fabriquant, Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n  maxSlippage: 0.1,\n  riskTolerance: \"moderate\",\n  mode: \"block\",\n});\n\nconst result = await Fabriquant.execute(transaction, { with: guard });\n```\n\n**Changes:**\n1. ✅ Package name: `@fabricant/sdk` → `@fabriquant/sdk`\n2. ✅ Class name: `Fabricant` → `Fabriquant`\n\n### Example 2: Risk Integration (Pulsar)\n\n**Before (v0.0.x):**\n```typescript\nimport { Guard, Pulsar } from \"@fabricant/sdk\";\n\n// Guard with Fabric Pulse (Risk) enabled\nconst guard = new Guard({\n  pulsar: {\n    enabled: true,\n    riskThreshold: 0.7,\n    cacheTTL: 60000,\n  },\n});\n```\n\n**After (v0.1.0):**\n```typescript\nimport { Guard, Pulsar } from \"@fabriquant/sdk\";\n\n// Guard with Risk enabled (class still named Pulsar for compatibility)\nconst guard = new Guard({\n  pulsar: {\n    enabled: true,\n    riskThreshold: 0.7,\n    cacheTTL: 60000,\n  },\n});\n```\n\n**Changes:**\n1. ✅ Package name: `@fabricant/sdk` → `@fabriquant/sdk`\n2. ✅ Config key `pulsar` remains unchanged\n3. ✅ `Pulsar` class name remains unchanged\n4. 📝 Documentation now calls this \"Risk\" instead of \"Fabric Pulse\"\n\n### Example 3: Privacy Integration (Arbor)\n\n**Before (v0.0.x):**\n```typescript\nimport { Fabricant, FabricCore } from \"@fabricant/sdk\";\n\n// Optimize with Fabric Weave (Privacy)\nconst optimized = FabricCore.optimize(tx, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\",\n});\n\nconst result = await Fabricant.executePrivate(optimized, {\n  privacy: { provider: \"arbor\" },\n});\n```\n\n**After (v0.1.0):**\n```typescript\nimport { Fabriquant, FabricCore } from \"@fabriquant/sdk\";\n\n// Optimize with Privacy (provider identifier remains \"arbor\")\nconst optimized = FabricCore.optimize(tx, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\",\n});\n\nconst result = await Fabriquant.executePrivate(optimized, {\n  privacy: { provider: \"arbor\" },\n});\n```\n\n**Changes:**\n1. ✅ Package name: `@fabricant/sdk` → `@fabriquant/sdk`\n2. ✅ Class name: `Fabricant` → `Fabriquant`\n3. ✅ Provider identifier `\"arbor\"` remains unchanged\n4. 📝 Documentation now calls this \"Privacy\" instead of \"Fabric Weave\"\n\n### Example 4: Complete Integration\n\n**Before (v0.0.x):**\n```typescript\nimport { Fabricant, Guard, Pulsar, FabricCore, Loom } from \"@fabricant/sdk\";\n\n// Initialize Guard with Fabric Pulse (Risk)\nconst guard = new Guard({\n  pulsar: { enabled: true, riskThreshold: 0.7 },\n  mode: \"block\",\n});\n\n// Create transaction with Loom\nconst tx = await Loom.weave({\n  type: \"MULTI_ROUTE_SWAP\",\n  input: \"SOL\",\n  output: \"USDC\",\n  amount: 100,\n});\n\n// Optimize with Fabric Weave (Privacy)\nconst optimized = FabricCore.optimize(tx, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\",\n});\n\n// Execute with Fabricant\nconst result = await Fabricant.executePrivate(optimized, {\n  with: guard,\n  privacy: { provider: \"arbor\", compression: true },\n});\n```\n\n**After (v0.1.0):**\n```typescript\nimport { Fabriquant, Guard, Pulsar, FabricCore, Loom } from \"@fabriquant/sdk\";\n\n// Initialize Guard with Risk (class still named Pulsar)\nconst guard = new Guard({\n  pulsar: { enabled: true, riskThreshold: 0.7 },\n  mode: \"block\",\n});\n\n// Create transaction with Loom\nconst tx = await Loom.weave({\n  type: \"MULTI_ROUTE_SWAP\",\n  input: \"SOL\",\n  output: \"USDC\",\n  amount: 100,\n});\n\n// Optimize with Privacy (provider identifier still \"arbor\")\nconst optimized = FabricCore.optimize(tx, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\",\n});\n\n// Execute with Fabriquant\nconst result = await Fabriquant.executePrivate(optimized, {\n  with: guard,\n  privacy: { provider: \"arbor\", compression: true },\n});\n```\n\n**Changes:**\n1. ✅ Package name: `@fabricant/sdk` → `@fabriquant/sdk`\n2. ✅ Class name: `Fabricant` → `Fabriquant`\n3. ✅ All other APIs remain backward compatible\n\n## Quick Migration Checklist\n\nUse this checklist to ensure you've migrated everything:\n\n### Package & Dependencies\n- [ ] Updated `package.json` to use `@fabriquant/sdk` instead of `@fabricant/sdk`\n- [ ] Ran `npm install` to install the new package\n- [ ] Verified no references to old package name in `package-lock.json`\n\n### Code Changes\n- [ ] Updated all import statements from `@fabricant/sdk` to `@fabriquant/sdk`\n- [ ] Renamed `Fabricant` class to `Fabriquant` in all files\n- [ ] Verified `Pulsar` class usage (no changes needed)\n- [ ] Verified `\"arbor\"` provider identifier usage (no changes needed)\n\n### Documentation & Comments\n- [ ] Updated code comments referring to \"Fabricant\" → \"Fabriquant\"\n- [ ] Updated code comments referring to \"Fabric Pulse\" → \"Risk\"\n- [ ] Updated code comments referring to \"Fabric Weave\" → \"Privacy\"\n\n### Testing\n- [ ] Ran test suite to verify functionality: `npm test`\n- [ ] Ran linter to verify code quality: `npm run lint`\n- [ ] Tested critical paths manually if applicable\n\n## Backward Compatibility Promise\n\nWe've designed this migration to minimize breaking changes:\n\n### What's Backward Compatible ✅\n- `Pulsar` class name (represents Risk component)\n- `\"arbor\"` provider identifier (represents Privacy component)\n- All Guard configurations and APIs\n- All FabricCore APIs\n- All Loom APIs\n- Configuration object structures\n\n### What's Breaking ❌\n- Package name: `@fabricant/sdk` → `@fabriquant/sdk`\n- Main class: `Fabricant` → `Fabriquant`\n\n## Why the Rebrand?\n\nThe rebranding from \"Fabricant\" to \"Fabriquant\" brings several benefits:\n\n1. **Clearer Identity**: The French spelling \"Fabriquant\" (meaning \"manufacturer\" or \"creator\") better reflects the precision and craftsmanship of the SDK\n2. **Component Clarity**: Simplified names (Risk, Privacy) are more intuitive than abstract names (Fabric Pulse, Fabric Weave)\n3. **SEO & Discoverability**: Unique spelling improves searchability and brand recognition\n4. **Unified Vision**: The \"weaving\" metaphor is now clearly expressed through component names and APIs\n\n## Need Help?\n\nIf you encounter issues during migration:\n\n1. **Check the examples**: See `examples/` directory for updated code samples\n2. **Review documentation**: See `docs/` for detailed component documentation\n3. **Open an issue**: [GitHub Issues](https://github.com/fabriquant-labs/fabriquant/issues)\n4. **Check the changelog**: See [CHANGELOG.md](./CHANGELOG.md) for complete list of changes\n\n## Future Deprecations\n\nWe plan to maintain backward compatibility for the following in the near term:\n\n- `Pulsar` class name (at least through v0.2.x)\n- `\"arbor\"` provider identifier (at least through v0.2.x)\n\nFuture major versions (v1.0.0+) may remove these compatibility layers in favor of:\n- `Risk` class to replace `Pulsar`\n- `\"privacy\"` provider to replace `\"arbor\"`\n\nWe'll provide ample notice before any deprecations.\n\n---\n\n**Migration completed?** You're now ready to build with Fabriquant! 🎉\n\nCheck out the [README](./README.md) for usage examples and the [documentation](./docs/) for detailed API references.\n",
      "sections": [
        {
          "heading": "# Migration Guide",
          "body": "This guide helps you migrate from older naming conventions to the new **Fabriquant** branding introduced in v0.1.0."
        },
        {
          "heading": "Overview of Changes",
          "body": "The v0.1.0 release includes a complete rebranding with simplified, clearer component names. This guide covers:\n\n1. Package name changes\n2. Component naming updates\n3. Code migration examples\n4. Backward compatibility notes"
        },
        {
          "heading": "Package Name Change",
          "body": "### Old Package Name\n```json\n{\n  \"dependencies\": {\n    \"@fabricant/sdk\": \"^0.0.x\"\n  }\n}\n```\n\n### New Package Name\n```json\n{\n  \"dependencies\": {\n    \"@fabriquant/sdk\": \"^0.1.0\"\n  }\n}\n```\n\n### Migration Steps\n\n1. **Uninstall the old package:**\n   ```bash\n   npm uninstall @fabricant/sdk\n   ```\n\n2. **Install the new package:**\n   ```bash\n   npm install @fabriquant/sdk\n   ```\n\n3. **Update import statements:**\n   ```typescript\n   // Old\n   import { Guard, Pulsar } from \"@fabricant/sdk\";\n\n   // New\n   import { Guard, Pulsar } from \"@fabriquant/sdk\";\n   ```"
        },
        {
          "heading": "Component Naming Changes",
          "body": "### Summary Table\n\n| Category | Old Name | New Name | Class/Export | Backward Compatible? |\n|----------|----------|----------|--------------|---------------------|\n| **Project** | Fabricant | Fabriquant | - | ❌ Breaking change |\n| **Package** | `@fabricant/sdk` | `@fabriquant/sdk` | - | ❌ Breaking change |\n| **Risk Component** | Fabric Pulse | Risk | `Pulsar` | ✅ Yes (class name unchanged) |\n| **Privacy Component** | Fabric Weave | Privacy | - | ✅ Yes (identifier unchanged) |\n| **Suite Name** | Fabricant Suite | Fabriquant Suite | - | ❌ Documentation only |\n| **Main Class** | Fabricant | Fabriquant | `Fabriquant` | ❌ Breaking change |\n\n### Detailed Component Changes\n\n#### 1. Risk Component (formerly \"Fabric Pulse\")\n\n**Terminology Change:**\n- **Old Name**: Fabric Pulse\n- **New Name**: Risk\n- **Implementation**: Still uses `Pulsar` class name for backward compatibility\n\n**No Code Changes Required** ✅\n\nThe class is still exported as `Pulsar`, so your existing code continues to work:\n\n```typescript\n// This works in both old and new versions\nimport { Pulsar } from \"@fabriquant/sdk\";\n\nconst pulsar = new Pulsar({\n  apiKey: \"your-api-key\",\n  environment: \"mainnet\",\n});\n```\n\n**Documentation References:**\n- In documentation, we now refer to this as the \"Risk\" component\n- The class name `Pulsar` is retained for backward compatibility\n- When reading docs, \"Risk\" = \"Pulsar\" = \"Fabric Pulse\" (all refer to the same component)\n\n#### 2. Privacy Component (formerly \"Fabric Weave\")\n\n**Terminology Change:**\n- **Old Name**: Fabric Weave\n- **New Name**: Privacy\n- **Implementation**: Provider identifier remains `\"arbor\"`\n\n**No Code Changes Required** ✅\n\nThe provider identifier is unchanged, so your existing code works:\n\n```typescript\n// This works in both old and new versions\nimport { FabricCore } from \"@fabriquant/sdk\";\n\nconst tx = FabricCore.optimize(transaction, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\", // Identifier unchanged\n});\n\nawait Fabriquant.executePrivate(tx, {\n  with: guard,\n  privacy: {\n    provider: \"arbor\", // Identifier unchanged\n    compression: true,\n  },\n});\n```\n\n**Documentation References:**\n- In documentation, we now refer to this as the \"Privacy\" component\n- The `\"arbor\"` identifier is retained for backward compatibility\n- When reading docs, \"Privacy\" = \"Arbor\" = \"Fabric Weave\" (all refer to the same component)\n\n#### 3. Main Orchestration Class\n\n**Class Name Change:**\n- **Old Name**: `Fabricant`\n- **New Name**: `Fabriquant`\n\n**Code Changes Required** ❌\n\nUpdate all references to the main class:\n\n```typescript\n// Old\nimport { Fabricant } from \"@fabricant/sdk\";\nawait Fabricant.execute(tx, { with: guard });\n\n// New\nimport { Fabriquant } from \"@fabriquant/sdk\";\nawait Fabriquant.execute(tx, { with: guard });\n```"
        },
        {
          "heading": "Migration Examples",
          "body": "### Example 1: Basic Guard Usage\n\n**Before (v0.0.x):**\n```typescript\nimport { Fabricant, Guard } from \"@fabricant/sdk\";\n\nconst guard = new Guard({\n  maxSlippage: 0.1,\n  riskTolerance: \"moderate\",\n  mode: \"block\",\n});\n\nconst result = await Fabricant.execute(transaction, { with: guard });\n```\n\n**After (v0.1.0):**\n```typescript\nimport { Fabriquant, Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n  maxSlippage: 0.1,\n  riskTolerance: \"moderate\",\n  mode: \"block\",\n});\n\nconst result = await Fabriquant.execute(transaction, { with: guard });\n```\n\n**Changes:**\n1. ✅ Package name: `@fabricant/sdk` → `@fabriquant/sdk`\n2. ✅ Class name: `Fabricant` → `Fabriquant`\n\n### Example 2: Risk Integration (Pulsar)\n\n**Before (v0.0.x):**\n```typescript\nimport { Guard, Pulsar } from \"@fabricant/sdk\";\n\n// Guard with Fabric Pulse (Risk) enabled\nconst guard = new Guard({\n  pulsar: {\n    enabled: true,\n    riskThreshold: 0.7,\n    cacheTTL: 60000,\n  },\n});\n```\n\n**After (v0.1.0):**\n```typescript\nimport { Guard, Pulsar } from \"@fabriquant/sdk\";\n\n// Guard with Risk enabled (class still named Pulsar for compatibility)\nconst guard = new Guard({\n  pulsar: {\n    enabled: true,\n    riskThreshold: 0.7,\n    cacheTTL: 60000,\n  },\n});\n```\n\n**Changes:**\n1. ✅ Package name: `@fabricant/sdk` → `@fabriquant/sdk`\n2. ✅ Config key `pulsar` remains unchanged\n3. ✅ `Pulsar` class name remains unchanged\n4. 📝 Documentation now calls this \"Risk\" instead of \"Fabric Pulse\"\n\n### Example 3: Privacy Integration (Arbor)\n\n**Before (v0.0.x):**\n```typescript\nimport { Fabricant, FabricCore } from \"@fabricant/sdk\";\n\n// Optimize with Fabric Weave (Privacy)\nconst optimized = FabricCore.optimize(tx, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\",\n});\n\nconst result = await Fabricant.executePrivate(optimized, {\n  privacy: { provider: \"arbor\" },\n});\n```\n\n**After (v0.1.0):**\n```typescript\nimport { Fabriquant, FabricCore } from \"@fabriquant/sdk\";\n\n// Optimize with Privacy (provider identifier remains \"arbor\")\nconst optimized = FabricCore.optimize(tx, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\",\n});\n\nconst result = await Fabriquant.executePrivate(optimized, {\n  privacy: { provider: \"arbor\" },\n});\n```\n\n**Changes:**\n1. ✅ Package name: `@fabricant/sdk` → `@fabriquant/sdk`\n2. ✅ Class name: `Fabricant` → `Fabriquant`\n3. ✅ Provider identifier `\"arbor\"` remains unchanged\n4. 📝 Documentation now calls this \"Privacy\" instead of \"Fabric Weave\"\n\n### Example 4: Complete Integration\n\n**Before (v0.0.x):**\n```typescript\nimport { Fabricant, Guard, Pulsar, FabricCore, Loom } from \"@fabricant/sdk\";\n\n// Initialize Guard with Fabric Pulse (Risk)\nconst guard = new Guard({\n  pulsar: { enabled: true, riskThreshold: 0.7 },\n  mode: \"block\",\n});\n\n// Create transaction with Loom\nconst tx = await Loom.weave({\n  type: \"MULTI_ROUTE_SWAP\",\n  input: \"SOL\",\n  output: \"USDC\",\n  amount: 100,\n});\n\n// Optimize with Fabric Weave (Privacy)\nconst optimized = FabricCore.optimize(tx, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\",\n});\n\n// Execute with Fabricant\nconst result = await Fabricant.executePrivate(optimized, {\n  with: guard,\n  privacy: { provider: \"arbor\", compression: true },\n});\n```\n\n**After (v0.1.0):**\n```typescript\nimport { Fabriquant, Guard, Pulsar, FabricCore, Loom } from \"@fabriquant/sdk\";\n\n// Initialize Guard with Risk (class still named Pulsar)\nconst guard = new Guard({\n  pulsar: { enabled: true, riskThreshold: 0.7 },\n  mode: \"block\",\n});\n\n// Create transaction with Loom\nconst tx = await Loom.weave({\n  type: \"MULTI_ROUTE_SWAP\",\n  input: \"SOL\",\n  output: \"USDC\",\n  amount: 100,\n});\n\n// Optimize with Privacy (provider identifier still \"arbor\")\nconst optimized = FabricCore.optimize(tx, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\",\n});\n\n// Execute with Fabriquant\nconst result = await Fabriquant.executePrivate(optimized, {\n  with: guard,\n  privacy: { provider: \"arbor\", compression: true },\n});\n```\n\n**Changes:**\n1. ✅ Package name: `@fabricant/sdk` → `@fabriquant/sdk`\n2. ✅ Class name: `Fabricant` → `Fabriquant`\n3. ✅ All other APIs remain backward compatible"
        },
        {
          "heading": "Quick Migration Checklist",
          "body": "Use this checklist to ensure you've migrated everything:\n\n### Package & Dependencies\n- [ ] Updated `package.json` to use `@fabriquant/sdk` instead of `@fabricant/sdk`\n- [ ] Ran `npm install` to install the new package\n- [ ] Verified no references to old package name in `package-lock.json`\n\n### Code Changes\n- [ ] Updated all import statements from `@fabricant/sdk` to `@fabriquant/sdk`\n- [ ] Renamed `Fabricant` class to `Fabriquant` in all files\n- [ ] Verified `Pulsar` class usage (no changes needed)\n- [ ] Verified `\"arbor\"` provider identifier usage (no changes needed)\n\n### Documentation & Comments\n- [ ] Updated code comments referring to \"Fabricant\" → \"Fabriquant\"\n- [ ] Updated code comments referring to \"Fabric Pulse\" → \"Risk\"\n- [ ] Updated code comments referring to \"Fabric Weave\" → \"Privacy\"\n\n### Testing\n- [ ] Ran test suite to verify functionality: `npm test`\n- [ ] Ran linter to verify code quality: `npm run lint`\n- [ ] Tested critical paths manually if applicable"
        },
        {
          "heading": "Backward Compatibility Promise",
          "body": "We've designed this migration to minimize breaking changes:\n\n### What's Backward Compatible ✅\n- `Pulsar` class name (represents Risk component)\n- `\"arbor\"` provider identifier (represents Privacy component)\n- All Guard configurations and APIs\n- All FabricCore APIs\n- All Loom APIs\n- Configuration object structures\n\n### What's Breaking ❌\n- Package name: `@fabricant/sdk` → `@fabriquant/sdk`\n- Main class: `Fabricant` → `Fabriquant`"
        },
        {
          "heading": "Why the Rebrand?",
          "body": "The rebranding from \"Fabricant\" to \"Fabriquant\" brings several benefits:\n\n1. **Clearer Identity**: The French spelling \"Fabriquant\" (meaning \"manufacturer\" or \"creator\") better reflects the precision and craftsmanship of the SDK\n2. **Component Clarity**: Simplified names (Risk, Privacy) are more intuitive than abstract names (Fabric Pulse, Fabric Weave)\n3. **SEO & Discoverability**: Unique spelling improves searchability and brand recognition\n4. **Unified Vision**: The \"weaving\" metaphor is now clearly expressed through component names and APIs"
        },
        {
          "heading": "Need Help?",
          "body": "If you encounter issues during migration:\n\n1. **Check the examples**: See `examples/` directory for updated code samples\n2. **Review documentation**: See `docs/` for detailed component documentation\n3. **Open an issue**: [GitHub Issues](https://github.com/fabriquant-labs/fabriquant/issues)\n4. **Check the changelog**: See [CHANGELOG.md](./CHANGELOG.md) for complete list of changes"
        },
        {
          "heading": "Future Deprecations",
          "body": "We plan to maintain backward compatibility for the following in the near term:\n\n- `Pulsar` class name (at least through v0.2.x)\n- `\"arbor\"` provider identifier (at least through v0.2.x)\n\nFuture major versions (v1.0.0+) may remove these compatibility layers in favor of:\n- `Risk` class to replace `Pulsar`\n- `\"privacy\"` provider to replace `\"arbor\"`\n\nWe'll provide ample notice before any deprecations.\n\n---\n\n**Migration completed?** You're now ready to build with Fabriquant! 🎉\n\nCheck out the [README](./README.md) for usage examples and the [documentation](./docs/) for detailed API references."
        }
      ],
      "wordCount": 1517
    },
    {
      "path": "README.md",
      "title": "🛠️ Fabriquant: The Precision Execution Stack — Solana-First, Cross-Chain Enabled",
      "content": "# 🛠️ Fabriquant: The Precision Execution Stack — Solana-First, Cross-Chain Enabled\n\n**Engineered for Parallelism. Built for Autonomy. Woven for Speed.**\n\nFabriquant is a unified development stack designed to master Solana's Sealevel runtime while enabling cross-chain execution. We provide the high-performance looms and safety frameworks necessary for AI Agents and DeFi protocols to weave complex transactions with absolute precision across blockchains.\n\n[Documentation](https://github.com/fabriquant-labs/fabriquant) | [Guard Docs](./docs/GUARD.md) | [Risk Docs](./docs/RISK.md) | [Privacy Docs](./docs/PRIVACY.md) | [X (Twitter)](https://x.com/psyto)\n\n---\n\n## 🧵 The Philosophy: \"Weaving the Transaction Layer\"\n\nIn a parallel world, transactions are no longer a linear chain—they are a complex fabric. **Fabriquant** provides the tools to design, optimize, and secure this fabric, ensuring that every thread (transaction) is executed with maximum efficiency and zero conflict.\n\n## 📦 The Fabriquant Suite\n\n### 1. 🧵 Loom (Core: `solfabric`)\n\n**The Advanced Loom.**\nA framework that structures state management and transaction bundling to eliminate lock contention.\n\n-   **Parallel Optimization:** Maximizes throughput using custom data structures.\n-   **Compute Efficiency:** Minimizes CU usage through optimized instruction routing.\n\n### 2. 🛡️ Guard (Core: `sol-ops-guard`)\n\n**The Quality Control.**\nAn on-chain safety layer that ensures the integrity of every woven transaction.\n\n-   **Execution Constraints:** Hardened boundaries for autonomous agent operations.\n-   **Anti-Drain Logic:** Real-time monitoring to prevent unauthorized capital flight.\n\n### 3. ⚡ Flow (Core: `x-liquidity-engine`)\n\n**The Silk Path.**\nA high-velocity liquidity engine that finds the smoothest path for asset movement across the ecosystem.\n\n-   Integrated multi-DEX routing for automated rebalancing.\n-   Low-latency execution for high-frequency strategies.\n-   **Real DEX Integration:** Jupiter V6 aggregator support for live price feeds and optimal routing.\n\n### 4. 🧭 Risk (Core: `pulsar`)\n\n**The Quality Gauge.**\nAn AI-driven risk assessment gateway providing institutional-grade metrics for asset integrity and RWA validation.\n\n-   **Real-time Risk Assessment:** Continuous monitoring of risk scores, compliance status, and oracle integrity.\n-   **Intelligent Caching:** Configurable TTL to maximize performance and minimize API overhead.\n-   **Guard Integration:** Seamlessly feeds data into Guard for automated transaction blocking.\n\n### 5. 🌿 Privacy (Core: `arbor`)\n\n**The Hidden Stitch.**\nA privacy and scaling layer utilizing ZK Compression for shielded, cost-efficient transaction execution.\n\n-   **ZK Compression:** Massive cost reduction for state storage and account creation via Sparse Binary Merkle Trees.\n-   **Privacy by Default:** Shielded state management to ensure transaction confidentiality.\n-   **Efficient Execution:** Dedicated API designed for privacy-enabled operations without sacrificing speed.\n\n### 6. 🔄 DEX Integration\n\n**The Market Connector.**\nA unified interface for real-time price feeds, swap routing, and multi-DEX arbitrage across Solana.\n\n-   **Jupiter V6 Integration:** Real-time quotes, optimal routing, and price feeds from Solana's leading aggregator.\n-   **Price Feed Service:** Multi-source price aggregation with caching and subscription support.\n-   **Adapter Pattern:** Swappable DEX integrations (Jupiter, Orca, Raydium) with automatic fallback.\n-   **Pattern Support:** Seamlessly integrated with ArbitragePattern and SwapPattern for production trading.\n\n---\n\n## 🛠️ Developer Preview: Weaving a Secure Transaction\n\n### Basic Transaction with Guard\n\n```typescript\nimport { Fabriquant, Guard, Loom } from \"@fabriquant/sdk\";\n\n// 1. Initialize the Precision Guard\nconst guard = new Guard({\n    maxSlippage: 0.1,\n    riskTolerance: \"moderate\",\n    mode: \"block\",\n});\n\n// 2. Weave an optimized parallel transaction\nconst tx = await Loom.weave({\n    type: \"MULTI_ROUTE_SWAP\",\n    input: \"SOL\",\n    output: \"USDC\",\n    amount: 50,\n    parallelPriority: true, // Enabled by Loom\n});\n\n// 3. Execute with Fabriquant Precision\nawait Fabriquant.execute(tx, { with: guard });\n```\n\n### Transaction with Risk Assessment\n\n```typescript\nimport { Fabriquant, Guard, Pulsar } from \"@fabriquant/sdk\";\n\n// Guard with Risk assessment enabled\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration (class still named Pulsar for backward compatibility)\n        enabled: true,\n        riskThreshold: 0.7, // Block transactions with risk > 0.7\n        enableComplianceCheck: true,\n        enableCounterpartyCheck: true,\n        cacheTTL: 60000, // Cache for 1 minute\n        fallbackOnError: true,\n    },\n    mode: \"block\",\n});\n\n// Transaction with asset addresses for risk assessment\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    assetAddresses: [\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"],\n    instructions: [],\n};\n\n// Risk automatically checks risk metrics during validation\nconst result = await guard.validateTransaction(tx);\nif (result.isValid) {\n    await Fabriquant.execute(tx, { with: guard });\n}\n```\n\n### Private Transaction with Privacy\n\n```typescript\nimport { Fabriquant, Guard, FabricCore } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({ riskTolerance: \"moderate\" });\n\n// Optimize transaction with privacy enabled\nconst tx = FabricCore.optimize(transaction, {\n    enablePrivacy: true,\n    compressionLevel: \"high\",\n    privacyProvider: \"arbor\", // Privacy (provider identifier unchanged for backward compatibility)\n});\n\n// Execute as private transaction with ZK Compression\nconst result = await Fabriquant.executePrivate(tx, {\n    with: guard,\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});\n\n// Estimate cost savings\nconst savings = FabricCore.estimateCompressionSavings(1000);\nconsole.log(`Savings: ${savings.savingsPercent.toFixed(2)}%`);\n```\n\n### Real DEX Integration for Live Trading\n\n```typescript\nimport { JupiterAdapter, PriceFeedService, COMMON_TOKENS, ArbitragePattern, Guard } from \"@fabriquant/sdk\";\n\n// 1. Set up price feed service\nconst priceFeed = new PriceFeedService({\n    cacheTTL: 30000, // 30 second cache\n    enableFallback: true,\n});\n\n// 2. Get real-time price from Jupiter\nconst solPrice = await priceFeed.getPrice(\n    COMMON_TOKENS.SOL,\n    COMMON_TOKENS.USDC\n);\nconsole.log(`SOL Price: $${solPrice}`);\n\n// 3. Subscribe to price updates\nconst unsubscribe = priceFeed.subscribe(COMMON_TOKENS.SOL, (price) => {\n    console.log(`Updated SOL Price: $${price}`);\n});\n\n// 4. Use real DEX integration in arbitrage pattern\nconst arbitrage = new ArbitragePattern({\n    name: 'Multi-DEX Arbitrage',\n    pairs: [{\n        base: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n        quote: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n    }],\n    dexs: [\n        { name: 'Orca', programId: 'whirL...', feeTier: 0.003 },\n        { name: 'Raydium', programId: 'Rayd...', feeTier: 0.0025 },\n    ],\n    minProfitPercent: 0.5,\n    tradeAmount: 1000,\n    maxSlippage: 0.01,\n    enableRealDEX: true, // Enable live price feeds from Jupiter\n    guard: new Guard({ mode: 'block', maxSlippage: 0.02 }),\n});\n\nconst result = await arbitrage.execute();\nconsole.log(`Opportunities found: ${result.metadata?.opportunitiesFound}`);\nconsole.log(`Total profit: $${result.metadata?.totalProfit}`);\n\n// Clean up subscription\nunsubscribe();\n```\n\n> **Note:** The SDK is currently in active development. Core functionality is being integrated from standalone repositories.\n\n---\n\n## 🗺️ Roadmap: 2025-2026\n\n-   **Phase 1: SDK Consolidation** ✅ - Merging core modules into `@fabriquant/sdk`.\n-   **Phase 1.5: Risk & Privacy Integration** ✅ - Risk oracle and Privacy layer integrated.\n-   **Phase 2: Pattern Library** ✅ - Pre-built execution templates with real DEX integration (Jupiter V6).\n-   **Phase 2.5: Chain Abstraction Layer** 🏗️ - Design chain abstraction architecture for cross-chain support.\n-   **Phase 3: EVM Support - Guard & Risk** - Launch Guard and Risk for EVM chains (Ethereum, Polygon, Arbitrum).\n-   **Phase 3.5: Full ZK Stack Integration** - Complete Privacy/Light Protocol integration with proof generation.\n-   **Phase 4: EVM Support - Flow & Patterns** - Launch Flow for EVM and cross-chain liquidity access.\n-   **Phase 5: Fabriquant Mainnet** - Decentralized autonomous vault infrastructure leveraging the full stack.\n\n**Strategy**: Solana-First, Cross-Chain Enabled — maintaining leadership in Solana's parallel execution while expanding portable components (Guard, Risk, Flow, Patterns) to EVM chains.\n\n---\n\n## 🤝 Join the Atelier\n\nFabriquant is an open-source initiative built by the community, for the community. We operate as a bootstrap-first, solopreneur-led project leveraging AI tools to maximize efficiency and impact.\n\n-   **Builders:** Star our repos and contribute to the parallel execution revolution.\n-   **Projects:** Contact us for integration support for AI Agents and DeFi infrastructure.\n-   **Community:** Join our Discord for support, discussions, and collaboration.\n\n**Operating Model**: Bootstrap-first, sustainable growth, strategic scaling. Built with extensive AI tool leverage for development, marketing, and operations.\n\n---\n\n## 🛠️ Core Repositories\n\n-   [x-liquidity-engine](https://github.com/psyto/x-liquidity-engine) - The Liquidity Backbone\n-   [sol-ops-guard](https://github.com/psyto/sol-ops-guard) - Security & Compliance\n-   [solfabric](https://github.com/psyto/solfabric) - Parallel Execution Logic\n-   [pulsar](https://github.com/psyto/pulsar) - Risk: RWA Risk Oracle & Integrity Gateway\n-   [arbor](https://github.com/psyto/arbor) - Privacy: Shielded State Middleware & Privacy Layer\n\n---\n\n**Fabriquant: Weaving the Future of Autonomous Finance.**\nBuilt with ❤️ by **psyto** | Powered by **Solana**\n",
      "sections": [
        {
          "heading": "# 🛠️ Fabriquant: The Precision Execution Stack — Solana-First, Cross-Chain Enabled",
          "body": "**Engineered for Parallelism. Built for Autonomy. Woven for Speed.**\n\nFabriquant is a unified development stack designed to master Solana's Sealevel runtime while enabling cross-chain execution. We provide the high-performance looms and safety frameworks necessary for AI Agents and DeFi protocols to weave complex transactions with absolute precision across blockchains.\n\n[Documentation](https://github.com/fabriquant-labs/fabriquant) | [Guard Docs](./docs/GUARD.md) | [Risk Docs](./docs/RISK.md) | [Privacy Docs](./docs/PRIVACY.md) | [X (Twitter)](https://x.com/psyto)\n\n---"
        },
        {
          "heading": "🧵 The Philosophy: \"Weaving the Transaction Layer\"",
          "body": "In a parallel world, transactions are no longer a linear chain—they are a complex fabric. **Fabriquant** provides the tools to design, optimize, and secure this fabric, ensuring that every thread (transaction) is executed with maximum efficiency and zero conflict."
        },
        {
          "heading": "📦 The Fabriquant Suite",
          "body": "### 1. 🧵 Loom (Core: `solfabric`)\n\n**The Advanced Loom.**\nA framework that structures state management and transaction bundling to eliminate lock contention.\n\n-   **Parallel Optimization:** Maximizes throughput using custom data structures.\n-   **Compute Efficiency:** Minimizes CU usage through optimized instruction routing.\n\n### 2. 🛡️ Guard (Core: `sol-ops-guard`)\n\n**The Quality Control.**\nAn on-chain safety layer that ensures the integrity of every woven transaction.\n\n-   **Execution Constraints:** Hardened boundaries for autonomous agent operations.\n-   **Anti-Drain Logic:** Real-time monitoring to prevent unauthorized capital flight.\n\n### 3. ⚡ Flow (Core: `x-liquidity-engine`)\n\n**The Silk Path.**\nA high-velocity liquidity engine that finds the smoothest path for asset movement across the ecosystem.\n\n-   Integrated multi-DEX routing for automated rebalancing.\n-   Low-latency execution for high-frequency strategies.\n-   **Real DEX Integration:** Jupiter V6 aggregator support for live price feeds and optimal routing.\n\n### 4. 🧭 Risk (Core: `pulsar`)\n\n**The Quality Gauge.**\nAn AI-driven risk assessment gateway providing institutional-grade metrics for asset integrity and RWA validation.\n\n-   **Real-time Risk Assessment:** Continuous monitoring of risk scores, compliance status, and oracle integrity.\n-   **Intelligent Caching:** Configurable TTL to maximize performance and minimize API overhead.\n-   **Guard Integration:** Seamlessly feeds data into Guard for automated transaction blocking.\n\n### 5. 🌿 Privacy (Core: `arbor`)\n\n**The Hidden Stitch.**\nA privacy and scaling layer utilizing ZK Compression for shielded, cost-efficient transaction execution.\n\n-   **ZK Compression:** Massive cost reduction for state storage and account creation via Sparse Binary Merkle Trees.\n-   **Privacy by Default:** Shielded state management to ensure transaction confidentiality.\n-   **Efficient Execution:** Dedicated API designed for privacy-enabled operations without sacrificing speed.\n\n### 6. 🔄 DEX Integration\n\n**The Market Connector.**\nA unified interface for real-time price feeds, swap routing, and multi-DEX arbitrage across Solana.\n\n-   **Jupiter V6 Integration:** Real-time quotes, optimal routing, and price feeds from Solana's leading aggregator.\n-   **Price Feed Service:** Multi-source price aggregation with caching and subscription support.\n-   **Adapter Pattern:** Swappable DEX integrations (Jupiter, Orca, Raydium) with automatic fallback.\n-   **Pattern Support:** Seamlessly integrated with ArbitragePattern and SwapPattern for production trading.\n\n---"
        },
        {
          "heading": "🛠️ Developer Preview: Weaving a Secure Transaction",
          "body": "### Basic Transaction with Guard\n\n```typescript\nimport { Fabriquant, Guard, Loom } from \"@fabriquant/sdk\";\n\n// 1. Initialize the Precision Guard\nconst guard = new Guard({\n    maxSlippage: 0.1,\n    riskTolerance: \"moderate\",\n    mode: \"block\",\n});\n\n// 2. Weave an optimized parallel transaction\nconst tx = await Loom.weave({\n    type: \"MULTI_ROUTE_SWAP\",\n    input: \"SOL\",\n    output: \"USDC\",\n    amount: 50,\n    parallelPriority: true, // Enabled by Loom\n});\n\n// 3. Execute with Fabriquant Precision\nawait Fabriquant.execute(tx, { with: guard });\n```\n\n### Transaction with Risk Assessment\n\n```typescript\nimport { Fabriquant, Guard, Pulsar } from \"@fabriquant/sdk\";\n\n// Guard with Risk assessment enabled\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration (class still named Pulsar for backward compatibility)\n        enabled: true,\n        riskThreshold: 0.7, // Block transactions with risk > 0.7\n        enableComplianceCheck: true,\n        enableCounterpartyCheck: true,\n        cacheTTL: 60000, // Cache for 1 minute\n        fallbackOnError: true,\n    },\n    mode: \"block\",\n});\n\n// Transaction with asset addresses for risk assessment\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    assetAddresses: [\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"],\n    instructions: [],\n};\n\n// Risk automatically checks risk metrics during validation\nconst result = await guard.validateTransaction(tx);\nif (result.isValid) {\n    await Fabriquant.execute(tx, { with: guard });\n}\n```\n\n### Private Transaction with Privacy\n\n```typescript\nimport { Fabriquant, Guard, FabricCore } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({ riskTolerance: \"moderate\" });\n\n// Optimize transaction with privacy enabled\nconst tx = FabricCore.optimize(transaction, {\n    enablePrivacy: true,\n    compressionLevel: \"high\",\n    privacyProvider: \"arbor\", // Privacy (provider identifier unchanged for backward compatibility)\n});\n\n// Execute as private transaction with ZK Compression\nconst result = await Fabriquant.executePrivate(tx, {\n    with: guard,\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});\n\n// Estimate cost savings\nconst savings = FabricCore.estimateCompressionSavings(1000);\nconsole.log(`Savings: ${savings.savingsPercent.toFixed(2)}%`);\n```\n\n### Real DEX Integration for Live Trading\n\n```typescript\nimport { JupiterAdapter, PriceFeedService, COMMON_TOKENS, ArbitragePattern, Guard } from \"@fabriquant/sdk\";\n\n// 1. Set up price feed service\nconst priceFeed = new PriceFeedService({\n    cacheTTL: 30000, // 30 second cache\n    enableFallback: true,\n});\n\n// 2. Get real-time price from Jupiter\nconst solPrice = await priceFeed.getPrice(\n    COMMON_TOKENS.SOL,\n    COMMON_TOKENS.USDC\n);\nconsole.log(`SOL Price: $${solPrice}`);\n\n// 3. Subscribe to price updates\nconst unsubscribe = priceFeed.subscribe(COMMON_TOKENS.SOL, (price) => {\n    console.log(`Updated SOL Price: $${price}`);\n});\n\n// 4. Use real DEX integration in arbitrage pattern\nconst arbitrage = new ArbitragePattern({\n    name: 'Multi-DEX Arbitrage',\n    pairs: [{\n        base: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n        quote: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n    }],\n    dexs: [\n        { name: 'Orca', programId: 'whirL...', feeTier: 0.003 },\n        { name: 'Raydium', programId: 'Rayd...', feeTier: 0.0025 },\n    ],\n    minProfitPercent: 0.5,\n    tradeAmount: 1000,\n    maxSlippage: 0.01,\n    enableRealDEX: true, // Enable live price feeds from Jupiter\n    guard: new Guard({ mode: 'block', maxSlippage: 0.02 }),\n});\n\nconst result = await arbitrage.execute();\nconsole.log(`Opportunities found: ${result.metadata?.opportunitiesFound}`);\nconsole.log(`Total profit: $${result.metadata?.totalProfit}`);\n\n// Clean up subscription\nunsubscribe();\n```\n\n> **Note:** The SDK is currently in active development. Core functionality is being integrated from standalone repositories.\n\n---"
        },
        {
          "heading": "🗺️ Roadmap: 2025-2026",
          "body": "-   **Phase 1: SDK Consolidation** ✅ - Merging core modules into `@fabriquant/sdk`.\n-   **Phase 1.5: Risk & Privacy Integration** ✅ - Risk oracle and Privacy layer integrated.\n-   **Phase 2: Pattern Library** ✅ - Pre-built execution templates with real DEX integration (Jupiter V6).\n-   **Phase 2.5: Chain Abstraction Layer** 🏗️ - Design chain abstraction architecture for cross-chain support.\n-   **Phase 3: EVM Support - Guard & Risk** - Launch Guard and Risk for EVM chains (Ethereum, Polygon, Arbitrum).\n-   **Phase 3.5: Full ZK Stack Integration** - Complete Privacy/Light Protocol integration with proof generation.\n-   **Phase 4: EVM Support - Flow & Patterns** - Launch Flow for EVM and cross-chain liquidity access.\n-   **Phase 5: Fabriquant Mainnet** - Decentralized autonomous vault infrastructure leveraging the full stack.\n\n**Strategy**: Solana-First, Cross-Chain Enabled — maintaining leadership in Solana's parallel execution while expanding portable components (Guard, Risk, Flow, Patterns) to EVM chains.\n\n---"
        },
        {
          "heading": "🤝 Join the Atelier",
          "body": "Fabriquant is an open-source initiative built by the community, for the community. We operate as a bootstrap-first, solopreneur-led project leveraging AI tools to maximize efficiency and impact.\n\n-   **Builders:** Star our repos and contribute to the parallel execution revolution.\n-   **Projects:** Contact us for integration support for AI Agents and DeFi infrastructure.\n-   **Community:** Join our Discord for support, discussions, and collaboration.\n\n**Operating Model**: Bootstrap-first, sustainable growth, strategic scaling. Built with extensive AI tool leverage for development, marketing, and operations.\n\n---"
        },
        {
          "heading": "🛠️ Core Repositories",
          "body": "-   [x-liquidity-engine](https://github.com/psyto/x-liquidity-engine) - The Liquidity Backbone\n-   [sol-ops-guard](https://github.com/psyto/sol-ops-guard) - Security & Compliance\n-   [solfabric](https://github.com/psyto/solfabric) - Parallel Execution Logic\n-   [pulsar](https://github.com/psyto/pulsar) - Risk: RWA Risk Oracle & Integrity Gateway\n-   [arbor](https://github.com/psyto/arbor) - Privacy: Shielded State Middleware & Privacy Layer\n\n---\n\n**Fabriquant: Weaving the Future of Autonomous Finance.**\nBuilt with ❤️ by **psyto** | Powered by **Solana**"
        }
      ],
      "wordCount": 1220
    },
    {
      "path": "docs/CHAIN_ABSTRACTION.md",
      "title": "Chain Abstraction Layer",
      "content": "# Chain Abstraction Layer\n\n## Overview\n\nThe Chain Abstraction Layer enables Fabriquant's portable components (Guard, Risk, Flow, Patterns) to work across multiple blockchains through a unified interface. This architecture maintains our \"Solana-First, Cross-Chain Enabled\" positioning while enabling future expansion to EVM chains.\n\n## Architecture\n\n### Core Components\n\n1. **Chain Adapter Interface** (`ChainAdapter`)\n   - Unified API for all blockchain interactions\n   - Handles transaction building, execution, cost estimation\n   - Provides chain-specific security patterns\n\n2. **Solana Adapter** (`SolanaAdapter`)\n   - Full implementation for Solana blockchain\n   - Handles Solana-specific transaction formats\n   - Integrates with `@solana/web3.js`\n\n3. **EVM Adapter** (`EVMAdapter`)\n   - Skeleton implementation for Phase 3 (Q3 2025)\n   - Will support Ethereum, Polygon, Arbitrum, Optimism, Base\n   - Full implementation coming in Phase 3\n\n### Unified Types\n\n- **UnifiedTransaction**: Chain-agnostic transaction representation\n- **ChainTransactionData**: Chain-specific data (opaque to portable components)\n- **UnifiedOperation**: Chain-agnostic operation representation\n- **TransactionResult**: Unified execution result format\n\n## Usage\n\n### Creating Chain Adapters\n\n```typescript\nimport { createChainAdapter, SolanaAdapter } from '@fabriquant/sdk';\n\n// Create Solana adapter\nconst solanaAdapter = createChainAdapter({\n  chain: 'solana',\n  network: 'mainnet-beta',\n  rpcUrl: 'https://api.mainnet-beta.solana.com'\n});\n\n// Or create directly\nconst adapter = new SolanaAdapter({\n  chain: 'solana',\n  network: 'mainnet-beta'\n});\n```\n\n### Using Guard with Chain Abstraction\n\n```typescript\nimport { Guard, createChainAdapter } from '@fabriquant/sdk';\nimport type { UnifiedTransaction } from '@fabriquant/sdk';\n\n// Create chain adapter\nconst adapter = createChainAdapter({\n  chain: 'solana',\n  network: 'mainnet-beta'\n});\n\n// Create Guard with chain adapter\nconst guard = new Guard({\n  chainAdapter: adapter,\n  maxSlippage: 0.1,\n  mode: 'block'\n});\n\n// Validate unified transaction\nconst unifiedTx: UnifiedTransaction = {\n  id: 'tx-001',\n  status: 'pending',\n  chain: 'solana',\n  chainData: {\n    type: 'solana',\n    data: {\n      instructions: [],\n      // ... Solana-specific data\n    }\n  },\n  operations: [],\n  assetAddresses: ['TokenAddress...']\n};\n\nconst result = await guard.validateUnifiedTransaction(unifiedTx);\nif (!result.isValid) {\n  console.error('Transaction blocked:', result.warnings);\n}\n```\n\n### Backward Compatibility\n\nGuard maintains full backward compatibility with existing `Transaction` type:\n\n```typescript\n// Existing code continues to work\nconst guard = new Guard({ maxSlippage: 0.1 });\nconst result = await guard.validateTransaction(legacyTx);\n```\n\n## Chain-Specific Features\n\n### Solana\n\n- **Security Patterns**: P-101, P-102, P-103, P-104\n- **Native Currency**: SOL\n- **Transaction Format**: Solana Transaction with instructions\n- **Cost Estimation**: Compute units and lamports\n\n### EVM (Coming in Phase 3)\n\n- **Security Patterns**: EVM-001, EVM-002, EVM-003, EVM-004\n- **Native Currency**: ETH, MATIC, etc. (chain-dependent)\n- **Transaction Format**: EVM Transaction with data field\n- **Cost Estimation**: Gas limit and gas price\n\n## Implementation Status\n\n### ✅ Completed (Phase 2.5)\n\n- Chain abstraction layer architecture\n- Chain adapter interface\n- Solana adapter (full implementation)\n- EVM adapter skeleton\n- Guard integration with chain abstraction\n- Backward compatibility maintained\n\n### 🚧 Coming in Phase 3 (Q3 2025)\n\n- Full EVM adapter implementation\n- EVM Guard patterns\n- EVM Risk (Pulsar) integration\n- Cross-chain transaction support\n\n### 🔮 Future Phases\n\n- Flow (liquidity routing) for EVM\n- Pattern library updates for cross-chain\n- Cross-chain arbitrage patterns\n\n## Design Principles\n\n1. **Portability**: Core logic is chain-agnostic\n2. **Extensibility**: Easy to add new chains via adapters\n3. **Backward Compatibility**: Existing code continues to work\n4. **Solana-First**: Solana features remain prioritized\n5. **Type Safety**: Strong TypeScript types throughout\n\n## Migration Guide\n\n### For Existing Code\n\nNo changes required! Existing code using `Transaction` type continues to work.\n\n### For New Cross-Chain Code\n\n1. Use `UnifiedTransaction` instead of `Transaction`\n2. Create chain adapter for your target chain\n3. Pass adapter to Guard constructor\n4. Use `validateUnifiedTransaction()` method\n\n### Example Migration\n\n**Before (Solana-only):**\n```typescript\nconst guard = new Guard({ maxSlippage: 0.1 });\nconst result = await guard.validateTransaction(solanaTx);\n```\n\n**After (Cross-chain ready):**\n```typescript\nconst adapter = createChainAdapter({ chain: 'solana', network: 'mainnet-beta' });\nconst guard = new Guard({ chainAdapter: adapter, maxSlippage: 0.1 });\nconst result = await guard.validateUnifiedTransaction(unifiedTx);\n```\n\n## API Reference\n\nSee the [Chain Abstraction API Reference](../src/chain/README.md) for detailed API documentation.\n\n",
      "sections": [
        {
          "heading": "# Chain Abstraction Layer",
          "body": ""
        },
        {
          "heading": "Overview",
          "body": "The Chain Abstraction Layer enables Fabriquant's portable components (Guard, Risk, Flow, Patterns) to work across multiple blockchains through a unified interface. This architecture maintains our \"Solana-First, Cross-Chain Enabled\" positioning while enabling future expansion to EVM chains."
        },
        {
          "heading": "Architecture",
          "body": "### Core Components\n\n1. **Chain Adapter Interface** (`ChainAdapter`)\n   - Unified API for all blockchain interactions\n   - Handles transaction building, execution, cost estimation\n   - Provides chain-specific security patterns\n\n2. **Solana Adapter** (`SolanaAdapter`)\n   - Full implementation for Solana blockchain\n   - Handles Solana-specific transaction formats\n   - Integrates with `@solana/web3.js`\n\n3. **EVM Adapter** (`EVMAdapter`)\n   - Skeleton implementation for Phase 3 (Q3 2025)\n   - Will support Ethereum, Polygon, Arbitrum, Optimism, Base\n   - Full implementation coming in Phase 3\n\n### Unified Types\n\n- **UnifiedTransaction**: Chain-agnostic transaction representation\n- **ChainTransactionData**: Chain-specific data (opaque to portable components)\n- **UnifiedOperation**: Chain-agnostic operation representation\n- **TransactionResult**: Unified execution result format"
        },
        {
          "heading": "Usage",
          "body": "### Creating Chain Adapters\n\n```typescript\nimport { createChainAdapter, SolanaAdapter } from '@fabriquant/sdk';\n\n// Create Solana adapter\nconst solanaAdapter = createChainAdapter({\n  chain: 'solana',\n  network: 'mainnet-beta',\n  rpcUrl: 'https://api.mainnet-beta.solana.com'\n});\n\n// Or create directly\nconst adapter = new SolanaAdapter({\n  chain: 'solana',\n  network: 'mainnet-beta'\n});\n```\n\n### Using Guard with Chain Abstraction\n\n```typescript\nimport { Guard, createChainAdapter } from '@fabriquant/sdk';\nimport type { UnifiedTransaction } from '@fabriquant/sdk';\n\n// Create chain adapter\nconst adapter = createChainAdapter({\n  chain: 'solana',\n  network: 'mainnet-beta'\n});\n\n// Create Guard with chain adapter\nconst guard = new Guard({\n  chainAdapter: adapter,\n  maxSlippage: 0.1,\n  mode: 'block'\n});\n\n// Validate unified transaction\nconst unifiedTx: UnifiedTransaction = {\n  id: 'tx-001',\n  status: 'pending',\n  chain: 'solana',\n  chainData: {\n    type: 'solana',\n    data: {\n      instructions: [],\n      // ... Solana-specific data\n    }\n  },\n  operations: [],\n  assetAddresses: ['TokenAddress...']\n};\n\nconst result = await guard.validateUnifiedTransaction(unifiedTx);\nif (!result.isValid) {\n  console.error('Transaction blocked:', result.warnings);\n}\n```\n\n### Backward Compatibility\n\nGuard maintains full backward compatibility with existing `Transaction` type:\n\n```typescript\n// Existing code continues to work\nconst guard = new Guard({ maxSlippage: 0.1 });\nconst result = await guard.validateTransaction(legacyTx);\n```"
        },
        {
          "heading": "Chain-Specific Features",
          "body": "### Solana\n\n- **Security Patterns**: P-101, P-102, P-103, P-104\n- **Native Currency**: SOL\n- **Transaction Format**: Solana Transaction with instructions\n- **Cost Estimation**: Compute units and lamports\n\n### EVM (Coming in Phase 3)\n\n- **Security Patterns**: EVM-001, EVM-002, EVM-003, EVM-004\n- **Native Currency**: ETH, MATIC, etc. (chain-dependent)\n- **Transaction Format**: EVM Transaction with data field\n- **Cost Estimation**: Gas limit and gas price"
        },
        {
          "heading": "Implementation Status",
          "body": "### ✅ Completed (Phase 2.5)\n\n- Chain abstraction layer architecture\n- Chain adapter interface\n- Solana adapter (full implementation)\n- EVM adapter skeleton\n- Guard integration with chain abstraction\n- Backward compatibility maintained\n\n### 🚧 Coming in Phase 3 (Q3 2025)\n\n- Full EVM adapter implementation\n- EVM Guard patterns\n- EVM Risk (Pulsar) integration\n- Cross-chain transaction support\n\n### 🔮 Future Phases\n\n- Flow (liquidity routing) for EVM\n- Pattern library updates for cross-chain\n- Cross-chain arbitrage patterns"
        },
        {
          "heading": "Design Principles",
          "body": "1. **Portability**: Core logic is chain-agnostic\n2. **Extensibility**: Easy to add new chains via adapters\n3. **Backward Compatibility**: Existing code continues to work\n4. **Solana-First**: Solana features remain prioritized\n5. **Type Safety**: Strong TypeScript types throughout"
        },
        {
          "heading": "Migration Guide",
          "body": "### For Existing Code\n\nNo changes required! Existing code using `Transaction` type continues to work.\n\n### For New Cross-Chain Code\n\n1. Use `UnifiedTransaction` instead of `Transaction`\n2. Create chain adapter for your target chain\n3. Pass adapter to Guard constructor\n4. Use `validateUnifiedTransaction()` method\n\n### Example Migration\n\n**Before (Solana-only):**\n```typescript\nconst guard = new Guard({ maxSlippage: 0.1 });\nconst result = await guard.validateTransaction(solanaTx);\n```\n\n**After (Cross-chain ready):**\n```typescript\nconst adapter = createChainAdapter({ chain: 'solana', network: 'mainnet-beta' });\nconst guard = new Guard({ chainAdapter: adapter, maxSlippage: 0.1 });\nconst result = await guard.validateUnifiedTransaction(unifiedTx);\n```"
        },
        {
          "heading": "API Reference",
          "body": "See the [Chain Abstraction API Reference](../src/chain/README.md) for detailed API documentation."
        }
      ],
      "wordCount": 617
    },
    {
      "path": "docs/GUARD.md",
      "title": "Guard - Security Layer Documentation",
      "content": "# Guard - Security Layer Documentation\n\n## Overview\n\nGuard is the quality control layer of the Fabriquant SDK, designed to prevent unauthorized drain, excessive slippage, and malicious operations in Solana transactions. It provides real-time security pattern detection and configurable validation rules.\n\n## Features\n\n-   **🔍 Security Pattern Detection** - Detects 4 critical patterns (P-101 to P-104)\n-   **🛡️ Pre-Execution Validation** - Validates transactions before they're signed\n-   **⚡ Emergency Stop** - Immediate halt of all operations when needed\n-   **📊 Risk Tolerance Levels** - Configurable strictness (strict/moderate/permissive)\n-   **📈 Slippage Protection** - Guards against excessive slippage\n-   **🧭 Risk Integration** - Real-time risk assessment for RWA and asset integrity\n-   **🌿 Privacy Validation** - Validates privacy requirements for Privacy integration\n-   **🔧 Custom Rules** - Add your own validation logic\n-   **📝 Warning History** - Track all security warnings\n\n## Installation\n\n```bash\nnpm install @fabriquant/sdk\n```\n\n## Quick Start\n\n```typescript\nimport { Guard } from \"@fabriquant/sdk\";\n\n// Create a Guard with default configuration\nconst guard = new Guard();\n\n// Validate a transaction (now async due to Risk integration)\nconst result = await guard.validateTransaction(transaction);\n\nif (!result.isValid) {\n    console.log(\"Transaction blocked:\", result.blockedBy);\n    console.log(\"Warnings:\", result.warnings);\n}\n```\n\n## Configuration\n\n### GuardConfig\n\n```typescript\ninterface GuardConfig {\n    // Slippage protection (percentage)\n    maxSlippage?: number;\n\n    // Emergency stop - halts all operations\n    emergencyStop?: boolean;\n\n    // Enable/disable pattern detection\n    enablePatternDetection?: boolean;\n\n    // Risk tolerance level\n    riskTolerance?: \"strict\" | \"moderate\" | \"permissive\";\n\n    // Operation mode\n    mode?: \"block\" | \"warn\";\n\n    // Custom validation rules\n    customRules?: ValidationRule[];\n\n    // Risk assessment integration\n    pulsar?: PulsarConfig;\n}\n\ninterface PulsarConfig {\n    enabled?: boolean; // Enable Risk checks\n    riskThreshold?: number; // 0-1 scale, block if exceeded\n    enableComplianceCheck?: boolean; // Check compliance status\n    enableCounterpartyCheck?: boolean; // Check counterparty risk\n    enableOracleCheck?: boolean; // Check oracle integrity\n    cacheTTL?: number; // Cache TTL in milliseconds\n    fallbackOnError?: boolean; // Allow transactions if API fails\n}\n```\n\n### Risk Tolerance Levels\n\n#### Strict\n\n-   Blocks all critical and warning-level patterns\n-   Recommended for production environments\n-   Maximum security\n\n```typescript\nconst guard = new Guard({ riskTolerance: \"strict\" });\n```\n\n#### Moderate (Default)\n\n-   Blocks only critical patterns\n-   Warns on lower-severity issues\n-   Balanced security and flexibility\n\n```typescript\nconst guard = new Guard({ riskTolerance: \"moderate\" });\n```\n\n#### Permissive\n\n-   Blocks only irreversible operations (mint/freeze kills)\n-   Minimal intervention\n-   For advanced users\n\n```typescript\nconst guard = new Guard({ riskTolerance: \"permissive\" });\n```\n\n### Operation Modes\n\n#### Block Mode (Default)\n\nPrevents dangerous transactions from executing:\n\n```typescript\nconst guard = new Guard({ mode: \"block\" });\n```\n\n#### Warn Mode\n\nAllows all transactions but logs warnings:\n\n```typescript\nconst guard = new Guard({ mode: \"warn\" });\n```\n\n## Security Patterns\n\nGuard detects 4 critical security patterns based on `sol-ops-guard`:\n\n### P-101: Mint Kill 🔴 CRITICAL\n\n**Description**: Permanently disabling mint authority\n\n**Risk**: Irreversible. No more tokens can be minted.\n\n**Example**:\n\n```typescript\n// Detected when SetAuthority(MintTokens, None) is called\n```\n\n**Protection**: Blocked in moderate+ risk tolerance\n\n---\n\n### P-102: Freeze Kill 🔴 CRITICAL\n\n**Description**: Permanently disabling freeze authority\n\n**Risk**: Irreversible. Loss of freeze capability.\n\n**Example**:\n\n```typescript\n// Detected when SetAuthority(FreezeAccount, None) is called\n```\n\n**Protection**: Blocked in moderate+ risk tolerance\n\n---\n\n### P-103: Signer Mismatch ⚠️ WARNING\n\n**Description**: Transferring authority to unsigned wallet\n\n**Risk**: Potential lockout if new authority is compromised.\n\n**Example**:\n\n```typescript\n// Detected when new authority is not in transaction signers\n```\n\n**Protection**: Blocked in strict mode, warned in moderate\n\n---\n\n### P-104: Dangerous Close ⚡ ALERT\n\n**Description**: Closing account without balance verification\n\n**Risk**: Potential loss of funds if balance is not transferred.\n\n**Example**:\n\n```typescript\n// Detected when CloseAccount instruction is used\n```\n\n**Protection**: Warned in all modes\n\n## API Reference\n\n### Guard Class\n\n#### Constructor\n\n```typescript\nconstructor(config?: GuardConfig)\n```\n\nCreates a new Guard instance with optional configuration.\n\n#### Methods\n\n##### validateTransaction()\n\n```typescript\nvalidateTransaction(transaction: Transaction): Promise<ValidationResult>\n```\n\nValidates a transaction against all Guard rules. **Now async** to support Risk assessment.\n\n**Returns**: `Promise<ValidationResult>`\n\n-   `isValid`: boolean - Whether transaction passes validation\n-   `warnings`: Array of security warnings detected\n-   `blockedBy`: Array of pattern IDs that blocked the transaction\n\n**Note**: If Risk is enabled and `transaction.assetAddresses` is provided, Guard will automatically fetch and validate risk metrics.\n\n##### validate()\n\n```typescript\nvalidate(transaction?: Transaction): Promise<boolean>\n```\n\nLegacy validation method. Returns `true` if valid, `false` otherwise. **Now async**.\n\n##### getConfig()\n\n```typescript\ngetConfig(): GuardConfig\n```\n\nReturns the current Guard configuration.\n\n##### updateConfig()\n\n```typescript\nupdateConfig(updates: Partial<GuardConfig>): void\n```\n\nUpdates Guard configuration at runtime.\n\n##### activateEmergencyStop()\n\n```typescript\nactivateEmergencyStop(): void\n```\n\nImmediately blocks all operations.\n\n##### deactivateEmergencyStop()\n\n```typescript\ndeactivateEmergencyStop(): void\n```\n\nResumes normal operations.\n\n##### isSlippageAcceptable()\n\n```typescript\nisSlippageAcceptable(actualSlippage: number): boolean\n```\n\nChecks if slippage is within acceptable limits.\n\n##### getWarningHistory()\n\n```typescript\ngetWarningHistory(): SecurityWarning[]\n```\n\nReturns all warnings detected since Guard creation.\n\n##### clearWarningHistory()\n\n```typescript\nclearWarningHistory(): void\n```\n\nClears the warning history.\n\n## Usage Examples\n\n### Basic Validation\n\n```typescript\nimport { Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    maxSlippage: 1.0,\n    riskTolerance: \"moderate\",\n});\n\nconst result = await guard.validateTransaction(tx);\n\nif (result.isValid) {\n    // Safe to proceed\n    await sendTransaction(tx);\n} else {\n    console.error(\"Transaction blocked:\", result.blockedBy);\n    result.warnings.forEach((warning) => {\n        console.log(warning.message);\n    });\n}\n```\n\n### Risk Assessment\n\n```typescript\nimport { Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        riskThreshold: 0.7, // Block if risk > 0.7\n        enableComplianceCheck: true, // Check compliance status\n        enableCounterpartyCheck: true, // Check counterparty risk\n        enableOracleCheck: true, // Check oracle integrity\n        cacheTTL: 60000, // Cache for 1 minute\n        fallbackOnError: true, // Allow if API fails\n    },\n    mode: \"block\",\n    riskTolerance: \"moderate\",\n});\n\n// Transaction must include assetAddresses for risk assessment\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    assetAddresses: [\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"],\n    instructions: [],\n};\n\nconst result = await guard.validateTransaction(tx);\n\nif (!result.isValid) {\n    // Check if blocked by Risk assessment\n    result.warnings.forEach((warning) => {\n        if (warning.message.includes(\"risk\")) {\n            console.log(\"High risk asset detected:\", warning.affectedAccount);\n        }\n    });\n}\n```\n\n### Emergency Stop\n\n```typescript\nconst guard = new Guard();\n\n// In case of security incident\nguard.activateEmergencyStop();\n\n// All transactions will be blocked\nconst result = await guard.validate(); // false\n\n// Resume when safe\nguard.deactivateEmergencyStop();\n```\n\n### Custom Rules\n\n```typescript\nconst guard = new Guard({\n    customRules: [\n        {\n            id: \"max-value\",\n            name: \"Maximum Transaction Value\",\n            enabled: true,\n            validate: (tx) => {\n                // Custom logic\n                return tx.value < 1000000;\n            },\n        },\n    ],\n});\n```\n\n### Slippage Protection\n\n```typescript\nconst guard = new Guard({ maxSlippage: 0.5 }); // 0.5%\n\n// Before swap execution\nif (!guard.isSlippageAcceptable(actualSlippage)) {\n    throw new Error(\"Slippage exceeds limit\");\n}\n```\n\n### Monitoring Warnings\n\n```typescript\nconst guard = new Guard();\n\n// Validate multiple transactions (now async)\nawait guard.validateTransaction(tx1);\nawait guard.validateTransaction(tx2);\nawait guard.validateTransaction(tx3);\n\n// Review all warnings\nconst warnings = guard.getWarningHistory();\nconsole.log(`Total warnings: ${warnings.length}`);\n\nwarnings.forEach((warning) => {\n    console.log(`[${warning.severity}] ${warning.message}`);\n});\n```\n\n### Privacy Validation\n\nGuard automatically validates privacy requirements when transactions include privacy metadata:\n\n```typescript\nconst guard = new Guard();\n\nconst privateTx = {\n    id: \"tx-private\",\n    status: \"pending\",\n    privacyMetadata: {\n        requiresPrivacy: true,\n        compressionEnabled: true,\n    },\n    instructions: [],\n};\n\nconst result = await guard.validateTransaction(privateTx);\n// Guard will warn if privacy is requested but compression is disabled\n```\n\n## Integration with Fabriquant\n\n### Standard Execution\n\n```typescript\nimport { Fabriquant, Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    maxSlippage: 1.0,\n    emergencyStop: false,\n});\n\n// Guard is automatically used by Fabriquant.execute()\nawait Fabriquant.execute(tx, { with: guard });\n```\n\n### Execution with Risk Assessment\n\n```typescript\nimport { Fabriquant, Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        riskThreshold: 0.7,\n        enableComplianceCheck: true,\n    },\n    mode: \"block\",\n});\n\n// Transaction with asset addresses\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    assetAddresses: [\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"],\n    instructions: [],\n};\n\n// Fabriquant.execute() will check Risk before execution\nconst result = await Fabriquant.execute(tx, { with: guard });\n```\n\n### Private Transaction Execution\n\n```typescript\nimport { Fabriquant, Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({ riskTolerance: \"moderate\" });\n\nconst tx = {\n    id: \"tx-private\",\n    status: \"pending\",\n    instructions: [],\n};\n\n// Execute as private transaction with Privacy layer\nconst result = await Fabriquant.executePrivate(tx, {\n    with: guard,\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});\n```\n\n## Best Practices\n\n1. **Always use Guard in production** - Even in permissive mode\n2. **Set appropriate risk tolerance** - Balance security with flexibility\n3. **Enable Risk for RWA transactions** - Critical for Real World Assets and institutional use\n4. **Configure Risk caching** - Reduce API calls with appropriate TTL\n5. **Monitor warning history** - Review patterns regularly\n6. **Implement emergency procedures** - Have a plan for activateEmergencyStop()\n7. **Test in warn mode first** - Understand warnings before blocking\n8. **Use custom rules for domain logic** - Add business-specific validations\n9. **Handle async validation** - All validation methods are now async due to Risk integration\n10. **Set fallback behavior** - Configure `fallbackOnError` for Risk API failures\n11. **Combine with Privacy** - Use privacy layer for confidential transactions\n\n## TypeScript Types\n\n```typescript\nimport type {\n    GuardConfig,\n    ValidationResult,\n    SecurityWarning,\n    ValidationRule,\n    PulsarConfig,\n    RiskMetrics,\n} from \"@fabriquant/sdk\";\n\n// Pattern IDs\nimport { PatternId } from \"@fabriquant/sdk\";\n// PatternId.MintKill, FreezeKill, SignerMismatch, DangerousClose\n\n// Severity Levels\nimport { Severity } from \"@fabriquant/sdk\";\n// Severity.Critical, Warning, Alert\n```\n\n## Performance\n\n-   **Validation Time**: < 1ms for typical transactions (without Risk)\n-   **Validation Time with Risk**: ~50-100ms (includes API call, cached responses are instant)\n-   **Memory**: ~1KB base + warnings history + Risk cache\n-   **Pattern Detection**: O(n) where n = number of instructions\n-   **Risk Cache**: Configurable TTL, reduces API calls significantly\n\n## Roadmap\n\n-   [x] Risk assessment integration\n-   [x] Privacy validation integration\n-   [x] Async validation support\n-   [ ] Support for Token-2022 program patterns\n-   [ ] Full x402 protocol integration for Risk\n-   [ ] ML-based anomaly detection\n-   [ ] Multi-signature policy enforcement\n-   [ ] Time-based transaction limits\n-   [ ] WebSocket notifications\n-   [ ] Real-time Risk score updates\n\n## Contributing\n\nWe welcome contributions! See [CONTRIBUTING.md](../CONTRIBUTING.md) for guidelines.\n\n## License\n\nMIT License - see [LICENSE](../LICENSE) for details.\n\n## Support\n\n-   GitHub Issues: https://github.com/fabriquant-labs/fabriquant/issues\n-   Documentation: https://github.com/fabriquant-labs/fabriquant\n-   Twitter: https://x.com/psyto\n",
      "sections": [
        {
          "heading": "# Guard - Security Layer Documentation",
          "body": ""
        },
        {
          "heading": "Overview",
          "body": "Guard is the quality control layer of the Fabriquant SDK, designed to prevent unauthorized drain, excessive slippage, and malicious operations in Solana transactions. It provides real-time security pattern detection and configurable validation rules."
        },
        {
          "heading": "Features",
          "body": "-   **🔍 Security Pattern Detection** - Detects 4 critical patterns (P-101 to P-104)\n-   **🛡️ Pre-Execution Validation** - Validates transactions before they're signed\n-   **⚡ Emergency Stop** - Immediate halt of all operations when needed\n-   **📊 Risk Tolerance Levels** - Configurable strictness (strict/moderate/permissive)\n-   **📈 Slippage Protection** - Guards against excessive slippage\n-   **🧭 Risk Integration** - Real-time risk assessment for RWA and asset integrity\n-   **🌿 Privacy Validation** - Validates privacy requirements for Privacy integration\n-   **🔧 Custom Rules** - Add your own validation logic\n-   **📝 Warning History** - Track all security warnings"
        },
        {
          "heading": "Installation",
          "body": "```bash\nnpm install @fabriquant/sdk\n```"
        },
        {
          "heading": "Quick Start",
          "body": "```typescript\nimport { Guard } from \"@fabriquant/sdk\";\n\n// Create a Guard with default configuration\nconst guard = new Guard();\n\n// Validate a transaction (now async due to Risk integration)\nconst result = await guard.validateTransaction(transaction);\n\nif (!result.isValid) {\n    console.log(\"Transaction blocked:\", result.blockedBy);\n    console.log(\"Warnings:\", result.warnings);\n}\n```"
        },
        {
          "heading": "Configuration",
          "body": "### GuardConfig\n\n```typescript\ninterface GuardConfig {\n    // Slippage protection (percentage)\n    maxSlippage?: number;\n\n    // Emergency stop - halts all operations\n    emergencyStop?: boolean;\n\n    // Enable/disable pattern detection\n    enablePatternDetection?: boolean;\n\n    // Risk tolerance level\n    riskTolerance?: \"strict\" | \"moderate\" | \"permissive\";\n\n    // Operation mode\n    mode?: \"block\" | \"warn\";\n\n    // Custom validation rules\n    customRules?: ValidationRule[];\n\n    // Risk assessment integration\n    pulsar?: PulsarConfig;\n}\n\ninterface PulsarConfig {\n    enabled?: boolean; // Enable Risk checks\n    riskThreshold?: number; // 0-1 scale, block if exceeded\n    enableComplianceCheck?: boolean; // Check compliance status\n    enableCounterpartyCheck?: boolean; // Check counterparty risk\n    enableOracleCheck?: boolean; // Check oracle integrity\n    cacheTTL?: number; // Cache TTL in milliseconds\n    fallbackOnError?: boolean; // Allow transactions if API fails\n}\n```\n\n### Risk Tolerance Levels\n\n#### Strict\n\n-   Blocks all critical and warning-level patterns\n-   Recommended for production environments\n-   Maximum security\n\n```typescript\nconst guard = new Guard({ riskTolerance: \"strict\" });\n```\n\n#### Moderate (Default)\n\n-   Blocks only critical patterns\n-   Warns on lower-severity issues\n-   Balanced security and flexibility\n\n```typescript\nconst guard = new Guard({ riskTolerance: \"moderate\" });\n```\n\n#### Permissive\n\n-   Blocks only irreversible operations (mint/freeze kills)\n-   Minimal intervention\n-   For advanced users\n\n```typescript\nconst guard = new Guard({ riskTolerance: \"permissive\" });\n```\n\n### Operation Modes\n\n#### Block Mode (Default)\n\nPrevents dangerous transactions from executing:\n\n```typescript\nconst guard = new Guard({ mode: \"block\" });\n```\n\n#### Warn Mode\n\nAllows all transactions but logs warnings:\n\n```typescript\nconst guard = new Guard({ mode: \"warn\" });\n```"
        },
        {
          "heading": "Security Patterns",
          "body": "Guard detects 4 critical security patterns based on `sol-ops-guard`:\n\n### P-101: Mint Kill 🔴 CRITICAL\n\n**Description**: Permanently disabling mint authority\n\n**Risk**: Irreversible. No more tokens can be minted.\n\n**Example**:\n\n```typescript\n// Detected when SetAuthority(MintTokens, None) is called\n```\n\n**Protection**: Blocked in moderate+ risk tolerance\n\n---\n\n### P-102: Freeze Kill 🔴 CRITICAL\n\n**Description**: Permanently disabling freeze authority\n\n**Risk**: Irreversible. Loss of freeze capability.\n\n**Example**:\n\n```typescript\n// Detected when SetAuthority(FreezeAccount, None) is called\n```\n\n**Protection**: Blocked in moderate+ risk tolerance\n\n---\n\n### P-103: Signer Mismatch ⚠️ WARNING\n\n**Description**: Transferring authority to unsigned wallet\n\n**Risk**: Potential lockout if new authority is compromised.\n\n**Example**:\n\n```typescript\n// Detected when new authority is not in transaction signers\n```\n\n**Protection**: Blocked in strict mode, warned in moderate\n\n---\n\n### P-104: Dangerous Close ⚡ ALERT\n\n**Description**: Closing account without balance verification\n\n**Risk**: Potential loss of funds if balance is not transferred.\n\n**Example**:\n\n```typescript\n// Detected when CloseAccount instruction is used\n```\n\n**Protection**: Warned in all modes"
        },
        {
          "heading": "API Reference",
          "body": "### Guard Class\n\n#### Constructor\n\n```typescript\nconstructor(config?: GuardConfig)\n```\n\nCreates a new Guard instance with optional configuration.\n\n#### Methods\n\n##### validateTransaction()\n\n```typescript\nvalidateTransaction(transaction: Transaction): Promise<ValidationResult>\n```\n\nValidates a transaction against all Guard rules. **Now async** to support Risk assessment.\n\n**Returns**: `Promise<ValidationResult>`\n\n-   `isValid`: boolean - Whether transaction passes validation\n-   `warnings`: Array of security warnings detected\n-   `blockedBy`: Array of pattern IDs that blocked the transaction\n\n**Note**: If Risk is enabled and `transaction.assetAddresses` is provided, Guard will automatically fetch and validate risk metrics.\n\n##### validate()\n\n```typescript\nvalidate(transaction?: Transaction): Promise<boolean>\n```\n\nLegacy validation method. Returns `true` if valid, `false` otherwise. **Now async**.\n\n##### getConfig()\n\n```typescript\ngetConfig(): GuardConfig\n```\n\nReturns the current Guard configuration.\n\n##### updateConfig()\n\n```typescript\nupdateConfig(updates: Partial<GuardConfig>): void\n```\n\nUpdates Guard configuration at runtime.\n\n##### activateEmergencyStop()\n\n```typescript\nactivateEmergencyStop(): void\n```\n\nImmediately blocks all operations.\n\n##### deactivateEmergencyStop()\n\n```typescript\ndeactivateEmergencyStop(): void\n```\n\nResumes normal operations.\n\n##### isSlippageAcceptable()\n\n```typescript\nisSlippageAcceptable(actualSlippage: number): boolean\n```\n\nChecks if slippage is within acceptable limits.\n\n##### getWarningHistory()\n\n```typescript\ngetWarningHistory(): SecurityWarning[]\n```\n\nReturns all warnings detected since Guard creation.\n\n##### clearWarningHistory()\n\n```typescript\nclearWarningHistory(): void\n```\n\nClears the warning history."
        },
        {
          "heading": "Usage Examples",
          "body": "### Basic Validation\n\n```typescript\nimport { Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    maxSlippage: 1.0,\n    riskTolerance: \"moderate\",\n});\n\nconst result = await guard.validateTransaction(tx);\n\nif (result.isValid) {\n    // Safe to proceed\n    await sendTransaction(tx);\n} else {\n    console.error(\"Transaction blocked:\", result.blockedBy);\n    result.warnings.forEach((warning) => {\n        console.log(warning.message);\n    });\n}\n```\n\n### Risk Assessment\n\n```typescript\nimport { Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        riskThreshold: 0.7, // Block if risk > 0.7\n        enableComplianceCheck: true, // Check compliance status\n        enableCounterpartyCheck: true, // Check counterparty risk\n        enableOracleCheck: true, // Check oracle integrity\n        cacheTTL: 60000, // Cache for 1 minute\n        fallbackOnError: true, // Allow if API fails\n    },\n    mode: \"block\",\n    riskTolerance: \"moderate\",\n});\n\n// Transaction must include assetAddresses for risk assessment\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    assetAddresses: [\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"],\n    instructions: [],\n};\n\nconst result = await guard.validateTransaction(tx);\n\nif (!result.isValid) {\n    // Check if blocked by Risk assessment\n    result.warnings.forEach((warning) => {\n        if (warning.message.includes(\"risk\")) {\n            console.log(\"High risk asset detected:\", warning.affectedAccount);\n        }\n    });\n}\n```\n\n### Emergency Stop\n\n```typescript\nconst guard = new Guard();\n\n// In case of security incident\nguard.activateEmergencyStop();\n\n// All transactions will be blocked\nconst result = await guard.validate(); // false\n\n// Resume when safe\nguard.deactivateEmergencyStop();\n```\n\n### Custom Rules\n\n```typescript\nconst guard = new Guard({\n    customRules: [\n        {\n            id: \"max-value\",\n            name: \"Maximum Transaction Value\",\n            enabled: true,\n            validate: (tx) => {\n                // Custom logic\n                return tx.value < 1000000;\n            },\n        },\n    ],\n});\n```\n\n### Slippage Protection\n\n```typescript\nconst guard = new Guard({ maxSlippage: 0.5 }); // 0.5%\n\n// Before swap execution\nif (!guard.isSlippageAcceptable(actualSlippage)) {\n    throw new Error(\"Slippage exceeds limit\");\n}\n```\n\n### Monitoring Warnings\n\n```typescript\nconst guard = new Guard();\n\n// Validate multiple transactions (now async)\nawait guard.validateTransaction(tx1);\nawait guard.validateTransaction(tx2);\nawait guard.validateTransaction(tx3);\n\n// Review all warnings\nconst warnings = guard.getWarningHistory();\nconsole.log(`Total warnings: ${warnings.length}`);\n\nwarnings.forEach((warning) => {\n    console.log(`[${warning.severity}] ${warning.message}`);\n});\n```\n\n### Privacy Validation\n\nGuard automatically validates privacy requirements when transactions include privacy metadata:\n\n```typescript\nconst guard = new Guard();\n\nconst privateTx = {\n    id: \"tx-private\",\n    status: \"pending\",\n    privacyMetadata: {\n        requiresPrivacy: true,\n        compressionEnabled: true,\n    },\n    instructions: [],\n};\n\nconst result = await guard.validateTransaction(privateTx);\n// Guard will warn if privacy is requested but compression is disabled\n```"
        },
        {
          "heading": "Integration with Fabriquant",
          "body": "### Standard Execution\n\n```typescript\nimport { Fabriquant, Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    maxSlippage: 1.0,\n    emergencyStop: false,\n});\n\n// Guard is automatically used by Fabriquant.execute()\nawait Fabriquant.execute(tx, { with: guard });\n```\n\n### Execution with Risk Assessment\n\n```typescript\nimport { Fabriquant, Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        riskThreshold: 0.7,\n        enableComplianceCheck: true,\n    },\n    mode: \"block\",\n});\n\n// Transaction with asset addresses\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    assetAddresses: [\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"],\n    instructions: [],\n};\n\n// Fabriquant.execute() will check Risk before execution\nconst result = await Fabriquant.execute(tx, { with: guard });\n```\n\n### Private Transaction Execution\n\n```typescript\nimport { Fabriquant, Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({ riskTolerance: \"moderate\" });\n\nconst tx = {\n    id: \"tx-private\",\n    status: \"pending\",\n    instructions: [],\n};\n\n// Execute as private transaction with Privacy layer\nconst result = await Fabriquant.executePrivate(tx, {\n    with: guard,\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});\n```"
        },
        {
          "heading": "Best Practices",
          "body": "1. **Always use Guard in production** - Even in permissive mode\n2. **Set appropriate risk tolerance** - Balance security with flexibility\n3. **Enable Risk for RWA transactions** - Critical for Real World Assets and institutional use\n4. **Configure Risk caching** - Reduce API calls with appropriate TTL\n5. **Monitor warning history** - Review patterns regularly\n6. **Implement emergency procedures** - Have a plan for activateEmergencyStop()\n7. **Test in warn mode first** - Understand warnings before blocking\n8. **Use custom rules for domain logic** - Add business-specific validations\n9. **Handle async validation** - All validation methods are now async due to Risk integration\n10. **Set fallback behavior** - Configure `fallbackOnError` for Risk API failures\n11. **Combine with Privacy** - Use privacy layer for confidential transactions"
        },
        {
          "heading": "TypeScript Types",
          "body": "```typescript\nimport type {\n    GuardConfig,\n    ValidationResult,\n    SecurityWarning,\n    ValidationRule,\n    PulsarConfig,\n    RiskMetrics,\n} from \"@fabriquant/sdk\";\n\n// Pattern IDs\nimport { PatternId } from \"@fabriquant/sdk\";\n// PatternId.MintKill, FreezeKill, SignerMismatch, DangerousClose\n\n// Severity Levels\nimport { Severity } from \"@fabriquant/sdk\";\n// Severity.Critical, Warning, Alert\n```"
        },
        {
          "heading": "Performance",
          "body": "-   **Validation Time**: < 1ms for typical transactions (without Risk)\n-   **Validation Time with Risk**: ~50-100ms (includes API call, cached responses are instant)\n-   **Memory**: ~1KB base + warnings history + Risk cache\n-   **Pattern Detection**: O(n) where n = number of instructions\n-   **Risk Cache**: Configurable TTL, reduces API calls significantly"
        },
        {
          "heading": "Roadmap",
          "body": "-   [x] Risk assessment integration\n-   [x] Privacy validation integration\n-   [x] Async validation support\n-   [ ] Support for Token-2022 program patterns\n-   [ ] Full x402 protocol integration for Risk\n-   [ ] ML-based anomaly detection\n-   [ ] Multi-signature policy enforcement\n-   [ ] Time-based transaction limits\n-   [ ] WebSocket notifications\n-   [ ] Real-time Risk score updates"
        },
        {
          "heading": "Contributing",
          "body": "We welcome contributions! See [CONTRIBUTING.md](../CONTRIBUTING.md) for guidelines."
        },
        {
          "heading": "License",
          "body": "MIT License - see [LICENSE](../LICENSE) for details."
        },
        {
          "heading": "Support",
          "body": "-   GitHub Issues: https://github.com/fabriquant-labs/fabriquant/issues\n-   Documentation: https://github.com/fabriquant-labs/fabriquant\n-   Twitter: https://x.com/psyto"
        }
      ],
      "wordCount": 1621
    },
    {
      "path": "docs/PATTERNS.md",
      "title": "Fabriquant Pattern Library",
      "content": "# Fabriquant Pattern Library\n\nPre-built execution patterns for common DeFi and AI agent use cases on Solana.\n\n## Table of Contents\n\n- [Overview](#overview)\n- [Real DEX Integration](#real-dex-integration)\n- [Getting Started](#getting-started)\n- [Pattern Categories](#pattern-categories)\n  - [AI Trading Agents](#ai-trading-agents)\n  - [DAO Treasury Management](#dao-treasury-management)\n  - [DeFi Protocols](#defi-protocols)\n- [Base Pattern API](#base-pattern-api)\n- [Pattern Registry](#pattern-registry)\n- [Best Practices](#best-practices)\n\n## Overview\n\nThe Fabriquant Pattern Library provides ready-to-use execution templates that combine multiple SDK components (Loom, Guard, FabricCore, Pulsar) to solve common DeFi challenges. Each pattern includes:\n\n- **Pre-configured security**: Integrated Guard validation\n- **Optimized execution**: Loom-powered transaction routing\n- **Retry logic**: Automatic retry with exponential backoff\n- **Metrics tracking**: Built-in performance monitoring\n- **Dry-run mode**: Test without executing on-chain\n\n## Real DEX Integration\n\nThe Pattern Library now supports real-time DEX integration via Jupiter V6 aggregator, enabling production-ready trading with live price feeds and optimal routing.\n\n### Key Features\n\n- **Jupiter V6 Integration**: Real-time quotes, prices, and routes from Solana's leading DEX aggregator\n- **Price Feed Service**: Multi-source price aggregation with caching and subscriptions\n- **Flexible Architecture**: Swappable DEX adapters (Jupiter, Orca, Raydium, custom)\n- **Backward Compatible**: Opt-in via `enableRealDEX` flag - existing code works unchanged\n\n### Quick Start\n\n```typescript\nimport {\n  ArbitragePattern,\n  PriceFeedService,\n  COMMON_TOKENS,\n  Guard\n} from '@fabriquant/sdk';\n\n// 1. Get real-time prices\nconst priceFeed = new PriceFeedService();\nconst solPrice = await priceFeed.getPrice(COMMON_TOKENS.SOL, COMMON_TOKENS.USDC);\nconsole.log(`SOL: $${solPrice}`);\n\n// 2. Use real DEX in patterns\nconst arbitrage = new ArbitragePattern({\n  name: 'Live Arbitrage',\n  pairs: [{\n    base: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n    quote: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n  }],\n  dexs: [\n    { name: 'Orca', programId: 'whirL...', feeTier: 0.003 },\n    { name: 'Raydium', programId: 'Rayd...', feeTier: 0.0025 },\n  ],\n  minProfitPercent: 0.5,\n  tradeAmount: 1000,\n  maxSlippage: 0.01,\n  enableRealDEX: true,  // ✨ Enable live prices from Jupiter\n  guard: new Guard({ mode: 'block' }),\n});\n\nconst result = await arbitrage.execute();\n```\n\n### Available Tokens\n\n```typescript\nimport { COMMON_TOKENS } from '@fabriquant/sdk';\n\n// Common Solana tokens with mint addresses\nCOMMON_TOKENS.SOL    // Wrapped SOL\nCOMMON_TOKENS.USDC   // USD Coin\nCOMMON_TOKENS.USDT   // Tether USD\nCOMMON_TOKENS.RAY    // Raydium\nCOMMON_TOKENS.SRM    // Serum\nCOMMON_TOKENS.MNGO   // Mango\nCOMMON_TOKENS.ORCA   // Orca\n```\n\n### Patterns Supporting Real DEX\n\n- **ArbitragePattern**: Live multi-DEX price comparison\n- **SwapPattern**: Optimal route fetching and execution\n\nMore patterns coming soon!\n\n## Getting Started\n\n### Installation\n\n```typescript\nimport {\n  GridTradingPattern,\n  SwapPattern,\n  TreasuryRebalancing,\n  Guard,\n  JupiterAdapter,        // ✨ For DEX integration\n  PriceFeedService,      // ✨ For price feeds\n  COMMON_TOKENS,         // ✨ For token mints\n} from '@fabriquant/sdk';\n```\n\n### Basic Usage\n\nAll patterns follow the same execution model:\n\n```typescript\n// 1. Create pattern with configuration\nconst pattern = new GridTradingPattern({\n  name: 'My Trading Strategy',\n  // ... pattern-specific config\n  guard: new Guard({ mode: 'block', maxSlippage: 0.02 }),\n  dryRun: false, // Set to true to test without executing\n});\n\n// 2. Execute pattern\nconst result = await pattern.execute();\n\n// 3. Check results\nif (result.success) {\n  console.log(`Executed ${result.transactions.length} transactions`);\n  console.log(`Duration: ${result.metrics.totalDuration}ms`);\n} else {\n  console.error('Pattern failed:', result.error);\n}\n```\n\n## Pattern Categories\n\n### AI Trading Agents\n\nAutomated trading strategies for AI agents and bots.\n\n#### Grid Trading Pattern\n\nProfit from market volatility by placing buy and sell orders at predefined price levels.\n\n**When to use:**\n- Markets with predictable volatility\n- Range-bound trading\n- Market making strategies\n\n**Example:**\n\n```typescript\nimport { GridTradingPattern, Guard } from '@fabriquant/sdk';\n\nconst pattern = new GridTradingPattern({\n  name: 'SOL-USDC Grid',\n  pair: {\n    base: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n    quote: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n  },\n  lowerBound: 90,      // Buy below $90\n  upperBound: 110,     // Sell above $110\n  gridLevels: 10,      // 10 price levels\n  amountPerGrid: 1,    // 1 SOL per level\n  currentPrice: {\n    token: 'SOL',\n    price: 100,\n    quoteCurrency: 'USDC',\n    timestamp: Date.now(),\n  },\n  guard: new Guard({ mode: 'block', maxSlippage: 0.02 }),\n});\n\nconst result = await pattern.execute();\n```\n\n**Configuration:**\n\n```typescript\ninterface GridTradingConfig {\n  name: string;\n  pair: TradingPair;\n  lowerBound: number;        // Minimum price\n  upperBound: number;        // Maximum price\n  gridLevels: number;        // Number of grid levels\n  amountPerGrid: number;     // Amount per level\n  currentPrice: Price;       // Current market price\n  guard?: Guard;             // Security validation\n  dryRun?: boolean;          // Test mode\n}\n```\n\n#### Dollar Cost Averaging (DCA)\n\nReduce volatility impact by purchasing fixed amounts at regular intervals.\n\n**When to use:**\n- Long-term accumulation strategies\n- Automated recurring buys\n- Reducing timing risk\n\n**Example:**\n\n```typescript\nimport { DCAStrategy, Guard } from '@fabriquant/sdk';\n\nconst pattern = new DCAStrategy({\n  name: 'Weekly SOL Purchase',\n  buyToken: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n  payToken: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n  amountPerInterval: 100,           // $100 per purchase\n  intervalDuration: 7 * 24 * 60 * 60 * 1000, // Weekly\n  totalIntervals: 52,               // 1 year\n  autoExecute: true,                // Run automatically\n  currentPrice: {\n    token: 'SOL',\n    price: 100,\n    quoteCurrency: 'USDC',\n    timestamp: Date.now(),\n  },\n  guard: new Guard({ mode: 'block', maxSlippage: 0.03 }),\n});\n\n// Start automated execution\nawait pattern.execute();\n\n// Control execution\npattern.pause();   // Pause strategy\npattern.resume();  // Resume strategy\npattern.stop();    // Stop completely\n```\n\n**Configuration:**\n\n```typescript\ninterface DCAConfig {\n  name: string;\n  buyToken: Token;\n  payToken: Token;\n  amountPerInterval: number;    // Amount per purchase\n  intervalDuration: number;     // Time between purchases (ms)\n  totalIntervals: number;       // Total number of purchases\n  autoExecute?: boolean;        // Auto-schedule intervals\n  currentPrice: Price;\n  guard?: Guard;\n  dryRun?: boolean;\n}\n```\n\n#### Arbitrage Pattern\n\nCapture price differences across multiple DEXs with parallel execution. Supports both simulated (testing) and real DEX integration (production) via Jupiter.\n\n**When to use:**\n- Price discrepancies between DEXs\n- High-frequency trading opportunities\n- MEV extraction\n\n**Example (with Real DEX Integration):**\n\n```typescript\nimport { ArbitragePattern, Guard, COMMON_TOKENS } from '@fabriquant/sdk';\n\nconst pattern = new ArbitragePattern({\n  name: 'Multi-DEX Arbitrage',\n  pairs: [\n    {\n      base: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n      quote: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n    },\n  ],\n  dexs: [\n    { name: 'Orca', programId: 'whirL...', feeTier: 0.003 },\n    { name: 'Raydium', programId: 'Rayd...', feeTier: 0.0025 },\n  ],\n  minProfitPercent: 0.5,        // 0.5% minimum profit\n  tradeAmount: 1000,            // $1k per trade\n  maxSlippage: 0.01,\n  scanInterval: 5000,           // Scan every 5 seconds\n  enableRealDEX: true,          // ✨ Enable live price feeds from Jupiter\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nconst result = await pattern.execute();\nconsole.log(`Found ${result.metadata.opportunitiesFound} opportunities`);\nconsole.log(`Total profit: $${result.metadata.totalProfit}`);\n```\n\n**Example (with Custom DEX Adapter):**\n\n```typescript\nimport { ArbitragePattern, JupiterAdapter } from '@fabriquant/sdk';\n\n// Use custom adapter configuration\nconst customAdapter = new JupiterAdapter({\n  cacheTTL: 10000,  // 10 second cache\n  timeout: 5000,    // 5 second timeout\n});\n\nconst pattern = new ArbitragePattern({\n  name: 'Custom Arbitrage',\n  // ... config\n  enableRealDEX: true,\n  dexAdapter: customAdapter,  // ✨ Use custom adapter\n});\n```\n\n**Configuration:**\n\n```typescript\ninterface ArbitrageConfig {\n  name: string;\n  pairs: TradingPair[];\n  dexs: DEX[];\n  minProfitPercent: number;     // Minimum profit threshold\n  tradeAmount: number;          // Amount to trade per arbitrage\n  maxSlippage: number;          // Maximum slippage tolerance\n  scanInterval?: number;        // Scan frequency (ms)\n  autoExecute?: boolean;        // Execute opportunities automatically\n  enableRealDEX?: boolean;      // ✨ Enable real DEX integration (default: false)\n  dexAdapter?: DEXAdapter;      // ✨ Custom DEX adapter (overrides default Jupiter)\n  guard?: Guard;\n  dryRun?: boolean;\n}\n```\n\n### DAO Treasury Management\n\nAutomated portfolio management for DAO treasuries.\n\n#### Treasury Rebalancing\n\nMaintain target asset allocations automatically by rebalancing when deviations exceed threshold.\n\n**When to use:**\n- Multi-asset treasury management\n- Maintaining risk profiles\n- Automated portfolio rebalancing\n\n**Example:**\n\n```typescript\nimport { TreasuryRebalancing, Guard } from '@fabriquant/sdk';\n\nconst pattern = new TreasuryRebalancing({\n  name: 'DAO Treasury Rebalance',\n  totalValue: 1000000,  // $1M treasury\n  allocations: [\n    {\n      token: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n      targetPercent: 40,\n      currentValue: 350000,  // Currently at $350k (35%)\n    },\n    {\n      token: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n      targetPercent: 40,\n      currentValue: 450000,  // Currently at $450k (45%)\n    },\n    {\n      token: { mint: 'mSo...', symbol: 'mSOL', decimals: 9 },\n      targetPercent: 20,\n      currentValue: 200000,  // Currently at $200k (20%)\n    },\n  ],\n  threshold: 5,                  // Rebalance if >5% deviation\n  maxSlippage: 0.02,\n  baseCurrency: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n  guard: new Guard({ mode: 'block', maxSlippage: 0.02 }),\n});\n\n// Check if rebalancing is needed\nif (pattern.needsRebalancing()) {\n  const result = await pattern.execute();\n  console.log(`Executed ${result.metadata.actionsExecuted} rebalancing trades`);\n}\n```\n\n**Configuration:**\n\n```typescript\ninterface RebalancingConfig {\n  name: string;\n  totalValue: number;           // Total treasury value (USD)\n  allocations: AssetAllocation[];\n  threshold: number;            // Deviation threshold (%)\n  minTradeSize?: number;        // Minimum trade size (USD)\n  maxSlippage: number;\n  baseCurrency: Token;\n  guard?: Guard;\n  dryRun?: boolean;\n}\n\ninterface AssetAllocation {\n  token: Token;\n  targetPercent: number;        // Target allocation (0-100)\n  currentValue: number;         // Current value (USD)\n}\n```\n\n#### Yield Farming Pattern\n\nOptimize yields across multiple protocols with automated allocation strategies.\n\n**When to use:**\n- Maximizing treasury returns\n- Multi-protocol yield optimization\n- Automated yield farming\n\n**Example:**\n\n```typescript\nimport { YieldFarmingPattern, Guard } from '@fabriquant/sdk';\n\nconst pattern = new YieldFarmingPattern({\n  name: 'Treasury Yield Optimization',\n  farmAmount: 500000,  // $500k to farm\n  farmToken: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n  protocols: [\n    {\n      name: 'Solend',\n      programId: 'SoLE...',\n      apy: 8.5,\n      token: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n    },\n    {\n      name: 'Marinade',\n      programId: 'Mari...',\n      apy: 6.8,\n      token: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n    },\n    {\n      name: 'Orca',\n      programId: 'Orca...',\n      apy: 12.3,\n      token: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n    },\n  ],\n  strategy: 'diversified',       // 'highest-apy' | 'diversified' | 'conservative'\n  autoCompound: true,\n  compoundFrequency: 7 * 24 * 60 * 60 * 1000, // Weekly\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nconst result = await pattern.execute();\nconst summary = pattern.getAllocationSummary();\nconsole.log('Allocations:', summary);\n```\n\n**Strategies:**\n\n- **highest-apy**: Allocate 100% to highest yield protocol\n- **diversified**: Split across top 3 protocols (50%, 30%, 20%)\n- **conservative**: Equal weight across all protocols\n\n**Configuration:**\n\n```typescript\ninterface YieldFarmingConfig {\n  name: string;\n  farmAmount: number;\n  farmToken: Token;\n  protocols: YieldProtocol[];\n  strategy: 'highest-apy' | 'diversified' | 'conservative';\n  autoCompound?: boolean;\n  compoundFrequency?: number;   // Compound interval (ms)\n  guard?: Guard;\n  dryRun?: boolean;\n}\n\ninterface YieldProtocol {\n  name: string;\n  programId: string;\n  apy: number;                  // Current APY (%)\n  token: Token;\n  minDeposit?: number;\n  maxDeposit?: number;\n  lockPeriod?: number;          // Lock duration (seconds)\n}\n```\n\n### DeFi Protocols\n\nLow-level DeFi operations with intelligent optimization.\n\n#### Swap Pattern\n\nMulti-route swap optimization with price impact minimization and intelligent order splitting. Supports real-time route optimization via Jupiter aggregator.\n\n**When to use:**\n- Large swaps that impact price\n- Multi-DEX routing\n- Optimized trade execution\n\n**Example (with Real DEX Integration):**\n\n```typescript\nimport { SwapPattern, Guard, COMMON_TOKENS } from '@fabriquant/sdk';\n\nconst pattern = new SwapPattern({\n  name: 'Optimized SOL Swap',\n  fromToken: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n  toToken: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n  amount: 100,\n  currentPrice: {\n    token: 'SOL',\n    price: 100,\n    quoteCurrency: 'USDC',\n    timestamp: Date.now(),\n  },\n  maxPriceImpact: 0.5,\n  enableSplitOrders: true,\n  enableRealDEX: true,          // ✨ Fetch optimal routes from Jupiter\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nconst result = await pattern.execute();\nconst summary = pattern.getSummary();\nconsole.log('Routes used:', summary.routes.length);\nconsole.log('Total price impact:', summary.totalPriceImpact);\nconsole.log('Average price:', summary.averagePrice);\n```\n\n**Example (with Manual Routes - Testing Mode):**\n\n```typescript\nconst pattern = new SwapPattern({\n  name: 'Manual Route Swap',\n  fromToken: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n  toToken: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n  amount: 100,\n  currentPrice: {\n    token: 'SOL',\n    price: 100,\n    quoteCurrency: 'USDC',\n    timestamp: Date.now(),\n  },\n  routes: [  // Manual routes for testing\n    {\n      dex: 'Orca',\n      programId: 'Orca...',\n      price: 100.5,\n      liquidity: 500000,\n      priceImpact: 0.15,\n      fee: 0.003,\n    },\n    {\n      dex: 'Raydium',\n      programId: 'Rayd...',\n      price: 100.2,\n      liquidity: 300000,\n      priceImpact: 0.25,\n      fee: 0.0025,\n    },\n  ],\n  maxPriceImpact: 0.5,\n  enableSplitOrders: true,\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n```\n\n**Configuration:**\n\n```typescript\ninterface SwapConfig {\n  name: string;\n  fromToken: Token;\n  toToken: Token;\n  amount: number;\n  currentPrice: Price;\n  routes?: SwapRoute[];          // ✨ Optional if using enableRealDEX\n  maxPriceImpact: number;        // Max allowed price impact (%)\n  enableSplitOrders?: boolean;   // Split across routes\n  minRouteAllocation?: number;   // Min allocation per route (%)\n  enableRealDEX?: boolean;       // ✨ Enable real DEX integration (default: false)\n  dexAdapter?: DEXAdapter;       // ✨ Custom DEX adapter (overrides default Jupiter)\n  guard?: Guard;\n  dryRun?: boolean;\n}\n\ninterface SwapRoute {\n  dex: string;\n  programId: string;\n  price: number;\n  liquidity: number;\n  priceImpact: number;          // Estimated impact (%)\n  fee: number;                  // Fee percentage\n}\n```\n\n#### Liquidity Pattern\n\nAutomated liquidity provision with position management and impermanent loss monitoring.\n\n**When to use:**\n- Adding/removing liquidity\n- LP position management\n- Impermanent loss tracking\n\n**Example:**\n\n```typescript\nimport { LiquidityPattern, Guard } from '@fabriquant/sdk';\n\n// Add liquidity\nconst addPattern = new LiquidityPattern({\n  name: 'Add SOL-USDC Liquidity',\n  action: 'add',\n  pool: {\n    name: 'Orca SOL-USDC',\n    programId: 'Orca...',\n    tokenA: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n    tokenB: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n    apy: 12.5,\n    feeTier: 0.003,\n    totalLiquidity: 5000000,\n    priceRatio: 100,\n  },\n  amountA: 10,    // 10 SOL\n  amountB: 1000,  // 1000 USDC\n  prices: {\n    tokenA: { token: 'SOL', price: 100, quoteCurrency: 'USDC', timestamp: Date.now() },\n    tokenB: { token: 'USDC', price: 1, quoteCurrency: 'USD', timestamp: Date.now() },\n  },\n  monitorImpermanentLoss: true,\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nconst result = await addPattern.execute();\n\n// Monitor position\nconst position = addPattern.getPositionSummary();\nconsole.log('Impermanent loss:', position?.impermanentLoss);\n\n// Remove liquidity\nconst removePattern = new LiquidityPattern({\n  name: 'Remove Liquidity',\n  action: 'remove',\n  pool: /* same pool */,\n  removePercentage: 50,  // Remove 50%\n  prices: { /* current prices */ },\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nawait removePattern.execute();\n```\n\n**Configuration:**\n\n```typescript\ninterface LiquidityConfig {\n  name: string;\n  action: 'add' | 'remove' | 'rebalance';\n  pool: LiquidityPool;\n  amountA?: number;             // For 'add'\n  amountB?: number;             // For 'add'\n  removePercentage?: number;    // For 'remove' (0-100)\n  prices: {\n    tokenA: Price;\n    tokenB: Price;\n  };\n  monitorImpermanentLoss?: boolean;\n  rebalanceThreshold?: number;  // Auto-rebalance at IL% threshold\n  guard?: Guard;\n  dryRun?: boolean;\n}\n\ninterface LiquidityPool {\n  name: string;\n  programId: string;\n  tokenA: Token;\n  tokenB: Token;\n  apy: number;\n  feeTier: number;\n  totalLiquidity: number;\n  priceRatio: number;\n}\n```\n\n## Base Pattern API\n\nAll patterns extend the `ExecutionPattern` base class:\n\n```typescript\nabstract class ExecutionPattern {\n  // Execute the pattern\n  abstract execute(): Promise<PatternResult>;\n\n  // Validate configuration (override in subclass)\n  protected abstract validate(): boolean;\n\n  // Execute with automatic retry on failure\n  protected async executeWithRetry<T>(\n    fn: () => Promise<T>,\n    maxRetries?: number\n  ): Promise<T>;\n}\n```\n\n### Pattern Result\n\n```typescript\ninterface PatternResult {\n  success: boolean;\n  transactions: Transaction[];\n  metrics: PatternMetrics;\n  error?: Error;\n  metadata?: Record<string, unknown>;\n}\n\ninterface PatternMetrics {\n  executionTime: number;        // Total duration (ms)\n  gasUsed?: number;             // Total gas consumed\n  successRate: number;          // Success rate (0-1)\n  retryCount: number;           // Number of retries\n  transactionCount: number;     // Total transactions\n}\n```\n\n## Pattern Registry\n\nRegister and retrieve custom patterns:\n\n```typescript\nimport { PatternRegistry, ExecutionPattern } from '@fabriquant/sdk';\n\n// Register custom pattern\nclass MyCustomPattern extends ExecutionPattern {\n  async execute() {\n    // Implementation\n  }\n\n  protected validate() {\n    // Validation\n  }\n}\n\nPatternRegistry.register('my-custom-pattern', MyCustomPattern);\n\n// Retrieve pattern\nconst PatternClass = PatternRegistry.get('my-custom-pattern');\nif (PatternClass) {\n  const pattern = new PatternClass(config);\n  await pattern.execute();\n}\n```\n\n## Best Practices\n\n### 1. Always Use Guard\n\n```typescript\nconst guard = new Guard({\n  mode: 'block',\n  maxSlippage: 0.02,\n  riskTolerance: 'moderate',\n});\n\nconst pattern = new GridTradingPattern({\n  // ... config\n  guard,  // ✅ Always include Guard\n});\n```\n\n### 2. Test with Dry Run\n\n```typescript\n// Test without executing\nconst pattern = new SwapPattern({\n  // ... config\n  dryRun: true,  // ✅ Test first\n});\n\nconst result = await pattern.execute();\nif (result.success) {\n  // Now run for real\n  pattern.config.dryRun = false;\n  await pattern.execute();\n}\n```\n\n### 3. Monitor Metrics\n\n```typescript\nconst result = await pattern.execute();\n\nconsole.log('Performance:', {\n  duration: result.metrics.executionTime,\n  gasUsed: result.metrics.gasUsed,\n  successRate: result.metrics.successRate,\n  retries: result.metrics.retryCount,\n});\n```\n\n### 4. Handle Errors\n\n```typescript\nconst result = await pattern.execute();\n\nif (!result.success) {\n  console.error('Pattern failed:', result.error);\n\n  // Analyze failure\n  if (result.error?.message.includes('slippage')) {\n    // Increase slippage tolerance\n  }\n}\n```\n\n### 5. Use Pattern-Specific Methods\n\n```typescript\n// Grid Trading\nconst gridPattern = new GridTradingPattern(config);\nconst levels = gridPattern.getGridLevels();  // Get all grid levels\n\n// Treasury Rebalancing\nconst rebalancePattern = new TreasuryRebalancing(config);\nif (rebalancePattern.needsRebalancing()) {\n  await rebalancePattern.execute();\n}\n\n// Swap\nconst swapPattern = new SwapPattern(config);\nconst summary = swapPattern.getSummary();  // Get execution summary\n```\n\n### 6. Keep Configurations Immutable\n\n```typescript\n// ❌ Don't modify config after creation\npattern.config.amount = 200;\n\n// ✅ Create new pattern instance\nconst newPattern = new SwapPattern({\n  ...config,\n  amount: 200,\n});\n```\n\n### 7. Combine with Privacy\n\n```typescript\nimport { FabricCore } from '@fabriquant/sdk';\n\nconst pattern = new GridTradingPattern(config);\nconst result = await pattern.execute();\n\n// Add privacy to transactions\nfor (const tx of result.transactions) {\n  const optimized = FabricCore.optimize(tx, {\n    enablePrivacy: true,\n    privacyProvider: 'arbor',\n  });\n}\n```\n\n## Additional Resources\n\n- [Main README](../README.md)\n- [API Documentation](./API.md)\n- [Examples](../examples/patterns/)\n- [Business Plan](../BUSINESS_PLAN.md)\n\n## Support\n\nFor questions or issues:\n- GitHub Issues: [fabriquant/issues](https://github.com/your-org/fabriquant/issues)\n- Documentation: [docs.fabriquant.dev](https://docs.fabriquant.dev)\n",
      "sections": [
        {
          "heading": "# Fabriquant Pattern Library",
          "body": "Pre-built execution patterns for common DeFi and AI agent use cases on Solana."
        },
        {
          "heading": "Table of Contents",
          "body": "- [Overview](#overview)\n- [Real DEX Integration](#real-dex-integration)\n- [Getting Started](#getting-started)\n- [Pattern Categories](#pattern-categories)\n  - [AI Trading Agents](#ai-trading-agents)\n  - [DAO Treasury Management](#dao-treasury-management)\n  - [DeFi Protocols](#defi-protocols)\n- [Base Pattern API](#base-pattern-api)\n- [Pattern Registry](#pattern-registry)\n- [Best Practices](#best-practices)"
        },
        {
          "heading": "Overview",
          "body": "The Fabriquant Pattern Library provides ready-to-use execution templates that combine multiple SDK components (Loom, Guard, FabricCore, Pulsar) to solve common DeFi challenges. Each pattern includes:\n\n- **Pre-configured security**: Integrated Guard validation\n- **Optimized execution**: Loom-powered transaction routing\n- **Retry logic**: Automatic retry with exponential backoff\n- **Metrics tracking**: Built-in performance monitoring\n- **Dry-run mode**: Test without executing on-chain"
        },
        {
          "heading": "Real DEX Integration",
          "body": "The Pattern Library now supports real-time DEX integration via Jupiter V6 aggregator, enabling production-ready trading with live price feeds and optimal routing.\n\n### Key Features\n\n- **Jupiter V6 Integration**: Real-time quotes, prices, and routes from Solana's leading DEX aggregator\n- **Price Feed Service**: Multi-source price aggregation with caching and subscriptions\n- **Flexible Architecture**: Swappable DEX adapters (Jupiter, Orca, Raydium, custom)\n- **Backward Compatible**: Opt-in via `enableRealDEX` flag - existing code works unchanged\n\n### Quick Start\n\n```typescript\nimport {\n  ArbitragePattern,\n  PriceFeedService,\n  COMMON_TOKENS,\n  Guard\n} from '@fabriquant/sdk';\n\n// 1. Get real-time prices\nconst priceFeed = new PriceFeedService();\nconst solPrice = await priceFeed.getPrice(COMMON_TOKENS.SOL, COMMON_TOKENS.USDC);\nconsole.log(`SOL: $${solPrice}`);\n\n// 2. Use real DEX in patterns\nconst arbitrage = new ArbitragePattern({\n  name: 'Live Arbitrage',\n  pairs: [{\n    base: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n    quote: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n  }],\n  dexs: [\n    { name: 'Orca', programId: 'whirL...', feeTier: 0.003 },\n    { name: 'Raydium', programId: 'Rayd...', feeTier: 0.0025 },\n  ],\n  minProfitPercent: 0.5,\n  tradeAmount: 1000,\n  maxSlippage: 0.01,\n  enableRealDEX: true,  // ✨ Enable live prices from Jupiter\n  guard: new Guard({ mode: 'block' }),\n});\n\nconst result = await arbitrage.execute();\n```\n\n### Available Tokens\n\n```typescript\nimport { COMMON_TOKENS } from '@fabriquant/sdk';\n\n// Common Solana tokens with mint addresses\nCOMMON_TOKENS.SOL    // Wrapped SOL\nCOMMON_TOKENS.USDC   // USD Coin\nCOMMON_TOKENS.USDT   // Tether USD\nCOMMON_TOKENS.RAY    // Raydium\nCOMMON_TOKENS.SRM    // Serum\nCOMMON_TOKENS.MNGO   // Mango\nCOMMON_TOKENS.ORCA   // Orca\n```\n\n### Patterns Supporting Real DEX\n\n- **ArbitragePattern**: Live multi-DEX price comparison\n- **SwapPattern**: Optimal route fetching and execution\n\nMore patterns coming soon!"
        },
        {
          "heading": "Getting Started",
          "body": "### Installation\n\n```typescript\nimport {\n  GridTradingPattern,\n  SwapPattern,\n  TreasuryRebalancing,\n  Guard,\n  JupiterAdapter,        // ✨ For DEX integration\n  PriceFeedService,      // ✨ For price feeds\n  COMMON_TOKENS,         // ✨ For token mints\n} from '@fabriquant/sdk';\n```\n\n### Basic Usage\n\nAll patterns follow the same execution model:\n\n```typescript\n// 1. Create pattern with configuration\nconst pattern = new GridTradingPattern({\n  name: 'My Trading Strategy',\n  // ... pattern-specific config\n  guard: new Guard({ mode: 'block', maxSlippage: 0.02 }),\n  dryRun: false, // Set to true to test without executing\n});\n\n// 2. Execute pattern\nconst result = await pattern.execute();\n\n// 3. Check results\nif (result.success) {\n  console.log(`Executed ${result.transactions.length} transactions`);\n  console.log(`Duration: ${result.metrics.totalDuration}ms`);\n} else {\n  console.error('Pattern failed:', result.error);\n}\n```"
        },
        {
          "heading": "Pattern Categories",
          "body": "### AI Trading Agents\n\nAutomated trading strategies for AI agents and bots.\n\n#### Grid Trading Pattern\n\nProfit from market volatility by placing buy and sell orders at predefined price levels.\n\n**When to use:**\n- Markets with predictable volatility\n- Range-bound trading\n- Market making strategies\n\n**Example:**\n\n```typescript\nimport { GridTradingPattern, Guard } from '@fabriquant/sdk';\n\nconst pattern = new GridTradingPattern({\n  name: 'SOL-USDC Grid',\n  pair: {\n    base: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n    quote: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n  },\n  lowerBound: 90,      // Buy below $90\n  upperBound: 110,     // Sell above $110\n  gridLevels: 10,      // 10 price levels\n  amountPerGrid: 1,    // 1 SOL per level\n  currentPrice: {\n    token: 'SOL',\n    price: 100,\n    quoteCurrency: 'USDC',\n    timestamp: Date.now(),\n  },\n  guard: new Guard({ mode: 'block', maxSlippage: 0.02 }),\n});\n\nconst result = await pattern.execute();\n```\n\n**Configuration:**\n\n```typescript\ninterface GridTradingConfig {\n  name: string;\n  pair: TradingPair;\n  lowerBound: number;        // Minimum price\n  upperBound: number;        // Maximum price\n  gridLevels: number;        // Number of grid levels\n  amountPerGrid: number;     // Amount per level\n  currentPrice: Price;       // Current market price\n  guard?: Guard;             // Security validation\n  dryRun?: boolean;          // Test mode\n}\n```\n\n#### Dollar Cost Averaging (DCA)\n\nReduce volatility impact by purchasing fixed amounts at regular intervals.\n\n**When to use:**\n- Long-term accumulation strategies\n- Automated recurring buys\n- Reducing timing risk\n\n**Example:**\n\n```typescript\nimport { DCAStrategy, Guard } from '@fabriquant/sdk';\n\nconst pattern = new DCAStrategy({\n  name: 'Weekly SOL Purchase',\n  buyToken: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n  payToken: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n  amountPerInterval: 100,           // $100 per purchase\n  intervalDuration: 7 * 24 * 60 * 60 * 1000, // Weekly\n  totalIntervals: 52,               // 1 year\n  autoExecute: true,                // Run automatically\n  currentPrice: {\n    token: 'SOL',\n    price: 100,\n    quoteCurrency: 'USDC',\n    timestamp: Date.now(),\n  },\n  guard: new Guard({ mode: 'block', maxSlippage: 0.03 }),\n});\n\n// Start automated execution\nawait pattern.execute();\n\n// Control execution\npattern.pause();   // Pause strategy\npattern.resume();  // Resume strategy\npattern.stop();    // Stop completely\n```\n\n**Configuration:**\n\n```typescript\ninterface DCAConfig {\n  name: string;\n  buyToken: Token;\n  payToken: Token;\n  amountPerInterval: number;    // Amount per purchase\n  intervalDuration: number;     // Time between purchases (ms)\n  totalIntervals: number;       // Total number of purchases\n  autoExecute?: boolean;        // Auto-schedule intervals\n  currentPrice: Price;\n  guard?: Guard;\n  dryRun?: boolean;\n}\n```\n\n#### Arbitrage Pattern\n\nCapture price differences across multiple DEXs with parallel execution. Supports both simulated (testing) and real DEX integration (production) via Jupiter.\n\n**When to use:**\n- Price discrepancies between DEXs\n- High-frequency trading opportunities\n- MEV extraction\n\n**Example (with Real DEX Integration):**\n\n```typescript\nimport { ArbitragePattern, Guard, COMMON_TOKENS } from '@fabriquant/sdk';\n\nconst pattern = new ArbitragePattern({\n  name: 'Multi-DEX Arbitrage',\n  pairs: [\n    {\n      base: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n      quote: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n    },\n  ],\n  dexs: [\n    { name: 'Orca', programId: 'whirL...', feeTier: 0.003 },\n    { name: 'Raydium', programId: 'Rayd...', feeTier: 0.0025 },\n  ],\n  minProfitPercent: 0.5,        // 0.5% minimum profit\n  tradeAmount: 1000,            // $1k per trade\n  maxSlippage: 0.01,\n  scanInterval: 5000,           // Scan every 5 seconds\n  enableRealDEX: true,          // ✨ Enable live price feeds from Jupiter\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nconst result = await pattern.execute();\nconsole.log(`Found ${result.metadata.opportunitiesFound} opportunities`);\nconsole.log(`Total profit: $${result.metadata.totalProfit}`);\n```\n\n**Example (with Custom DEX Adapter):**\n\n```typescript\nimport { ArbitragePattern, JupiterAdapter } from '@fabriquant/sdk';\n\n// Use custom adapter configuration\nconst customAdapter = new JupiterAdapter({\n  cacheTTL: 10000,  // 10 second cache\n  timeout: 5000,    // 5 second timeout\n});\n\nconst pattern = new ArbitragePattern({\n  name: 'Custom Arbitrage',\n  // ... config\n  enableRealDEX: true,\n  dexAdapter: customAdapter,  // ✨ Use custom adapter\n});\n```\n\n**Configuration:**\n\n```typescript\ninterface ArbitrageConfig {\n  name: string;\n  pairs: TradingPair[];\n  dexs: DEX[];\n  minProfitPercent: number;     // Minimum profit threshold\n  tradeAmount: number;          // Amount to trade per arbitrage\n  maxSlippage: number;          // Maximum slippage tolerance\n  scanInterval?: number;        // Scan frequency (ms)\n  autoExecute?: boolean;        // Execute opportunities automatically\n  enableRealDEX?: boolean;      // ✨ Enable real DEX integration (default: false)\n  dexAdapter?: DEXAdapter;      // ✨ Custom DEX adapter (overrides default Jupiter)\n  guard?: Guard;\n  dryRun?: boolean;\n}\n```\n\n### DAO Treasury Management\n\nAutomated portfolio management for DAO treasuries.\n\n#### Treasury Rebalancing\n\nMaintain target asset allocations automatically by rebalancing when deviations exceed threshold.\n\n**When to use:**\n- Multi-asset treasury management\n- Maintaining risk profiles\n- Automated portfolio rebalancing\n\n**Example:**\n\n```typescript\nimport { TreasuryRebalancing, Guard } from '@fabriquant/sdk';\n\nconst pattern = new TreasuryRebalancing({\n  name: 'DAO Treasury Rebalance',\n  totalValue: 1000000,  // $1M treasury\n  allocations: [\n    {\n      token: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n      targetPercent: 40,\n      currentValue: 350000,  // Currently at $350k (35%)\n    },\n    {\n      token: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n      targetPercent: 40,\n      currentValue: 450000,  // Currently at $450k (45%)\n    },\n    {\n      token: { mint: 'mSo...', symbol: 'mSOL', decimals: 9 },\n      targetPercent: 20,\n      currentValue: 200000,  // Currently at $200k (20%)\n    },\n  ],\n  threshold: 5,                  // Rebalance if >5% deviation\n  maxSlippage: 0.02,\n  baseCurrency: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n  guard: new Guard({ mode: 'block', maxSlippage: 0.02 }),\n});\n\n// Check if rebalancing is needed\nif (pattern.needsRebalancing()) {\n  const result = await pattern.execute();\n  console.log(`Executed ${result.metadata.actionsExecuted} rebalancing trades`);\n}\n```\n\n**Configuration:**\n\n```typescript\ninterface RebalancingConfig {\n  name: string;\n  totalValue: number;           // Total treasury value (USD)\n  allocations: AssetAllocation[];\n  threshold: number;            // Deviation threshold (%)\n  minTradeSize?: number;        // Minimum trade size (USD)\n  maxSlippage: number;\n  baseCurrency: Token;\n  guard?: Guard;\n  dryRun?: boolean;\n}\n\ninterface AssetAllocation {\n  token: Token;\n  targetPercent: number;        // Target allocation (0-100)\n  currentValue: number;         // Current value (USD)\n}\n```\n\n#### Yield Farming Pattern\n\nOptimize yields across multiple protocols with automated allocation strategies.\n\n**When to use:**\n- Maximizing treasury returns\n- Multi-protocol yield optimization\n- Automated yield farming\n\n**Example:**\n\n```typescript\nimport { YieldFarmingPattern, Guard } from '@fabriquant/sdk';\n\nconst pattern = new YieldFarmingPattern({\n  name: 'Treasury Yield Optimization',\n  farmAmount: 500000,  // $500k to farm\n  farmToken: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n  protocols: [\n    {\n      name: 'Solend',\n      programId: 'SoLE...',\n      apy: 8.5,\n      token: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n    },\n    {\n      name: 'Marinade',\n      programId: 'Mari...',\n      apy: 6.8,\n      token: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n    },\n    {\n      name: 'Orca',\n      programId: 'Orca...',\n      apy: 12.3,\n      token: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n    },\n  ],\n  strategy: 'diversified',       // 'highest-apy' | 'diversified' | 'conservative'\n  autoCompound: true,\n  compoundFrequency: 7 * 24 * 60 * 60 * 1000, // Weekly\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nconst result = await pattern.execute();\nconst summary = pattern.getAllocationSummary();\nconsole.log('Allocations:', summary);\n```\n\n**Strategies:**\n\n- **highest-apy**: Allocate 100% to highest yield protocol\n- **diversified**: Split across top 3 protocols (50%, 30%, 20%)\n- **conservative**: Equal weight across all protocols\n\n**Configuration:**\n\n```typescript\ninterface YieldFarmingConfig {\n  name: string;\n  farmAmount: number;\n  farmToken: Token;\n  protocols: YieldProtocol[];\n  strategy: 'highest-apy' | 'diversified' | 'conservative';\n  autoCompound?: boolean;\n  compoundFrequency?: number;   // Compound interval (ms)\n  guard?: Guard;\n  dryRun?: boolean;\n}\n\ninterface YieldProtocol {\n  name: string;\n  programId: string;\n  apy: number;                  // Current APY (%)\n  token: Token;\n  minDeposit?: number;\n  maxDeposit?: number;\n  lockPeriod?: number;          // Lock duration (seconds)\n}\n```\n\n### DeFi Protocols\n\nLow-level DeFi operations with intelligent optimization.\n\n#### Swap Pattern\n\nMulti-route swap optimization with price impact minimization and intelligent order splitting. Supports real-time route optimization via Jupiter aggregator.\n\n**When to use:**\n- Large swaps that impact price\n- Multi-DEX routing\n- Optimized trade execution\n\n**Example (with Real DEX Integration):**\n\n```typescript\nimport { SwapPattern, Guard, COMMON_TOKENS } from '@fabriquant/sdk';\n\nconst pattern = new SwapPattern({\n  name: 'Optimized SOL Swap',\n  fromToken: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n  toToken: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n  amount: 100,\n  currentPrice: {\n    token: 'SOL',\n    price: 100,\n    quoteCurrency: 'USDC',\n    timestamp: Date.now(),\n  },\n  maxPriceImpact: 0.5,\n  enableSplitOrders: true,\n  enableRealDEX: true,          // ✨ Fetch optimal routes from Jupiter\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nconst result = await pattern.execute();\nconst summary = pattern.getSummary();\nconsole.log('Routes used:', summary.routes.length);\nconsole.log('Total price impact:', summary.totalPriceImpact);\nconsole.log('Average price:', summary.averagePrice);\n```\n\n**Example (with Manual Routes - Testing Mode):**\n\n```typescript\nconst pattern = new SwapPattern({\n  name: 'Manual Route Swap',\n  fromToken: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n  toToken: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n  amount: 100,\n  currentPrice: {\n    token: 'SOL',\n    price: 100,\n    quoteCurrency: 'USDC',\n    timestamp: Date.now(),\n  },\n  routes: [  // Manual routes for testing\n    {\n      dex: 'Orca',\n      programId: 'Orca...',\n      price: 100.5,\n      liquidity: 500000,\n      priceImpact: 0.15,\n      fee: 0.003,\n    },\n    {\n      dex: 'Raydium',\n      programId: 'Rayd...',\n      price: 100.2,\n      liquidity: 300000,\n      priceImpact: 0.25,\n      fee: 0.0025,\n    },\n  ],\n  maxPriceImpact: 0.5,\n  enableSplitOrders: true,\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n```\n\n**Configuration:**\n\n```typescript\ninterface SwapConfig {\n  name: string;\n  fromToken: Token;\n  toToken: Token;\n  amount: number;\n  currentPrice: Price;\n  routes?: SwapRoute[];          // ✨ Optional if using enableRealDEX\n  maxPriceImpact: number;        // Max allowed price impact (%)\n  enableSplitOrders?: boolean;   // Split across routes\n  minRouteAllocation?: number;   // Min allocation per route (%)\n  enableRealDEX?: boolean;       // ✨ Enable real DEX integration (default: false)\n  dexAdapter?: DEXAdapter;       // ✨ Custom DEX adapter (overrides default Jupiter)\n  guard?: Guard;\n  dryRun?: boolean;\n}\n\ninterface SwapRoute {\n  dex: string;\n  programId: string;\n  price: number;\n  liquidity: number;\n  priceImpact: number;          // Estimated impact (%)\n  fee: number;                  // Fee percentage\n}\n```\n\n#### Liquidity Pattern\n\nAutomated liquidity provision with position management and impermanent loss monitoring.\n\n**When to use:**\n- Adding/removing liquidity\n- LP position management\n- Impermanent loss tracking\n\n**Example:**\n\n```typescript\nimport { LiquidityPattern, Guard } from '@fabriquant/sdk';\n\n// Add liquidity\nconst addPattern = new LiquidityPattern({\n  name: 'Add SOL-USDC Liquidity',\n  action: 'add',\n  pool: {\n    name: 'Orca SOL-USDC',\n    programId: 'Orca...',\n    tokenA: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n    tokenB: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n    apy: 12.5,\n    feeTier: 0.003,\n    totalLiquidity: 5000000,\n    priceRatio: 100,\n  },\n  amountA: 10,    // 10 SOL\n  amountB: 1000,  // 1000 USDC\n  prices: {\n    tokenA: { token: 'SOL', price: 100, quoteCurrency: 'USDC', timestamp: Date.now() },\n    tokenB: { token: 'USDC', price: 1, quoteCurrency: 'USD', timestamp: Date.now() },\n  },\n  monitorImpermanentLoss: true,\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nconst result = await addPattern.execute();\n\n// Monitor position\nconst position = addPattern.getPositionSummary();\nconsole.log('Impermanent loss:', position?.impermanentLoss);\n\n// Remove liquidity\nconst removePattern = new LiquidityPattern({\n  name: 'Remove Liquidity',\n  action: 'remove',\n  pool: /* same pool */,\n  removePercentage: 50,  // Remove 50%\n  prices: { /* current prices */ },\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nawait removePattern.execute();\n```\n\n**Configuration:**\n\n```typescript\ninterface LiquidityConfig {\n  name: string;\n  action: 'add' | 'remove' | 'rebalance';\n  pool: LiquidityPool;\n  amountA?: number;             // For 'add'\n  amountB?: number;             // For 'add'\n  removePercentage?: number;    // For 'remove' (0-100)\n  prices: {\n    tokenA: Price;\n    tokenB: Price;\n  };\n  monitorImpermanentLoss?: boolean;\n  rebalanceThreshold?: number;  // Auto-rebalance at IL% threshold\n  guard?: Guard;\n  dryRun?: boolean;\n}\n\ninterface LiquidityPool {\n  name: string;\n  programId: string;\n  tokenA: Token;\n  tokenB: Token;\n  apy: number;\n  feeTier: number;\n  totalLiquidity: number;\n  priceRatio: number;\n}\n```"
        },
        {
          "heading": "Base Pattern API",
          "body": "All patterns extend the `ExecutionPattern` base class:\n\n```typescript\nabstract class ExecutionPattern {\n  // Execute the pattern\n  abstract execute(): Promise<PatternResult>;\n\n  // Validate configuration (override in subclass)\n  protected abstract validate(): boolean;\n\n  // Execute with automatic retry on failure\n  protected async executeWithRetry<T>(\n    fn: () => Promise<T>,\n    maxRetries?: number\n  ): Promise<T>;\n}\n```\n\n### Pattern Result\n\n```typescript\ninterface PatternResult {\n  success: boolean;\n  transactions: Transaction[];\n  metrics: PatternMetrics;\n  error?: Error;\n  metadata?: Record<string, unknown>;\n}\n\ninterface PatternMetrics {\n  executionTime: number;        // Total duration (ms)\n  gasUsed?: number;             // Total gas consumed\n  successRate: number;          // Success rate (0-1)\n  retryCount: number;           // Number of retries\n  transactionCount: number;     // Total transactions\n}\n```"
        },
        {
          "heading": "Pattern Registry",
          "body": "Register and retrieve custom patterns:\n\n```typescript\nimport { PatternRegistry, ExecutionPattern } from '@fabriquant/sdk';\n\n// Register custom pattern\nclass MyCustomPattern extends ExecutionPattern {\n  async execute() {\n    // Implementation\n  }\n\n  protected validate() {\n    // Validation\n  }\n}\n\nPatternRegistry.register('my-custom-pattern', MyCustomPattern);\n\n// Retrieve pattern\nconst PatternClass = PatternRegistry.get('my-custom-pattern');\nif (PatternClass) {\n  const pattern = new PatternClass(config);\n  await pattern.execute();\n}\n```"
        },
        {
          "heading": "Best Practices",
          "body": "### 1. Always Use Guard\n\n```typescript\nconst guard = new Guard({\n  mode: 'block',\n  maxSlippage: 0.02,\n  riskTolerance: 'moderate',\n});\n\nconst pattern = new GridTradingPattern({\n  // ... config\n  guard,  // ✅ Always include Guard\n});\n```\n\n### 2. Test with Dry Run\n\n```typescript\n// Test without executing\nconst pattern = new SwapPattern({\n  // ... config\n  dryRun: true,  // ✅ Test first\n});\n\nconst result = await pattern.execute();\nif (result.success) {\n  // Now run for real\n  pattern.config.dryRun = false;\n  await pattern.execute();\n}\n```\n\n### 3. Monitor Metrics\n\n```typescript\nconst result = await pattern.execute();\n\nconsole.log('Performance:', {\n  duration: result.metrics.executionTime,\n  gasUsed: result.metrics.gasUsed,\n  successRate: result.metrics.successRate,\n  retries: result.metrics.retryCount,\n});\n```\n\n### 4. Handle Errors\n\n```typescript\nconst result = await pattern.execute();\n\nif (!result.success) {\n  console.error('Pattern failed:', result.error);\n\n  // Analyze failure\n  if (result.error?.message.includes('slippage')) {\n    // Increase slippage tolerance\n  }\n}\n```\n\n### 5. Use Pattern-Specific Methods\n\n```typescript\n// Grid Trading\nconst gridPattern = new GridTradingPattern(config);\nconst levels = gridPattern.getGridLevels();  // Get all grid levels\n\n// Treasury Rebalancing\nconst rebalancePattern = new TreasuryRebalancing(config);\nif (rebalancePattern.needsRebalancing()) {\n  await rebalancePattern.execute();\n}\n\n// Swap\nconst swapPattern = new SwapPattern(config);\nconst summary = swapPattern.getSummary();  // Get execution summary\n```\n\n### 6. Keep Configurations Immutable\n\n```typescript\n// ❌ Don't modify config after creation\npattern.config.amount = 200;\n\n// ✅ Create new pattern instance\nconst newPattern = new SwapPattern({\n  ...config,\n  amount: 200,\n});\n```\n\n### 7. Combine with Privacy\n\n```typescript\nimport { FabricCore } from '@fabriquant/sdk';\n\nconst pattern = new GridTradingPattern(config);\nconst result = await pattern.execute();\n\n// Add privacy to transactions\nfor (const tx of result.transactions) {\n  const optimized = FabricCore.optimize(tx, {\n    enablePrivacy: true,\n    privacyProvider: 'arbor',\n  });\n}\n```"
        },
        {
          "heading": "Additional Resources",
          "body": "- [Main README](../README.md)\n- [API Documentation](./API.md)\n- [Examples](../examples/patterns/)\n- [Business Plan](../BUSINESS_PLAN.md)"
        },
        {
          "heading": "Support",
          "body": "For questions or issues:\n- GitHub Issues: [fabriquant/issues](https://github.com/your-org/fabriquant/issues)\n- Documentation: [docs.fabriquant.dev](https://docs.fabriquant.dev)"
        }
      ],
      "wordCount": 2651
    },
    {
      "path": "docs/PRIVACY.md",
      "title": "Privacy - The Hidden Stitch Documentation",
      "content": "# Privacy - The Hidden Stitch Documentation\n\n## Overview\n\nPrivacy (formerly Fabric Weave/Arbor) is the Shielded State Middleware (SSM) integration for Fabriquant, providing ZK Compression and privacy-enabled transaction execution. It acts as an abstraction layer between the Solana Virtual Machine (SVM) and the Light Protocol ZK Stack, enabling cost-efficient private transactions.\n\n**Note:** Provider identifiers still use `'arbor'` for backward compatibility, but represent the Privacy component.\n\n## Features\n\n-   **🌿 ZK Compression** - Massive cost reduction for state storage and account creation via Sparse Binary Merkle Trees\n-   **🔒 Privacy by Default** - Shielded state management to ensure transaction confidentiality\n-   **💰 Cost Estimation** - Built-in tools to calculate compression savings\n-   **⚡ Efficient Execution** - Dedicated API designed for privacy-enabled operations without sacrificing speed\n-   **🔗 Guard Integration** - Privacy validation in transaction flow\n\n## Cost Savings\n\nZK Compression provides dramatic cost reductions:\n\n| Operation          | Native Cost   | Compressed Cost   | Savings    |\n| ------------------ | ------------- | ----------------- | ---------- |\n| 100 Token Accounts | 0.20 SOL      | 0.00004 SOL       | **99.98%** |\n| 1M User Airdrop    | ~$260,000 USD | ~$50 USD          | **5,200x** |\n| PDA Creation       | High          | 1/160th of Native | **99.37%** |\n\n## Installation\n\n```bash\nnpm install @fabriquant/sdk\n```\n\n## Quick Start\n\n### Private Transaction Execution\n\n```typescript\nimport { Fabriquant, Guard, FabricCore } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({ riskTolerance: \"moderate\" });\n\nconst tx = {\n    id: \"tx-private-001\",\n    status: \"pending\",\n    instructions: [],\n};\n\n// Execute as private transaction with ZK Compression via Privacy\nconst result = await Fabriquant.executePrivate(tx, {\n    with: guard,\n    privacy: {\n        provider: \"arbor\", // Note: 'arbor' is the provider identifier, represents Privacy\n        compression: true,\n    },\n});\n\nconsole.log(\"Status:\", result.status);\nconsole.log(\"Privacy Enabled:\", result.privacyMetadata?.requiresPrivacy);\nconsole.log(\"Compression Enabled:\", result.privacyMetadata?.compressionEnabled);\n```\n\n### Cost Estimation\n\n```typescript\nimport { FabricCore } from \"@fabriquant/sdk\";\n\n// Estimate cost savings for 1000 transactions\nconst savings = FabricCore.estimateCompressionSavings(1000);\n\nconsole.log(\"Native Cost:\", savings.nativeCost, \"SOL\");\nconsole.log(\"Compressed Cost:\", savings.compressedCost, \"SOL\");\nconsole.log(\"Savings:\", savings.savings, \"SOL\");\nconsole.log(\"Savings Percentage:\", savings.savingsPercent.toFixed(2), \"%\");\n```\n\n### Optimized Private Transaction\n\n```typescript\nimport { FabricCore, Fabriquant } from \"@fabriquant/sdk\";\n\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    instructions: [],\n};\n\n// Optimize with privacy enabled via Privacy\nconst optimized = FabricCore.optimize(tx, {\n    enablePrivacy: true,\n    compressionLevel: \"high\",\n    privacyProvider: \"arbor\", // Note: 'arbor' is the provider identifier, represents Privacy\n});\n\n// Execute as private transaction\nconst result = await Fabriquant.executePrivate(optimized, {\n    privacy: {\n        provider: \"arbor\",\n        compression: true,\n    },\n});\n```\n\n## Configuration\n\n### PrivacyConfig\n\n```typescript\ninterface PrivacyConfig {\n    enabled?: boolean; // Enable privacy features\n    provider?: \"arbor\" | \"light\"; // Privacy provider ('arbor' = Privacy)\n    compressionLevel?: \"low\" | \"medium\" | \"high\"; // Compression level\n    requirePrivacy?: boolean; // Require privacy for execution\n}\n```\n\n### FabriquantConfig with Privacy\n\n```typescript\nimport { Fabriquant } from \"@fabriquant/sdk\";\n\nconst fabriquant = new Fabriquant({\n    network: \"mainnet-beta\",\n    privacy: {\n        enabled: true,\n        provider: \"arbor\", // Privacy\n        compressionLevel: \"high\",\n    },\n});\n```\n\n## API Reference\n\n### Fabriquant.executePrivate()\n\n```typescript\nstatic async executePrivate(\n  tx: Transaction,\n  options: {\n    with?: Guard;\n    privacy?: {\n      provider?: 'arbor' | 'light';\n      compression?: boolean;\n    };\n  }\n): Promise<Transaction>\n```\n\nExecute a transaction with privacy enabled.\n\n**Parameters:**\n\n-   `tx`: Transaction to execute\n-   `options.with` (optional): Guard instance for validation\n-   `options.privacy` (optional): Privacy configuration\n\n**Returns:** `Promise<Transaction>` with privacy metadata\n\n### FabricCore.optimize()\n\n```typescript\nstatic optimize(\n  transaction: Transaction,\n  options: OptimizeOptions\n): Transaction\n```\n\nOptimize transaction for parallel execution with optional privacy.\n\n**Parameters:**\n\n-   `transaction`: Transaction to optimize\n-   `options.enablePrivacy`: Enable privacy layer\n-   `options.compressionLevel`: Compression level ('low' | 'medium' | 'high')\n-   `options.privacyProvider`: Privacy provider ('arbor' | 'light')\n\n**Returns:** Optimized transaction with privacy metadata\n\n### FabricCore.compressWithArbor()\n\n```typescript\nstatic async compressWithArbor(\n  transaction: Transaction,\n  config?: PrivacyConfig\n): Promise<Transaction>\n```\n\nCompress transaction state using Privacy ZK Compression.\n\n**Note:** This is a placeholder for future implementation. Full integration with Light Protocol ZK Stack will be added in Phase 2.5.\n\n**Parameters:**\n\n-   `transaction`: Transaction to compress\n-   `config`: Privacy configuration\n\n**Returns:** Compressed transaction\n\n### FabricCore.estimateCompressionSavings()\n\n```typescript\nstatic estimateCompressionSavings(\n  transactionCount: number\n): {\n  nativeCost: number;\n  compressedCost: number;\n  savings: number;\n  savingsPercent: number;\n}\n```\n\nEstimate cost savings from ZK Compression.\n\n**Parameters:**\n\n-   `transactionCount`: Number of transactions/accounts\n\n**Returns:** Cost comparison object\n\n## Integration with Guard\n\nGuard automatically validates privacy requirements:\n\n```typescript\nimport { Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard();\n\nconst privateTx = {\n    id: \"tx-private\",\n    status: \"pending\",\n    privacyMetadata: {\n        requiresPrivacy: true,\n        compressionEnabled: true,\n    },\n    instructions: [],\n};\n\n// Guard will validate privacy requirements\nconst result = await guard.validateTransaction(privateTx);\n\n// Guard warns if privacy is requested but compression is disabled\nif (!result.isValid) {\n    result.warnings.forEach((warning) => {\n        if (warning.message.includes(\"privacy\")) {\n            console.log(\"Privacy warning:\", warning.message);\n        }\n    });\n}\n```\n\n## Use Cases\n\n### 1. Confidential Payroll & B2B Payments\n\n```typescript\n// Hide transaction amounts while allowing disclosure to authorities via Privacy\nconst payrollTx = await Fabriquant.executePrivate(payrollTransaction, {\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});\n```\n\n### 2. Private Airdrops\n\n```typescript\n// Mass airdrop to millions of users at minimal cost via Privacy\nconst airdropTx = await Fabriquant.executePrivate(airdropTransaction, {\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});\n\n// Estimate savings\nconst savings = FabricCore.estimateCompressionSavings(1000000);\nconsole.log(`Savings: ${savings.savingsPercent.toFixed(2)}%`);\n```\n\n### 3. Confidential Order Books (Dark Pools)\n\n```typescript\n// Hide order size and price until execution via Privacy\nconst orderTx = await Fabriquant.executePrivate(orderTransaction, {\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});\n```\n\n### 4. Private Governance Voting\n\n```typescript\n// Blind voting with results revealed after period ends via Privacy\nconst voteTx = await Fabriquant.executePrivate(voteTransaction, {\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});\n```\n\n## Technical Details\n\n### ZK Compression Architecture\n\nPrivacy uses **Sparse Binary Merkle Trees** to compress on-chain state:\n\n1. **State Compression**: Public state → Compressed private state\n2. **Proof Generation**: Groth16 proof system (128 bytes fixed size)\n3. **Verification**: On-chain verification of compressed state\n4. **Cost Reduction**: 99.98% reduction in storage costs\n\n### Privacy Levels\n\n-   **Low**: Basic compression, minimal privacy\n-   **Medium**: Balanced compression and privacy\n-   **High**: Maximum compression and privacy (recommended for sensitive operations)\n\n## Performance\n\n-   **Compression Time**: Varies by transaction complexity\n-   **Proof Size**: Fixed 128 bytes (Groth16)\n-   **Cost Savings**: 99.98% for token account creation\n-   **Privacy**: Full state hiding with selective disclosure support\n\n## Roadmap\n\n### Phase 2.5: Full ZK Stack Integration\n\n-   [ ] Complete Light Protocol ZK Stack integration\n-   [ ] Sparse Binary Merkle Tree implementation\n-   [ ] Groth16 proof generation\n-   [ ] On-chain verification\n-   [ ] Selective disclosure support\n-   [ ] Auditor keys for compliance\n\n### Future Enhancements\n\n-   [ ] Multi-party computation (MPC) support\n-   [ ] Fully homomorphic encryption (FHE)\n-   [ ] Trusted execution environments (TEE)\n-   [ ] Cross-chain privacy bridges\n\n## Best Practices\n\n1. **Use High Compression Level** - For maximum cost savings\n2. **Enable Compression** - Always enable compression for cost efficiency\n3. **Validate Privacy Requirements** - Use Guard to validate privacy metadata\n4. **Estimate Costs First** - Use `estimateCompressionSavings()` before large operations\n5. **Combine with Risk** - Use risk assessment for private transactions\n6. **Monitor Privacy Metadata** - Ensure `requiresPrivacy` and `compressionEnabled` are set correctly\n\n## Examples\n\nSee [`examples/pulsar-arbor-integration.ts`](../examples/pulsar-arbor-integration.ts) for comprehensive examples including:\n\n-   Private transaction execution\n-   Cost estimation\n-   Optimized private transactions\n-   Combined Risk + Privacy workflows\n\n## Support\n\n-   GitHub Issues: https://github.com/fabriquant-labs/fabriquant/issues\n-   Documentation: https://github.com/fabriquant-labs/fabriquant\n-   Twitter: https://x.com/psyto\n-   Privacy Repository: https://github.com/psyto/arbor\n",
      "sections": [
        {
          "heading": "# Privacy - The Hidden Stitch Documentation",
          "body": ""
        },
        {
          "heading": "Overview",
          "body": "Privacy (formerly Fabric Weave/Arbor) is the Shielded State Middleware (SSM) integration for Fabriquant, providing ZK Compression and privacy-enabled transaction execution. It acts as an abstraction layer between the Solana Virtual Machine (SVM) and the Light Protocol ZK Stack, enabling cost-efficient private transactions.\n\n**Note:** Provider identifiers still use `'arbor'` for backward compatibility, but represent the Privacy component."
        },
        {
          "heading": "Features",
          "body": "-   **🌿 ZK Compression** - Massive cost reduction for state storage and account creation via Sparse Binary Merkle Trees\n-   **🔒 Privacy by Default** - Shielded state management to ensure transaction confidentiality\n-   **💰 Cost Estimation** - Built-in tools to calculate compression savings\n-   **⚡ Efficient Execution** - Dedicated API designed for privacy-enabled operations without sacrificing speed\n-   **🔗 Guard Integration** - Privacy validation in transaction flow"
        },
        {
          "heading": "Cost Savings",
          "body": "ZK Compression provides dramatic cost reductions:\n\n| Operation          | Native Cost   | Compressed Cost   | Savings    |\n| ------------------ | ------------- | ----------------- | ---------- |\n| 100 Token Accounts | 0.20 SOL      | 0.00004 SOL       | **99.98%** |\n| 1M User Airdrop    | ~$260,000 USD | ~$50 USD          | **5,200x** |\n| PDA Creation       | High          | 1/160th of Native | **99.37%** |"
        },
        {
          "heading": "Installation",
          "body": "```bash\nnpm install @fabriquant/sdk\n```"
        },
        {
          "heading": "Quick Start",
          "body": "### Private Transaction Execution\n\n```typescript\nimport { Fabriquant, Guard, FabricCore } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({ riskTolerance: \"moderate\" });\n\nconst tx = {\n    id: \"tx-private-001\",\n    status: \"pending\",\n    instructions: [],\n};\n\n// Execute as private transaction with ZK Compression via Privacy\nconst result = await Fabriquant.executePrivate(tx, {\n    with: guard,\n    privacy: {\n        provider: \"arbor\", // Note: 'arbor' is the provider identifier, represents Privacy\n        compression: true,\n    },\n});\n\nconsole.log(\"Status:\", result.status);\nconsole.log(\"Privacy Enabled:\", result.privacyMetadata?.requiresPrivacy);\nconsole.log(\"Compression Enabled:\", result.privacyMetadata?.compressionEnabled);\n```\n\n### Cost Estimation\n\n```typescript\nimport { FabricCore } from \"@fabriquant/sdk\";\n\n// Estimate cost savings for 1000 transactions\nconst savings = FabricCore.estimateCompressionSavings(1000);\n\nconsole.log(\"Native Cost:\", savings.nativeCost, \"SOL\");\nconsole.log(\"Compressed Cost:\", savings.compressedCost, \"SOL\");\nconsole.log(\"Savings:\", savings.savings, \"SOL\");\nconsole.log(\"Savings Percentage:\", savings.savingsPercent.toFixed(2), \"%\");\n```\n\n### Optimized Private Transaction\n\n```typescript\nimport { FabricCore, Fabriquant } from \"@fabriquant/sdk\";\n\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    instructions: [],\n};\n\n// Optimize with privacy enabled via Privacy\nconst optimized = FabricCore.optimize(tx, {\n    enablePrivacy: true,\n    compressionLevel: \"high\",\n    privacyProvider: \"arbor\", // Note: 'arbor' is the provider identifier, represents Privacy\n});\n\n// Execute as private transaction\nconst result = await Fabriquant.executePrivate(optimized, {\n    privacy: {\n        provider: \"arbor\",\n        compression: true,\n    },\n});\n```"
        },
        {
          "heading": "Configuration",
          "body": "### PrivacyConfig\n\n```typescript\ninterface PrivacyConfig {\n    enabled?: boolean; // Enable privacy features\n    provider?: \"arbor\" | \"light\"; // Privacy provider ('arbor' = Privacy)\n    compressionLevel?: \"low\" | \"medium\" | \"high\"; // Compression level\n    requirePrivacy?: boolean; // Require privacy for execution\n}\n```\n\n### FabriquantConfig with Privacy\n\n```typescript\nimport { Fabriquant } from \"@fabriquant/sdk\";\n\nconst fabriquant = new Fabriquant({\n    network: \"mainnet-beta\",\n    privacy: {\n        enabled: true,\n        provider: \"arbor\", // Privacy\n        compressionLevel: \"high\",\n    },\n});\n```"
        },
        {
          "heading": "API Reference",
          "body": "### Fabriquant.executePrivate()\n\n```typescript\nstatic async executePrivate(\n  tx: Transaction,\n  options: {\n    with?: Guard;\n    privacy?: {\n      provider?: 'arbor' | 'light';\n      compression?: boolean;\n    };\n  }\n): Promise<Transaction>\n```\n\nExecute a transaction with privacy enabled.\n\n**Parameters:**\n\n-   `tx`: Transaction to execute\n-   `options.with` (optional): Guard instance for validation\n-   `options.privacy` (optional): Privacy configuration\n\n**Returns:** `Promise<Transaction>` with privacy metadata\n\n### FabricCore.optimize()\n\n```typescript\nstatic optimize(\n  transaction: Transaction,\n  options: OptimizeOptions\n): Transaction\n```\n\nOptimize transaction for parallel execution with optional privacy.\n\n**Parameters:**\n\n-   `transaction`: Transaction to optimize\n-   `options.enablePrivacy`: Enable privacy layer\n-   `options.compressionLevel`: Compression level ('low' | 'medium' | 'high')\n-   `options.privacyProvider`: Privacy provider ('arbor' | 'light')\n\n**Returns:** Optimized transaction with privacy metadata\n\n### FabricCore.compressWithArbor()\n\n```typescript\nstatic async compressWithArbor(\n  transaction: Transaction,\n  config?: PrivacyConfig\n): Promise<Transaction>\n```\n\nCompress transaction state using Privacy ZK Compression.\n\n**Note:** This is a placeholder for future implementation. Full integration with Light Protocol ZK Stack will be added in Phase 2.5.\n\n**Parameters:**\n\n-   `transaction`: Transaction to compress\n-   `config`: Privacy configuration\n\n**Returns:** Compressed transaction\n\n### FabricCore.estimateCompressionSavings()\n\n```typescript\nstatic estimateCompressionSavings(\n  transactionCount: number\n): {\n  nativeCost: number;\n  compressedCost: number;\n  savings: number;\n  savingsPercent: number;\n}\n```\n\nEstimate cost savings from ZK Compression.\n\n**Parameters:**\n\n-   `transactionCount`: Number of transactions/accounts\n\n**Returns:** Cost comparison object"
        },
        {
          "heading": "Integration with Guard",
          "body": "Guard automatically validates privacy requirements:\n\n```typescript\nimport { Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard();\n\nconst privateTx = {\n    id: \"tx-private\",\n    status: \"pending\",\n    privacyMetadata: {\n        requiresPrivacy: true,\n        compressionEnabled: true,\n    },\n    instructions: [],\n};\n\n// Guard will validate privacy requirements\nconst result = await guard.validateTransaction(privateTx);\n\n// Guard warns if privacy is requested but compression is disabled\nif (!result.isValid) {\n    result.warnings.forEach((warning) => {\n        if (warning.message.includes(\"privacy\")) {\n            console.log(\"Privacy warning:\", warning.message);\n        }\n    });\n}\n```"
        },
        {
          "heading": "Use Cases",
          "body": "### 1. Confidential Payroll & B2B Payments\n\n```typescript\n// Hide transaction amounts while allowing disclosure to authorities via Privacy\nconst payrollTx = await Fabriquant.executePrivate(payrollTransaction, {\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});\n```\n\n### 2. Private Airdrops\n\n```typescript\n// Mass airdrop to millions of users at minimal cost via Privacy\nconst airdropTx = await Fabriquant.executePrivate(airdropTransaction, {\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});\n\n// Estimate savings\nconst savings = FabricCore.estimateCompressionSavings(1000000);\nconsole.log(`Savings: ${savings.savingsPercent.toFixed(2)}%`);\n```\n\n### 3. Confidential Order Books (Dark Pools)\n\n```typescript\n// Hide order size and price until execution via Privacy\nconst orderTx = await Fabriquant.executePrivate(orderTransaction, {\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});\n```\n\n### 4. Private Governance Voting\n\n```typescript\n// Blind voting with results revealed after period ends via Privacy\nconst voteTx = await Fabriquant.executePrivate(voteTransaction, {\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});\n```"
        },
        {
          "heading": "Technical Details",
          "body": "### ZK Compression Architecture\n\nPrivacy uses **Sparse Binary Merkle Trees** to compress on-chain state:\n\n1. **State Compression**: Public state → Compressed private state\n2. **Proof Generation**: Groth16 proof system (128 bytes fixed size)\n3. **Verification**: On-chain verification of compressed state\n4. **Cost Reduction**: 99.98% reduction in storage costs\n\n### Privacy Levels\n\n-   **Low**: Basic compression, minimal privacy\n-   **Medium**: Balanced compression and privacy\n-   **High**: Maximum compression and privacy (recommended for sensitive operations)"
        },
        {
          "heading": "Performance",
          "body": "-   **Compression Time**: Varies by transaction complexity\n-   **Proof Size**: Fixed 128 bytes (Groth16)\n-   **Cost Savings**: 99.98% for token account creation\n-   **Privacy**: Full state hiding with selective disclosure support"
        },
        {
          "heading": "Roadmap",
          "body": "### Phase 2.5: Full ZK Stack Integration\n\n-   [ ] Complete Light Protocol ZK Stack integration\n-   [ ] Sparse Binary Merkle Tree implementation\n-   [ ] Groth16 proof generation\n-   [ ] On-chain verification\n-   [ ] Selective disclosure support\n-   [ ] Auditor keys for compliance\n\n### Future Enhancements\n\n-   [ ] Multi-party computation (MPC) support\n-   [ ] Fully homomorphic encryption (FHE)\n-   [ ] Trusted execution environments (TEE)\n-   [ ] Cross-chain privacy bridges"
        },
        {
          "heading": "Best Practices",
          "body": "1. **Use High Compression Level** - For maximum cost savings\n2. **Enable Compression** - Always enable compression for cost efficiency\n3. **Validate Privacy Requirements** - Use Guard to validate privacy metadata\n4. **Estimate Costs First** - Use `estimateCompressionSavings()` before large operations\n5. **Combine with Risk** - Use risk assessment for private transactions\n6. **Monitor Privacy Metadata** - Ensure `requiresPrivacy` and `compressionEnabled` are set correctly"
        },
        {
          "heading": "Examples",
          "body": "See [`examples/pulsar-arbor-integration.ts`](../examples/pulsar-arbor-integration.ts) for comprehensive examples including:\n\n-   Private transaction execution\n-   Cost estimation\n-   Optimized private transactions\n-   Combined Risk + Privacy workflows"
        },
        {
          "heading": "Support",
          "body": "-   GitHub Issues: https://github.com/fabriquant-labs/fabriquant/issues\n-   Documentation: https://github.com/fabriquant-labs/fabriquant\n-   Twitter: https://x.com/psyto\n-   Privacy Repository: https://github.com/psyto/arbor"
        }
      ],
      "wordCount": 1193
    },
    {
      "path": "docs/RISK.md",
      "title": "Risk - The Quality Gauge Documentation",
      "content": "# Risk - The Quality Gauge Documentation\n\n## Overview\n\nRisk (formerly Fabric Pulse/Pulsar) is the Risk Oracle component of Fabriquant, providing AI-driven risk assessment for Real World Assets (RWA) and asset integrity validation. It integrates seamlessly with Guard to provide institutional-grade risk metrics before transaction execution.\n\n**Note:** The class is still exported as `Pulsar` for backward compatibility, but represents the Risk component.\n\n## Features\n\n-   **🧭 Real-time Risk Assessment** - Continuous monitoring of risk scores, compliance status, and oracle integrity\n-   **💾 Intelligent Caching** - Configurable TTL to maximize performance and minimize API overhead\n-   **📦 Batch Processing** - Assess multiple assets simultaneously\n-   **🔄 Fallback Support** - Graceful degradation when API unavailable\n-   **🔗 Guard Integration** - Seamlessly feeds data into Guard for automated transaction blocking\n\n## Installation\n\n```bash\nnpm install @fabriquant/sdk\n```\n\n## Quick Start\n\n### Basic Risk Assessment\n\n```typescript\nimport { Pulsar } from \"@fabriquant/sdk\";\n\n// Note: The class is still named 'Pulsar' in code, but represents Risk\n// Get risk metrics for a single asset\nconst metrics = await Pulsar.getRiskMetrics(\n    \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\n);\n\nconsole.log(\"Risk Score:\", metrics.riskScore);\nconsole.log(\"Compliance:\", metrics.complianceStatus);\nconsole.log(\"Counterparty Risk:\", metrics.counterpartyRisk);\nconsole.log(\"Oracle Integrity:\", metrics.oracleIntegrity);\n```\n\n### Batch Risk Assessment\n\n```typescript\nimport { Pulsar } from \"@fabriquant/sdk\"; // Risk\n\nconst assetAddresses = [\n    \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\",\n    \"So11111111111111111111111111111111111111112\",\n    \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n];\n\n// Get risk metrics for multiple assets\nconst riskMap = await Pulsar.getBatchRiskMetrics(assetAddresses);\n\nfor (const [address, metrics] of riskMap.entries()) {\n    console.log(`${address}: Risk Score = ${metrics.riskScore}`);\n}\n```\n\n## Configuration\n\n### PulsarConfig\n\n```typescript\ninterface PulsarConfig {\n    enabled?: boolean; // Enable Risk checks (default: true)\n    riskThreshold?: number; // 0-1 scale, block if exceeded (default: 0.7)\n    enableComplianceCheck?: boolean; // Check compliance status (default: true)\n    enableCounterpartyCheck?: boolean; // Check counterparty risk (default: true)\n    enableOracleCheck?: boolean; // Check oracle integrity (default: true)\n    cacheTTL?: number; // Cache TTL in milliseconds (default: 60000)\n    fallbackOnError?: boolean; // Allow transactions if API fails (default: true)\n}\n```\n\n## Risk Metrics\n\n### RiskMetrics Interface\n\n```typescript\ninterface RiskMetrics {\n    asset?: string; // Asset address\n    riskScore: number | null; // 0-1 scale, where 1 is highest risk\n    complianceStatus: \"compliant\" | \"non-compliant\" | \"unknown\" | null;\n    counterpartyRisk: number | null; // 0-1 scale\n    oracleIntegrity: number | null; // 0-1 scale, where 1 is highest integrity\n    timestamp?: number; // When metrics were fetched\n}\n```\n\n### Risk Score Interpretation\n\n-   **0.0 - 0.3**: Low risk - Safe for most operations\n-   **0.3 - 0.6**: Moderate risk - Review before execution\n-   **0.6 - 0.8**: High risk - Block in strict mode\n-   **0.8 - 1.0**: Critical risk - Block in all modes\n\n## Caching\n\nRisk uses an in-memory cache to reduce API calls and improve performance.\n\n### Cache Management\n\n```typescript\nimport { Pulsar } from \"@fabriquant/sdk\";\n\n// Get cache statistics\nconst stats = Pulsar.getCacheStats();\nconsole.log(\"Cache size:\", stats.size);\nconsole.log(\"Cached assets:\", stats.entries);\n\n// Clear cache\nPulsar.clearCache();\n```\n\n### Cache Configuration\n\n```typescript\n// Configure cache TTL (default: 60000ms = 1 minute)\nconst metrics = await Pulsar.getRiskMetrics(assetAddress, {\n    cacheTTL: 300000, // 5 minutes\n});\n```\n\n## Integration with Guard\n\nRisk integrates automatically with Guard when enabled in the configuration:\n\n```typescript\nimport { Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    pulsar: {\n        enabled: true,\n        riskThreshold: 0.7,\n        enableComplianceCheck: true,\n        enableCounterpartyCheck: true,\n        enableOracleCheck: true,\n        cacheTTL: 60000,\n        fallbackOnError: true,\n    },\n    mode: \"block\",\n});\n\n// Transaction must include assetAddresses\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    assetAddresses: [\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"],\n    instructions: [],\n};\n\n// Guard will automatically check Risk metrics\nconst result = await guard.validateTransaction(tx);\n\nif (!result.isValid) {\n    // Check for Risk-related warnings\n    result.warnings.forEach((warning) => {\n        if (\n            warning.message.includes(\"risk\") ||\n            warning.message.includes(\"compliance\")\n        ) {\n            console.log(\"Risk warning:\", warning.message);\n        }\n    });\n}\n```\n\n## Error Handling\n\nRisk supports graceful fallback when the API is unavailable:\n\n```typescript\nconst guard = new Guard({\n    pulsar: {\n        enabled: true,\n        fallbackOnError: true, // Allow transactions if API fails\n    },\n});\n\n// If Risk API fails, transaction will proceed (if fallbackOnError: true)\n// If fallbackOnError: false, transaction will be blocked\n```\n\n## Use Cases\n\n### 1. RWA Compliance Checking\n\n```typescript\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        enableComplianceCheck: true,\n        riskThreshold: 0.5, // Stricter for RWA\n    },\n    mode: \"block\",\n});\n```\n\n### 2. High-Frequency Trading\n\n```typescript\n// Use aggressive caching for high-frequency operations\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        cacheTTL: 10000, // 10 seconds for faster updates\n    },\n});\n```\n\n### 3. Institutional DeFi\n\n```typescript\n// Comprehensive risk assessment for institutional use\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        riskThreshold: 0.6,\n        enableComplianceCheck: true,\n        enableCounterpartyCheck: true,\n        enableOracleCheck: true,\n    },\n    riskTolerance: \"strict\",\n});\n```\n\n## API Reference\n\n### Pulsar Class (Risk)\n\n**Note:** The class is exported as `Pulsar` for backward compatibility, but represents Risk functionality.\n\n#### getRiskMetrics()\n\n```typescript\nstatic async getRiskMetrics(\n  assetAddress?: string,\n  config?: PulsarConfig\n): Promise<RiskMetrics>\n```\n\nGet risk metrics for a single asset.\n\n**Parameters:**\n\n-   `assetAddress` (optional): The asset address to assess\n-   `config` (optional): Pulsar configuration options\n\n**Returns:** `Promise<RiskMetrics>`\n\n#### getBatchRiskMetrics()\n\n```typescript\nstatic async getBatchRiskMetrics(\n  assetAddresses: string[],\n  config?: PulsarConfig\n): Promise<Map<string, RiskMetrics>>\n```\n\nGet risk metrics for multiple assets in parallel.\n\n**Parameters:**\n\n-   `assetAddresses`: Array of asset addresses\n-   `config` (optional): Pulsar configuration options\n\n**Returns:** `Promise<Map<string, RiskMetrics>>`\n\n#### clearCache()\n\n```typescript\nstatic clearCache(): void\n```\n\nClear the risk metrics cache.\n\n#### getCacheStats()\n\n```typescript\nstatic getCacheStats(): { size: number; entries: string[] }\n```\n\nGet cache statistics.\n\n**Returns:** Object with cache size and list of cached asset addresses\n\n## Performance\n\n-   **API Call Latency**: ~50-100ms (first call, cached responses are instant)\n-   **Cache Hit Rate**: High with default 1-minute TTL\n-   **Batch Processing**: Processes multiple assets in parallel\n-   **Memory Usage**: ~1KB per cached asset\n\n## Roadmap\n\n-   [ ] Full x402 protocol integration\n-   [ ] Real-time risk score updates via WebSocket\n-   [ ] Historical risk trend analysis\n-   [ ] Custom risk scoring models\n-   [ ] Multi-chain support\n-   [ ] Integration with Privacy for privacy-aware risk assessment\n\n## Support\n\n-   GitHub Issues: https://github.com/fabriquant-labs/fabriquant/issues\n-   Documentation: https://github.com/fabriquant-labs/fabriquant\n-   Twitter: https://x.com/psyto\n",
      "sections": [
        {
          "heading": "# Risk - The Quality Gauge Documentation",
          "body": ""
        },
        {
          "heading": "Overview",
          "body": "Risk (formerly Fabric Pulse/Pulsar) is the Risk Oracle component of Fabriquant, providing AI-driven risk assessment for Real World Assets (RWA) and asset integrity validation. It integrates seamlessly with Guard to provide institutional-grade risk metrics before transaction execution.\n\n**Note:** The class is still exported as `Pulsar` for backward compatibility, but represents the Risk component."
        },
        {
          "heading": "Features",
          "body": "-   **🧭 Real-time Risk Assessment** - Continuous monitoring of risk scores, compliance status, and oracle integrity\n-   **💾 Intelligent Caching** - Configurable TTL to maximize performance and minimize API overhead\n-   **📦 Batch Processing** - Assess multiple assets simultaneously\n-   **🔄 Fallback Support** - Graceful degradation when API unavailable\n-   **🔗 Guard Integration** - Seamlessly feeds data into Guard for automated transaction blocking"
        },
        {
          "heading": "Installation",
          "body": "```bash\nnpm install @fabriquant/sdk\n```"
        },
        {
          "heading": "Quick Start",
          "body": "### Basic Risk Assessment\n\n```typescript\nimport { Pulsar } from \"@fabriquant/sdk\";\n\n// Note: The class is still named 'Pulsar' in code, but represents Risk\n// Get risk metrics for a single asset\nconst metrics = await Pulsar.getRiskMetrics(\n    \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\n);\n\nconsole.log(\"Risk Score:\", metrics.riskScore);\nconsole.log(\"Compliance:\", metrics.complianceStatus);\nconsole.log(\"Counterparty Risk:\", metrics.counterpartyRisk);\nconsole.log(\"Oracle Integrity:\", metrics.oracleIntegrity);\n```\n\n### Batch Risk Assessment\n\n```typescript\nimport { Pulsar } from \"@fabriquant/sdk\"; // Risk\n\nconst assetAddresses = [\n    \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\",\n    \"So11111111111111111111111111111111111111112\",\n    \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n];\n\n// Get risk metrics for multiple assets\nconst riskMap = await Pulsar.getBatchRiskMetrics(assetAddresses);\n\nfor (const [address, metrics] of riskMap.entries()) {\n    console.log(`${address}: Risk Score = ${metrics.riskScore}`);\n}\n```"
        },
        {
          "heading": "Configuration",
          "body": "### PulsarConfig\n\n```typescript\ninterface PulsarConfig {\n    enabled?: boolean; // Enable Risk checks (default: true)\n    riskThreshold?: number; // 0-1 scale, block if exceeded (default: 0.7)\n    enableComplianceCheck?: boolean; // Check compliance status (default: true)\n    enableCounterpartyCheck?: boolean; // Check counterparty risk (default: true)\n    enableOracleCheck?: boolean; // Check oracle integrity (default: true)\n    cacheTTL?: number; // Cache TTL in milliseconds (default: 60000)\n    fallbackOnError?: boolean; // Allow transactions if API fails (default: true)\n}\n```"
        },
        {
          "heading": "Risk Metrics",
          "body": "### RiskMetrics Interface\n\n```typescript\ninterface RiskMetrics {\n    asset?: string; // Asset address\n    riskScore: number | null; // 0-1 scale, where 1 is highest risk\n    complianceStatus: \"compliant\" | \"non-compliant\" | \"unknown\" | null;\n    counterpartyRisk: number | null; // 0-1 scale\n    oracleIntegrity: number | null; // 0-1 scale, where 1 is highest integrity\n    timestamp?: number; // When metrics were fetched\n}\n```\n\n### Risk Score Interpretation\n\n-   **0.0 - 0.3**: Low risk - Safe for most operations\n-   **0.3 - 0.6**: Moderate risk - Review before execution\n-   **0.6 - 0.8**: High risk - Block in strict mode\n-   **0.8 - 1.0**: Critical risk - Block in all modes"
        },
        {
          "heading": "Caching",
          "body": "Risk uses an in-memory cache to reduce API calls and improve performance.\n\n### Cache Management\n\n```typescript\nimport { Pulsar } from \"@fabriquant/sdk\";\n\n// Get cache statistics\nconst stats = Pulsar.getCacheStats();\nconsole.log(\"Cache size:\", stats.size);\nconsole.log(\"Cached assets:\", stats.entries);\n\n// Clear cache\nPulsar.clearCache();\n```\n\n### Cache Configuration\n\n```typescript\n// Configure cache TTL (default: 60000ms = 1 minute)\nconst metrics = await Pulsar.getRiskMetrics(assetAddress, {\n    cacheTTL: 300000, // 5 minutes\n});\n```"
        },
        {
          "heading": "Integration with Guard",
          "body": "Risk integrates automatically with Guard when enabled in the configuration:\n\n```typescript\nimport { Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    pulsar: {\n        enabled: true,\n        riskThreshold: 0.7,\n        enableComplianceCheck: true,\n        enableCounterpartyCheck: true,\n        enableOracleCheck: true,\n        cacheTTL: 60000,\n        fallbackOnError: true,\n    },\n    mode: \"block\",\n});\n\n// Transaction must include assetAddresses\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    assetAddresses: [\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"],\n    instructions: [],\n};\n\n// Guard will automatically check Risk metrics\nconst result = await guard.validateTransaction(tx);\n\nif (!result.isValid) {\n    // Check for Risk-related warnings\n    result.warnings.forEach((warning) => {\n        if (\n            warning.message.includes(\"risk\") ||\n            warning.message.includes(\"compliance\")\n        ) {\n            console.log(\"Risk warning:\", warning.message);\n        }\n    });\n}\n```"
        },
        {
          "heading": "Error Handling",
          "body": "Risk supports graceful fallback when the API is unavailable:\n\n```typescript\nconst guard = new Guard({\n    pulsar: {\n        enabled: true,\n        fallbackOnError: true, // Allow transactions if API fails\n    },\n});\n\n// If Risk API fails, transaction will proceed (if fallbackOnError: true)\n// If fallbackOnError: false, transaction will be blocked\n```"
        },
        {
          "heading": "Use Cases",
          "body": "### 1. RWA Compliance Checking\n\n```typescript\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        enableComplianceCheck: true,\n        riskThreshold: 0.5, // Stricter for RWA\n    },\n    mode: \"block\",\n});\n```\n\n### 2. High-Frequency Trading\n\n```typescript\n// Use aggressive caching for high-frequency operations\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        cacheTTL: 10000, // 10 seconds for faster updates\n    },\n});\n```\n\n### 3. Institutional DeFi\n\n```typescript\n// Comprehensive risk assessment for institutional use\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        riskThreshold: 0.6,\n        enableComplianceCheck: true,\n        enableCounterpartyCheck: true,\n        enableOracleCheck: true,\n    },\n    riskTolerance: \"strict\",\n});\n```"
        },
        {
          "heading": "API Reference",
          "body": "### Pulsar Class (Risk)\n\n**Note:** The class is exported as `Pulsar` for backward compatibility, but represents Risk functionality.\n\n#### getRiskMetrics()\n\n```typescript\nstatic async getRiskMetrics(\n  assetAddress?: string,\n  config?: PulsarConfig\n): Promise<RiskMetrics>\n```\n\nGet risk metrics for a single asset.\n\n**Parameters:**\n\n-   `assetAddress` (optional): The asset address to assess\n-   `config` (optional): Pulsar configuration options\n\n**Returns:** `Promise<RiskMetrics>`\n\n#### getBatchRiskMetrics()\n\n```typescript\nstatic async getBatchRiskMetrics(\n  assetAddresses: string[],\n  config?: PulsarConfig\n): Promise<Map<string, RiskMetrics>>\n```\n\nGet risk metrics for multiple assets in parallel.\n\n**Parameters:**\n\n-   `assetAddresses`: Array of asset addresses\n-   `config` (optional): Pulsar configuration options\n\n**Returns:** `Promise<Map<string, RiskMetrics>>`\n\n#### clearCache()\n\n```typescript\nstatic clearCache(): void\n```\n\nClear the risk metrics cache.\n\n#### getCacheStats()\n\n```typescript\nstatic getCacheStats(): { size: number; entries: string[] }\n```\n\nGet cache statistics.\n\n**Returns:** Object with cache size and list of cached asset addresses"
        },
        {
          "heading": "Performance",
          "body": "-   **API Call Latency**: ~50-100ms (first call, cached responses are instant)\n-   **Cache Hit Rate**: High with default 1-minute TTL\n-   **Batch Processing**: Processes multiple assets in parallel\n-   **Memory Usage**: ~1KB per cached asset"
        },
        {
          "heading": "Roadmap",
          "body": "-   [ ] Full x402 protocol integration\n-   [ ] Real-time risk score updates via WebSocket\n-   [ ] Historical risk trend analysis\n-   [ ] Custom risk scoring models\n-   [ ] Multi-chain support\n-   [ ] Integration with Privacy for privacy-aware risk assessment"
        },
        {
          "heading": "Support",
          "body": "-   GitHub Issues: https://github.com/fabriquant-labs/fabriquant/issues\n-   Documentation: https://github.com/fabriquant-labs/fabriquant\n-   Twitter: https://x.com/psyto"
        }
      ],
      "wordCount": 975
    }
  ],
  "codeExamples": [
    {
      "language": "typescript",
      "code": "// Unified chain interface\ninterface ChainAdapter {\n    chain: \"solana\" | \"ethereum\" | \"polygon\" | \"arbitrum\";\n    buildTransaction(tx: UnifiedTransaction): ChainTransaction;\n    executeTransaction(tx: ChainTransaction): Promise<TransactionResult>;\n    estimateCost(tx: ChainTransaction): Promise<bigint>;\n}\n\n// Portable components work with unified interface\nclass Guard {\n    validateTransaction(\n        tx: UnifiedTransaction,\n        chain: ChainAdapter\n    ): ValidationResult {\n        // Chain-agnostic validation logic\n        // Chain-specific patterns via adapter\n    }\n}",
      "source": "BUSINESS_PLAN.md"
    },
    {
      "language": "text",
      "code": "fabriquant/\n├── src/\n│   ├── core/           # Fabriquant orchestration class\n│   ├── guard/          # Security layer (Guard)\n│   ├── pulsar/         # Risk assessment (Risk/Pulsar)\n│   ├── fabric/         # Performance & Privacy (FabricCore)\n│   ├── loom/           # Liquidity engine (Loom)\n│   └── types/          # Shared TypeScript types\n├── docs/               # Component documentation\n├── examples/           # Usage examples\n└── tests/              # Unit tests",
      "source": "CHANGELOG.md"
    },
    {
      "language": "text",
      "code": "src/dex/\n├── types.ts          # DEX adapter interfaces and common types (190 lines)\n├── jupiter.ts        # Jupiter V6 API client implementation (298 lines)\n├── price-feed.ts     # Price aggregation service (223 lines)\n└── index.ts          # Module exports (21 lines)",
      "source": "CHANGELOG.md"
    },
    {
      "language": "bash",
      "code": "git clone https://github.com/YOUR_USERNAME/fabriquant.git\n   cd fabriquant",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "bash",
      "code": "npm install",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "bash",
      "code": "npm test",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "bash",
      "code": "npm run lint",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "bash",
      "code": "git checkout -b feature/your-feature-name\n   # or\n   git checkout -b fix/issue-description",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "bash",
      "code": "npm test\n   npm run lint",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "text",
      "code": "src/\n├── core/           # Core orchestration (Fabriquant class)\n├── guard/          # Security layer\n├── pulsar/         # Risk assessment (backward compat: still named Pulsar)\n├── fabric/         # Performance & Privacy layer\n├── loom/           # Liquidity engine\n└── types/          # Shared TypeScript types",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "bash",
      "code": "npm run lint",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "typescript",
      "code": "import { describe, it, expect } from \"vitest\";\nimport { Guard } from \"../src/guard\";\n\ndescribe(\"Guard\", () => {\n    it(\"should validate transaction within slippage limits\", () => {\n        const guard = new Guard({ maxSlippage: 0.1 });\n        const result = guard.validateTransaction(mockTransaction);\n        expect(result.isValid).toBe(true);\n    });\n\n    it(\"should reject transaction exceeding slippage limits\", () => {\n        const guard = new Guard({ maxSlippage: 0.1 });\n        const result = guard.validateTransaction(highSlippageTx);\n        expect(result.isValid).toBe(false);\n    });\n});",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "bash",
      "code": "# Run all tests\nnpm test\n\n# Run tests in watch mode\nnpm run test:watch\n\n# Run with coverage\nnpm run test:coverage",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "text",
      "code": "<type>(<scope>): <subject>\n\n<body>\n\n<footer>",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "bash",
      "code": "feat(guard): add custom pattern detection for CPI calls\n\nImplement support for user-defined security patterns to detect\nsuspicious Cross-Program Invocation patterns.\n\nCloses #42\n\n---\n\nfix(risk): correct cache TTL calculation\n\nThe cache was expiring too early due to millisecond conversion error.\n\n---\n\ndocs(readme): update installation instructions\n\nAdd npm and yarn installation commands to README.\n\n---\n\nrefactor(fabric): simplify transaction optimization logic\n\nRemove redundant conditional checks and improve readability.",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "text",
      "code": "feat(guard): add support for custom validation rules\nfix(risk): resolve race condition in cache updates\ndocs: improve Guard API documentation",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "markdown",
      "code": "## Description\nBrief description of what this PR does.\n\n## Type of Change\n- [ ] Bug fix (non-breaking change fixing an issue)\n- [ ] New feature (non-breaking change adding functionality)\n- [ ] Breaking change (fix or feature causing existing functionality to change)\n- [ ] Documentation update\n\n## Testing\nDescribe the tests you ran and how to reproduce them.\n\n## Checklist\n- [ ] My code follows the project's code standards\n- [ ] I have performed a self-review of my code\n- [ ] I have commented my code, particularly in hard-to-understand areas\n- [ ] I have updated the documentation accordingly\n- [ ] My changes generate no new warnings or errors\n- [ ] I have added tests that prove my fix is effective or that my feature works\n- [ ] New and existing unit tests pass locally with my changes\n\n## Related Issues\nCloses #(issue number)",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "typescript",
      "code": "/**\n * Validate a transaction against configured security rules\n * @param transaction - The transaction to validate\n * @returns Validation result with isValid flag and optional reasons\n * @example\n *",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "text",
      "code": "*/\npublic validateTransaction(transaction: Transaction): ValidationResult {\n    // Implementation\n}",
      "source": "CONTRIBUTING.md"
    },
    {
      "language": "json",
      "code": "{\n  \"dependencies\": {\n    \"@fabricant/sdk\": \"^0.0.x\"\n  }\n}",
      "source": "MIGRATION.md"
    },
    {
      "language": "json",
      "code": "{\n  \"dependencies\": {\n    \"@fabriquant/sdk\": \"^0.1.0\"\n  }\n}",
      "source": "MIGRATION.md"
    },
    {
      "language": "bash",
      "code": "npm uninstall @fabricant/sdk",
      "source": "MIGRATION.md"
    },
    {
      "language": "bash",
      "code": "npm install @fabriquant/sdk",
      "source": "MIGRATION.md"
    },
    {
      "language": "typescript",
      "code": "// Old\n   import { Guard, Pulsar } from \"@fabricant/sdk\";\n\n   // New\n   import { Guard, Pulsar } from \"@fabriquant/sdk\";",
      "source": "MIGRATION.md"
    },
    {
      "language": "typescript",
      "code": "// This works in both old and new versions\nimport { Pulsar } from \"@fabriquant/sdk\";\n\nconst pulsar = new Pulsar({\n  apiKey: \"your-api-key\",\n  environment: \"mainnet\",\n});",
      "source": "MIGRATION.md"
    },
    {
      "language": "typescript",
      "code": "// This works in both old and new versions\nimport { FabricCore } from \"@fabriquant/sdk\";\n\nconst tx = FabricCore.optimize(transaction, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\", // Identifier unchanged\n});\n\nawait Fabriquant.executePrivate(tx, {\n  with: guard,\n  privacy: {\n    provider: \"arbor\", // Identifier unchanged\n    compression: true,\n  },\n});",
      "source": "MIGRATION.md"
    },
    {
      "language": "typescript",
      "code": "// Old\nimport { Fabricant } from \"@fabricant/sdk\";\nawait Fabricant.execute(tx, { with: guard });\n\n// New\nimport { Fabriquant } from \"@fabriquant/sdk\";\nawait Fabriquant.execute(tx, { with: guard });",
      "source": "MIGRATION.md"
    },
    {
      "language": "typescript",
      "code": "import { Fabricant, Guard } from \"@fabricant/sdk\";\n\nconst guard = new Guard({\n  maxSlippage: 0.1,\n  riskTolerance: \"moderate\",\n  mode: \"block\",\n});\n\nconst result = await Fabricant.execute(transaction, { with: guard });",
      "source": "MIGRATION.md"
    },
    {
      "language": "typescript",
      "code": "import { Fabriquant, Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n  maxSlippage: 0.1,\n  riskTolerance: \"moderate\",\n  mode: \"block\",\n});\n\nconst result = await Fabriquant.execute(transaction, { with: guard });",
      "source": "MIGRATION.md"
    },
    {
      "language": "typescript",
      "code": "import { Guard, Pulsar } from \"@fabricant/sdk\";\n\n// Guard with Fabric Pulse (Risk) enabled\nconst guard = new Guard({\n  pulsar: {\n    enabled: true,\n    riskThreshold: 0.7,\n    cacheTTL: 60000,\n  },\n});",
      "source": "MIGRATION.md"
    },
    {
      "language": "typescript",
      "code": "import { Guard, Pulsar } from \"@fabriquant/sdk\";\n\n// Guard with Risk enabled (class still named Pulsar for compatibility)\nconst guard = new Guard({\n  pulsar: {\n    enabled: true,\n    riskThreshold: 0.7,\n    cacheTTL: 60000,\n  },\n});",
      "source": "MIGRATION.md"
    },
    {
      "language": "typescript",
      "code": "import { Fabricant, FabricCore } from \"@fabricant/sdk\";\n\n// Optimize with Fabric Weave (Privacy)\nconst optimized = FabricCore.optimize(tx, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\",\n});\n\nconst result = await Fabricant.executePrivate(optimized, {\n  privacy: { provider: \"arbor\" },\n});",
      "source": "MIGRATION.md"
    },
    {
      "language": "typescript",
      "code": "import { Fabriquant, FabricCore } from \"@fabriquant/sdk\";\n\n// Optimize with Privacy (provider identifier remains \"arbor\")\nconst optimized = FabricCore.optimize(tx, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\",\n});\n\nconst result = await Fabriquant.executePrivate(optimized, {\n  privacy: { provider: \"arbor\" },\n});",
      "source": "MIGRATION.md"
    },
    {
      "language": "typescript",
      "code": "import { Fabricant, Guard, Pulsar, FabricCore, Loom } from \"@fabricant/sdk\";\n\n// Initialize Guard with Fabric Pulse (Risk)\nconst guard = new Guard({\n  pulsar: { enabled: true, riskThreshold: 0.7 },\n  mode: \"block\",\n});\n\n// Create transaction with Loom\nconst tx = await Loom.weave({\n  type: \"MULTI_ROUTE_SWAP\",\n  input: \"SOL\",\n  output: \"USDC\",\n  amount: 100,\n});\n\n// Optimize with Fabric Weave (Privacy)\nconst optimized = FabricCore.optimize(tx, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\",\n});\n\n// Execute with Fabricant\nconst result = await Fabricant.executePrivate(optimized, {\n  with: guard,\n  privacy: { provider: \"arbor\", compression: true },\n});",
      "source": "MIGRATION.md"
    },
    {
      "language": "typescript",
      "code": "import { Fabriquant, Guard, Pulsar, FabricCore, Loom } from \"@fabriquant/sdk\";\n\n// Initialize Guard with Risk (class still named Pulsar)\nconst guard = new Guard({\n  pulsar: { enabled: true, riskThreshold: 0.7 },\n  mode: \"block\",\n});\n\n// Create transaction with Loom\nconst tx = await Loom.weave({\n  type: \"MULTI_ROUTE_SWAP\",\n  input: \"SOL\",\n  output: \"USDC\",\n  amount: 100,\n});\n\n// Optimize with Privacy (provider identifier still \"arbor\")\nconst optimized = FabricCore.optimize(tx, {\n  enablePrivacy: true,\n  privacyProvider: \"arbor\",\n});\n\n// Execute with Fabriquant\nconst result = await Fabriquant.executePrivate(optimized, {\n  with: guard,\n  privacy: { provider: \"arbor\", compression: true },\n});",
      "source": "MIGRATION.md"
    },
    {
      "language": "typescript",
      "code": "import { Fabriquant, Guard, Loom } from \"@fabriquant/sdk\";\n\n// 1. Initialize the Precision Guard\nconst guard = new Guard({\n    maxSlippage: 0.1,\n    riskTolerance: \"moderate\",\n    mode: \"block\",\n});\n\n// 2. Weave an optimized parallel transaction\nconst tx = await Loom.weave({\n    type: \"MULTI_ROUTE_SWAP\",\n    input: \"SOL\",\n    output: \"USDC\",\n    amount: 50,\n    parallelPriority: true, // Enabled by Loom\n});\n\n// 3. Execute with Fabriquant Precision\nawait Fabriquant.execute(tx, { with: guard });",
      "source": "README.md"
    },
    {
      "language": "typescript",
      "code": "import { Fabriquant, Guard, Pulsar } from \"@fabriquant/sdk\";\n\n// Guard with Risk assessment enabled\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration (class still named Pulsar for backward compatibility)\n        enabled: true,\n        riskThreshold: 0.7, // Block transactions with risk > 0.7\n        enableComplianceCheck: true,\n        enableCounterpartyCheck: true,\n        cacheTTL: 60000, // Cache for 1 minute\n        fallbackOnError: true,\n    },\n    mode: \"block\",\n});\n\n// Transaction with asset addresses for risk assessment\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    assetAddresses: [\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"],\n    instructions: [],\n};\n\n// Risk automatically checks risk metrics during validation\nconst result = await guard.validateTransaction(tx);\nif (result.isValid) {\n    await Fabriquant.execute(tx, { with: guard });\n}",
      "source": "README.md"
    },
    {
      "language": "typescript",
      "code": "import { Fabriquant, Guard, FabricCore } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({ riskTolerance: \"moderate\" });\n\n// Optimize transaction with privacy enabled\nconst tx = FabricCore.optimize(transaction, {\n    enablePrivacy: true,\n    compressionLevel: \"high\",\n    privacyProvider: \"arbor\", // Privacy (provider identifier unchanged for backward compatibility)\n});\n\n// Execute as private transaction with ZK Compression\nconst result = await Fabriquant.executePrivate(tx, {\n    with: guard,\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});\n\n// Estimate cost savings\nconst savings = FabricCore.estimateCompressionSavings(1000);\nconsole.log(`Savings: ${savings.savingsPercent.toFixed(2)}%`);",
      "source": "README.md"
    },
    {
      "language": "typescript",
      "code": "import { JupiterAdapter, PriceFeedService, COMMON_TOKENS, ArbitragePattern, Guard } from \"@fabriquant/sdk\";\n\n// 1. Set up price feed service\nconst priceFeed = new PriceFeedService({\n    cacheTTL: 30000, // 30 second cache\n    enableFallback: true,\n});\n\n// 2. Get real-time price from Jupiter\nconst solPrice = await priceFeed.getPrice(\n    COMMON_TOKENS.SOL,\n    COMMON_TOKENS.USDC\n);\nconsole.log(`SOL Price: $${solPrice}`);\n\n// 3. Subscribe to price updates\nconst unsubscribe = priceFeed.subscribe(COMMON_TOKENS.SOL, (price) => {\n    console.log(`Updated SOL Price: $${price}`);\n});\n\n// 4. Use real DEX integration in arbitrage pattern\nconst arbitrage = new ArbitragePattern({\n    name: 'Multi-DEX Arbitrage',\n    pairs: [{\n        base: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n        quote: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n    }],\n    dexs: [\n        { name: 'Orca', programId: 'whirL...', feeTier: 0.003 },\n        { name: 'Raydium', programId: 'Rayd...', feeTier: 0.0025 },\n    ],\n    minProfitPercent: 0.5,\n    tradeAmount: 1000,\n    maxSlippage: 0.01,\n    enableRealDEX: true, // Enable live price feeds from Jupiter\n    guard: new Guard({ mode: 'block', maxSlippage: 0.02 }),\n});\n\nconst result = await arbitrage.execute();\nconsole.log(`Opportunities found: ${result.metadata?.opportunitiesFound}`);\nconsole.log(`Total profit: $${result.metadata?.totalProfit}`);\n\n// Clean up subscription\nunsubscribe();",
      "source": "README.md"
    },
    {
      "language": "typescript",
      "code": "import { createChainAdapter, SolanaAdapter } from '@fabriquant/sdk';\n\n// Create Solana adapter\nconst solanaAdapter = createChainAdapter({\n  chain: 'solana',\n  network: 'mainnet-beta',\n  rpcUrl: 'https://api.mainnet-beta.solana.com'\n});\n\n// Or create directly\nconst adapter = new SolanaAdapter({\n  chain: 'solana',\n  network: 'mainnet-beta'\n});",
      "source": "docs/CHAIN_ABSTRACTION.md"
    },
    {
      "language": "typescript",
      "code": "import { Guard, createChainAdapter } from '@fabriquant/sdk';\nimport type { UnifiedTransaction } from '@fabriquant/sdk';\n\n// Create chain adapter\nconst adapter = createChainAdapter({\n  chain: 'solana',\n  network: 'mainnet-beta'\n});\n\n// Create Guard with chain adapter\nconst guard = new Guard({\n  chainAdapter: adapter,\n  maxSlippage: 0.1,\n  mode: 'block'\n});\n\n// Validate unified transaction\nconst unifiedTx: UnifiedTransaction = {\n  id: 'tx-001',\n  status: 'pending',\n  chain: 'solana',\n  chainData: {\n    type: 'solana',\n    data: {\n      instructions: [],\n      // ... Solana-specific data\n    }\n  },\n  operations: [],\n  assetAddresses: ['TokenAddress...']\n};\n\nconst result = await guard.validateUnifiedTransaction(unifiedTx);\nif (!result.isValid) {\n  console.error('Transaction blocked:', result.warnings);\n}",
      "source": "docs/CHAIN_ABSTRACTION.md"
    },
    {
      "language": "typescript",
      "code": "// Existing code continues to work\nconst guard = new Guard({ maxSlippage: 0.1 });\nconst result = await guard.validateTransaction(legacyTx);",
      "source": "docs/CHAIN_ABSTRACTION.md"
    },
    {
      "language": "typescript",
      "code": "const guard = new Guard({ maxSlippage: 0.1 });\nconst result = await guard.validateTransaction(solanaTx);",
      "source": "docs/CHAIN_ABSTRACTION.md"
    },
    {
      "language": "typescript",
      "code": "const adapter = createChainAdapter({ chain: 'solana', network: 'mainnet-beta' });\nconst guard = new Guard({ chainAdapter: adapter, maxSlippage: 0.1 });\nconst result = await guard.validateUnifiedTransaction(unifiedTx);",
      "source": "docs/CHAIN_ABSTRACTION.md"
    },
    {
      "language": "bash",
      "code": "npm install @fabriquant/sdk",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "import { Guard } from \"@fabriquant/sdk\";\n\n// Create a Guard with default configuration\nconst guard = new Guard();\n\n// Validate a transaction (now async due to Risk integration)\nconst result = await guard.validateTransaction(transaction);\n\nif (!result.isValid) {\n    console.log(\"Transaction blocked:\", result.blockedBy);\n    console.log(\"Warnings:\", result.warnings);\n}",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "interface GuardConfig {\n    // Slippage protection (percentage)\n    maxSlippage?: number;\n\n    // Emergency stop - halts all operations\n    emergencyStop?: boolean;\n\n    // Enable/disable pattern detection\n    enablePatternDetection?: boolean;\n\n    // Risk tolerance level\n    riskTolerance?: \"strict\" | \"moderate\" | \"permissive\";\n\n    // Operation mode\n    mode?: \"block\" | \"warn\";\n\n    // Custom validation rules\n    customRules?: ValidationRule[];\n\n    // Risk assessment integration\n    pulsar?: PulsarConfig;\n}\n\ninterface PulsarConfig {\n    enabled?: boolean; // Enable Risk checks\n    riskThreshold?: number; // 0-1 scale, block if exceeded\n    enableComplianceCheck?: boolean; // Check compliance status\n    enableCounterpartyCheck?: boolean; // Check counterparty risk\n    enableOracleCheck?: boolean; // Check oracle integrity\n    cacheTTL?: number; // Cache TTL in milliseconds\n    fallbackOnError?: boolean; // Allow transactions if API fails\n}",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "const guard = new Guard({ riskTolerance: \"strict\" });",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "const guard = new Guard({ riskTolerance: \"moderate\" });",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "const guard = new Guard({ riskTolerance: \"permissive\" });",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "const guard = new Guard({ mode: \"block\" });",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "const guard = new Guard({ mode: \"warn\" });",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "// Detected when SetAuthority(MintTokens, None) is called",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "// Detected when SetAuthority(FreezeAccount, None) is called",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "// Detected when new authority is not in transaction signers",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "// Detected when CloseAccount instruction is used",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "constructor(config?: GuardConfig)",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "validateTransaction(transaction: Transaction): Promise<ValidationResult>",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "validate(transaction?: Transaction): Promise<boolean>",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "getConfig(): GuardConfig",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "updateConfig(updates: Partial<GuardConfig>): void",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "activateEmergencyStop(): void",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "deactivateEmergencyStop(): void",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "isSlippageAcceptable(actualSlippage: number): boolean",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "getWarningHistory(): SecurityWarning[]",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "clearWarningHistory(): void",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "import { Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    maxSlippage: 1.0,\n    riskTolerance: \"moderate\",\n});\n\nconst result = await guard.validateTransaction(tx);\n\nif (result.isValid) {\n    // Safe to proceed\n    await sendTransaction(tx);\n} else {\n    console.error(\"Transaction blocked:\", result.blockedBy);\n    result.warnings.forEach((warning) => {\n        console.log(warning.message);\n    });\n}",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "import { Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        riskThreshold: 0.7, // Block if risk > 0.7\n        enableComplianceCheck: true, // Check compliance status\n        enableCounterpartyCheck: true, // Check counterparty risk\n        enableOracleCheck: true, // Check oracle integrity\n        cacheTTL: 60000, // Cache for 1 minute\n        fallbackOnError: true, // Allow if API fails\n    },\n    mode: \"block\",\n    riskTolerance: \"moderate\",\n});\n\n// Transaction must include assetAddresses for risk assessment\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    assetAddresses: [\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"],\n    instructions: [],\n};\n\nconst result = await guard.validateTransaction(tx);\n\nif (!result.isValid) {\n    // Check if blocked by Risk assessment\n    result.warnings.forEach((warning) => {\n        if (warning.message.includes(\"risk\")) {\n            console.log(\"High risk asset detected:\", warning.affectedAccount);\n        }\n    });\n}",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "const guard = new Guard();\n\n// In case of security incident\nguard.activateEmergencyStop();\n\n// All transactions will be blocked\nconst result = await guard.validate(); // false\n\n// Resume when safe\nguard.deactivateEmergencyStop();",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "const guard = new Guard({\n    customRules: [\n        {\n            id: \"max-value\",\n            name: \"Maximum Transaction Value\",\n            enabled: true,\n            validate: (tx) => {\n                // Custom logic\n                return tx.value < 1000000;\n            },\n        },\n    ],\n});",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "const guard = new Guard({ maxSlippage: 0.5 }); // 0.5%\n\n// Before swap execution\nif (!guard.isSlippageAcceptable(actualSlippage)) {\n    throw new Error(\"Slippage exceeds limit\");\n}",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "const guard = new Guard();\n\n// Validate multiple transactions (now async)\nawait guard.validateTransaction(tx1);\nawait guard.validateTransaction(tx2);\nawait guard.validateTransaction(tx3);\n\n// Review all warnings\nconst warnings = guard.getWarningHistory();\nconsole.log(`Total warnings: ${warnings.length}`);\n\nwarnings.forEach((warning) => {\n    console.log(`[${warning.severity}] ${warning.message}`);\n});",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "const guard = new Guard();\n\nconst privateTx = {\n    id: \"tx-private\",\n    status: \"pending\",\n    privacyMetadata: {\n        requiresPrivacy: true,\n        compressionEnabled: true,\n    },\n    instructions: [],\n};\n\nconst result = await guard.validateTransaction(privateTx);\n// Guard will warn if privacy is requested but compression is disabled",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "import { Fabriquant, Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    maxSlippage: 1.0,\n    emergencyStop: false,\n});\n\n// Guard is automatically used by Fabriquant.execute()\nawait Fabriquant.execute(tx, { with: guard });",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "import { Fabriquant, Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        riskThreshold: 0.7,\n        enableComplianceCheck: true,\n    },\n    mode: \"block\",\n});\n\n// Transaction with asset addresses\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    assetAddresses: [\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"],\n    instructions: [],\n};\n\n// Fabriquant.execute() will check Risk before execution\nconst result = await Fabriquant.execute(tx, { with: guard });",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "import { Fabriquant, Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({ riskTolerance: \"moderate\" });\n\nconst tx = {\n    id: \"tx-private\",\n    status: \"pending\",\n    instructions: [],\n};\n\n// Execute as private transaction with Privacy layer\nconst result = await Fabriquant.executePrivate(tx, {\n    with: guard,\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "import type {\n    GuardConfig,\n    ValidationResult,\n    SecurityWarning,\n    ValidationRule,\n    PulsarConfig,\n    RiskMetrics,\n} from \"@fabriquant/sdk\";\n\n// Pattern IDs\nimport { PatternId } from \"@fabriquant/sdk\";\n// PatternId.MintKill, FreezeKill, SignerMismatch, DangerousClose\n\n// Severity Levels\nimport { Severity } from \"@fabriquant/sdk\";\n// Severity.Critical, Warning, Alert",
      "source": "docs/GUARD.md"
    },
    {
      "language": "typescript",
      "code": "import {\n  ArbitragePattern,\n  PriceFeedService,\n  COMMON_TOKENS,\n  Guard\n} from '@fabriquant/sdk';\n\n// 1. Get real-time prices\nconst priceFeed = new PriceFeedService();\nconst solPrice = await priceFeed.getPrice(COMMON_TOKENS.SOL, COMMON_TOKENS.USDC);\nconsole.log(`SOL: $${solPrice}`);\n\n// 2. Use real DEX in patterns\nconst arbitrage = new ArbitragePattern({\n  name: 'Live Arbitrage',\n  pairs: [{\n    base: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n    quote: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n  }],\n  dexs: [\n    { name: 'Orca', programId: 'whirL...', feeTier: 0.003 },\n    { name: 'Raydium', programId: 'Rayd...', feeTier: 0.0025 },\n  ],\n  minProfitPercent: 0.5,\n  tradeAmount: 1000,\n  maxSlippage: 0.01,\n  enableRealDEX: true,  // ✨ Enable live prices from Jupiter\n  guard: new Guard({ mode: 'block' }),\n});\n\nconst result = await arbitrage.execute();",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "import { COMMON_TOKENS } from '@fabriquant/sdk';\n\n// Common Solana tokens with mint addresses\nCOMMON_TOKENS.SOL    // Wrapped SOL\nCOMMON_TOKENS.USDC   // USD Coin\nCOMMON_TOKENS.USDT   // Tether USD\nCOMMON_TOKENS.RAY    // Raydium\nCOMMON_TOKENS.SRM    // Serum\nCOMMON_TOKENS.MNGO   // Mango\nCOMMON_TOKENS.ORCA   // Orca",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "import {\n  GridTradingPattern,\n  SwapPattern,\n  TreasuryRebalancing,\n  Guard,\n  JupiterAdapter,        // ✨ For DEX integration\n  PriceFeedService,      // ✨ For price feeds\n  COMMON_TOKENS,         // ✨ For token mints\n} from '@fabriquant/sdk';",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "// 1. Create pattern with configuration\nconst pattern = new GridTradingPattern({\n  name: 'My Trading Strategy',\n  // ... pattern-specific config\n  guard: new Guard({ mode: 'block', maxSlippage: 0.02 }),\n  dryRun: false, // Set to true to test without executing\n});\n\n// 2. Execute pattern\nconst result = await pattern.execute();\n\n// 3. Check results\nif (result.success) {\n  console.log(`Executed ${result.transactions.length} transactions`);\n  console.log(`Duration: ${result.metrics.totalDuration}ms`);\n} else {\n  console.error('Pattern failed:', result.error);\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "import { GridTradingPattern, Guard } from '@fabriquant/sdk';\n\nconst pattern = new GridTradingPattern({\n  name: 'SOL-USDC Grid',\n  pair: {\n    base: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n    quote: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n  },\n  lowerBound: 90,      // Buy below $90\n  upperBound: 110,     // Sell above $110\n  gridLevels: 10,      // 10 price levels\n  amountPerGrid: 1,    // 1 SOL per level\n  currentPrice: {\n    token: 'SOL',\n    price: 100,\n    quoteCurrency: 'USDC',\n    timestamp: Date.now(),\n  },\n  guard: new Guard({ mode: 'block', maxSlippage: 0.02 }),\n});\n\nconst result = await pattern.execute();",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "interface GridTradingConfig {\n  name: string;\n  pair: TradingPair;\n  lowerBound: number;        // Minimum price\n  upperBound: number;        // Maximum price\n  gridLevels: number;        // Number of grid levels\n  amountPerGrid: number;     // Amount per level\n  currentPrice: Price;       // Current market price\n  guard?: Guard;             // Security validation\n  dryRun?: boolean;          // Test mode\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "import { DCAStrategy, Guard } from '@fabriquant/sdk';\n\nconst pattern = new DCAStrategy({\n  name: 'Weekly SOL Purchase',\n  buyToken: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n  payToken: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n  amountPerInterval: 100,           // $100 per purchase\n  intervalDuration: 7 * 24 * 60 * 60 * 1000, // Weekly\n  totalIntervals: 52,               // 1 year\n  autoExecute: true,                // Run automatically\n  currentPrice: {\n    token: 'SOL',\n    price: 100,\n    quoteCurrency: 'USDC',\n    timestamp: Date.now(),\n  },\n  guard: new Guard({ mode: 'block', maxSlippage: 0.03 }),\n});\n\n// Start automated execution\nawait pattern.execute();\n\n// Control execution\npattern.pause();   // Pause strategy\npattern.resume();  // Resume strategy\npattern.stop();    // Stop completely",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "interface DCAConfig {\n  name: string;\n  buyToken: Token;\n  payToken: Token;\n  amountPerInterval: number;    // Amount per purchase\n  intervalDuration: number;     // Time between purchases (ms)\n  totalIntervals: number;       // Total number of purchases\n  autoExecute?: boolean;        // Auto-schedule intervals\n  currentPrice: Price;\n  guard?: Guard;\n  dryRun?: boolean;\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "import { ArbitragePattern, Guard, COMMON_TOKENS } from '@fabriquant/sdk';\n\nconst pattern = new ArbitragePattern({\n  name: 'Multi-DEX Arbitrage',\n  pairs: [\n    {\n      base: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n      quote: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n    },\n  ],\n  dexs: [\n    { name: 'Orca', programId: 'whirL...', feeTier: 0.003 },\n    { name: 'Raydium', programId: 'Rayd...', feeTier: 0.0025 },\n  ],\n  minProfitPercent: 0.5,        // 0.5% minimum profit\n  tradeAmount: 1000,            // $1k per trade\n  maxSlippage: 0.01,\n  scanInterval: 5000,           // Scan every 5 seconds\n  enableRealDEX: true,          // ✨ Enable live price feeds from Jupiter\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nconst result = await pattern.execute();\nconsole.log(`Found ${result.metadata.opportunitiesFound} opportunities`);\nconsole.log(`Total profit: $${result.metadata.totalProfit}`);",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "import { ArbitragePattern, JupiterAdapter } from '@fabriquant/sdk';\n\n// Use custom adapter configuration\nconst customAdapter = new JupiterAdapter({\n  cacheTTL: 10000,  // 10 second cache\n  timeout: 5000,    // 5 second timeout\n});\n\nconst pattern = new ArbitragePattern({\n  name: 'Custom Arbitrage',\n  // ... config\n  enableRealDEX: true,\n  dexAdapter: customAdapter,  // ✨ Use custom adapter\n});",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "interface ArbitrageConfig {\n  name: string;\n  pairs: TradingPair[];\n  dexs: DEX[];\n  minProfitPercent: number;     // Minimum profit threshold\n  tradeAmount: number;          // Amount to trade per arbitrage\n  maxSlippage: number;          // Maximum slippage tolerance\n  scanInterval?: number;        // Scan frequency (ms)\n  autoExecute?: boolean;        // Execute opportunities automatically\n  enableRealDEX?: boolean;      // ✨ Enable real DEX integration (default: false)\n  dexAdapter?: DEXAdapter;      // ✨ Custom DEX adapter (overrides default Jupiter)\n  guard?: Guard;\n  dryRun?: boolean;\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "import { TreasuryRebalancing, Guard } from '@fabriquant/sdk';\n\nconst pattern = new TreasuryRebalancing({\n  name: 'DAO Treasury Rebalance',\n  totalValue: 1000000,  // $1M treasury\n  allocations: [\n    {\n      token: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n      targetPercent: 40,\n      currentValue: 350000,  // Currently at $350k (35%)\n    },\n    {\n      token: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n      targetPercent: 40,\n      currentValue: 450000,  // Currently at $450k (45%)\n    },\n    {\n      token: { mint: 'mSo...', symbol: 'mSOL', decimals: 9 },\n      targetPercent: 20,\n      currentValue: 200000,  // Currently at $200k (20%)\n    },\n  ],\n  threshold: 5,                  // Rebalance if >5% deviation\n  maxSlippage: 0.02,\n  baseCurrency: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n  guard: new Guard({ mode: 'block', maxSlippage: 0.02 }),\n});\n\n// Check if rebalancing is needed\nif (pattern.needsRebalancing()) {\n  const result = await pattern.execute();\n  console.log(`Executed ${result.metadata.actionsExecuted} rebalancing trades`);\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "interface RebalancingConfig {\n  name: string;\n  totalValue: number;           // Total treasury value (USD)\n  allocations: AssetAllocation[];\n  threshold: number;            // Deviation threshold (%)\n  minTradeSize?: number;        // Minimum trade size (USD)\n  maxSlippage: number;\n  baseCurrency: Token;\n  guard?: Guard;\n  dryRun?: boolean;\n}\n\ninterface AssetAllocation {\n  token: Token;\n  targetPercent: number;        // Target allocation (0-100)\n  currentValue: number;         // Current value (USD)\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "import { YieldFarmingPattern, Guard } from '@fabriquant/sdk';\n\nconst pattern = new YieldFarmingPattern({\n  name: 'Treasury Yield Optimization',\n  farmAmount: 500000,  // $500k to farm\n  farmToken: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n  protocols: [\n    {\n      name: 'Solend',\n      programId: 'SoLE...',\n      apy: 8.5,\n      token: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n    },\n    {\n      name: 'Marinade',\n      programId: 'Mari...',\n      apy: 6.8,\n      token: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n    },\n    {\n      name: 'Orca',\n      programId: 'Orca...',\n      apy: 12.3,\n      token: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n    },\n  ],\n  strategy: 'diversified',       // 'highest-apy' | 'diversified' | 'conservative'\n  autoCompound: true,\n  compoundFrequency: 7 * 24 * 60 * 60 * 1000, // Weekly\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nconst result = await pattern.execute();\nconst summary = pattern.getAllocationSummary();\nconsole.log('Allocations:', summary);",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "interface YieldFarmingConfig {\n  name: string;\n  farmAmount: number;\n  farmToken: Token;\n  protocols: YieldProtocol[];\n  strategy: 'highest-apy' | 'diversified' | 'conservative';\n  autoCompound?: boolean;\n  compoundFrequency?: number;   // Compound interval (ms)\n  guard?: Guard;\n  dryRun?: boolean;\n}\n\ninterface YieldProtocol {\n  name: string;\n  programId: string;\n  apy: number;                  // Current APY (%)\n  token: Token;\n  minDeposit?: number;\n  maxDeposit?: number;\n  lockPeriod?: number;          // Lock duration (seconds)\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "import { SwapPattern, Guard, COMMON_TOKENS } from '@fabriquant/sdk';\n\nconst pattern = new SwapPattern({\n  name: 'Optimized SOL Swap',\n  fromToken: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n  toToken: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n  amount: 100,\n  currentPrice: {\n    token: 'SOL',\n    price: 100,\n    quoteCurrency: 'USDC',\n    timestamp: Date.now(),\n  },\n  maxPriceImpact: 0.5,\n  enableSplitOrders: true,\n  enableRealDEX: true,          // ✨ Fetch optimal routes from Jupiter\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nconst result = await pattern.execute();\nconst summary = pattern.getSummary();\nconsole.log('Routes used:', summary.routes.length);\nconsole.log('Total price impact:', summary.totalPriceImpact);\nconsole.log('Average price:', summary.averagePrice);",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "const pattern = new SwapPattern({\n  name: 'Manual Route Swap',\n  fromToken: { mint: COMMON_TOKENS.SOL, symbol: 'SOL', decimals: 9 },\n  toToken: { mint: COMMON_TOKENS.USDC, symbol: 'USDC', decimals: 6 },\n  amount: 100,\n  currentPrice: {\n    token: 'SOL',\n    price: 100,\n    quoteCurrency: 'USDC',\n    timestamp: Date.now(),\n  },\n  routes: [  // Manual routes for testing\n    {\n      dex: 'Orca',\n      programId: 'Orca...',\n      price: 100.5,\n      liquidity: 500000,\n      priceImpact: 0.15,\n      fee: 0.003,\n    },\n    {\n      dex: 'Raydium',\n      programId: 'Rayd...',\n      price: 100.2,\n      liquidity: 300000,\n      priceImpact: 0.25,\n      fee: 0.0025,\n    },\n  ],\n  maxPriceImpact: 0.5,\n  enableSplitOrders: true,\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "interface SwapConfig {\n  name: string;\n  fromToken: Token;\n  toToken: Token;\n  amount: number;\n  currentPrice: Price;\n  routes?: SwapRoute[];          // ✨ Optional if using enableRealDEX\n  maxPriceImpact: number;        // Max allowed price impact (%)\n  enableSplitOrders?: boolean;   // Split across routes\n  minRouteAllocation?: number;   // Min allocation per route (%)\n  enableRealDEX?: boolean;       // ✨ Enable real DEX integration (default: false)\n  dexAdapter?: DEXAdapter;       // ✨ Custom DEX adapter (overrides default Jupiter)\n  guard?: Guard;\n  dryRun?: boolean;\n}\n\ninterface SwapRoute {\n  dex: string;\n  programId: string;\n  price: number;\n  liquidity: number;\n  priceImpact: number;          // Estimated impact (%)\n  fee: number;                  // Fee percentage\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "import { LiquidityPattern, Guard } from '@fabriquant/sdk';\n\n// Add liquidity\nconst addPattern = new LiquidityPattern({\n  name: 'Add SOL-USDC Liquidity',\n  action: 'add',\n  pool: {\n    name: 'Orca SOL-USDC',\n    programId: 'Orca...',\n    tokenA: { mint: 'So11...', symbol: 'SOL', decimals: 9 },\n    tokenB: { mint: 'EPjF...', symbol: 'USDC', decimals: 6 },\n    apy: 12.5,\n    feeTier: 0.003,\n    totalLiquidity: 5000000,\n    priceRatio: 100,\n  },\n  amountA: 10,    // 10 SOL\n  amountB: 1000,  // 1000 USDC\n  prices: {\n    tokenA: { token: 'SOL', price: 100, quoteCurrency: 'USDC', timestamp: Date.now() },\n    tokenB: { token: 'USDC', price: 1, quoteCurrency: 'USD', timestamp: Date.now() },\n  },\n  monitorImpermanentLoss: true,\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nconst result = await addPattern.execute();\n\n// Monitor position\nconst position = addPattern.getPositionSummary();\nconsole.log('Impermanent loss:', position?.impermanentLoss);\n\n// Remove liquidity\nconst removePattern = new LiquidityPattern({\n  name: 'Remove Liquidity',\n  action: 'remove',\n  pool: /* same pool */,\n  removePercentage: 50,  // Remove 50%\n  prices: { /* current prices */ },\n  guard: new Guard({ mode: 'block', maxSlippage: 0.01 }),\n});\n\nawait removePattern.execute();",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "interface LiquidityConfig {\n  name: string;\n  action: 'add' | 'remove' | 'rebalance';\n  pool: LiquidityPool;\n  amountA?: number;             // For 'add'\n  amountB?: number;             // For 'add'\n  removePercentage?: number;    // For 'remove' (0-100)\n  prices: {\n    tokenA: Price;\n    tokenB: Price;\n  };\n  monitorImpermanentLoss?: boolean;\n  rebalanceThreshold?: number;  // Auto-rebalance at IL% threshold\n  guard?: Guard;\n  dryRun?: boolean;\n}\n\ninterface LiquidityPool {\n  name: string;\n  programId: string;\n  tokenA: Token;\n  tokenB: Token;\n  apy: number;\n  feeTier: number;\n  totalLiquidity: number;\n  priceRatio: number;\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "abstract class ExecutionPattern {\n  // Execute the pattern\n  abstract execute(): Promise<PatternResult>;\n\n  // Validate configuration (override in subclass)\n  protected abstract validate(): boolean;\n\n  // Execute with automatic retry on failure\n  protected async executeWithRetry<T>(\n    fn: () => Promise<T>,\n    maxRetries?: number\n  ): Promise<T>;\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "interface PatternResult {\n  success: boolean;\n  transactions: Transaction[];\n  metrics: PatternMetrics;\n  error?: Error;\n  metadata?: Record<string, unknown>;\n}\n\ninterface PatternMetrics {\n  executionTime: number;        // Total duration (ms)\n  gasUsed?: number;             // Total gas consumed\n  successRate: number;          // Success rate (0-1)\n  retryCount: number;           // Number of retries\n  transactionCount: number;     // Total transactions\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "import { PatternRegistry, ExecutionPattern } from '@fabriquant/sdk';\n\n// Register custom pattern\nclass MyCustomPattern extends ExecutionPattern {\n  async execute() {\n    // Implementation\n  }\n\n  protected validate() {\n    // Validation\n  }\n}\n\nPatternRegistry.register('my-custom-pattern', MyCustomPattern);\n\n// Retrieve pattern\nconst PatternClass = PatternRegistry.get('my-custom-pattern');\nif (PatternClass) {\n  const pattern = new PatternClass(config);\n  await pattern.execute();\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "const guard = new Guard({\n  mode: 'block',\n  maxSlippage: 0.02,\n  riskTolerance: 'moderate',\n});\n\nconst pattern = new GridTradingPattern({\n  // ... config\n  guard,  // ✅ Always include Guard\n});",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "// Test without executing\nconst pattern = new SwapPattern({\n  // ... config\n  dryRun: true,  // ✅ Test first\n});\n\nconst result = await pattern.execute();\nif (result.success) {\n  // Now run for real\n  pattern.config.dryRun = false;\n  await pattern.execute();\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "const result = await pattern.execute();\n\nconsole.log('Performance:', {\n  duration: result.metrics.executionTime,\n  gasUsed: result.metrics.gasUsed,\n  successRate: result.metrics.successRate,\n  retries: result.metrics.retryCount,\n});",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "const result = await pattern.execute();\n\nif (!result.success) {\n  console.error('Pattern failed:', result.error);\n\n  // Analyze failure\n  if (result.error?.message.includes('slippage')) {\n    // Increase slippage tolerance\n  }\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "// Grid Trading\nconst gridPattern = new GridTradingPattern(config);\nconst levels = gridPattern.getGridLevels();  // Get all grid levels\n\n// Treasury Rebalancing\nconst rebalancePattern = new TreasuryRebalancing(config);\nif (rebalancePattern.needsRebalancing()) {\n  await rebalancePattern.execute();\n}\n\n// Swap\nconst swapPattern = new SwapPattern(config);\nconst summary = swapPattern.getSummary();  // Get execution summary",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "// ❌ Don't modify config after creation\npattern.config.amount = 200;\n\n// ✅ Create new pattern instance\nconst newPattern = new SwapPattern({\n  ...config,\n  amount: 200,\n});",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "typescript",
      "code": "import { FabricCore } from '@fabriquant/sdk';\n\nconst pattern = new GridTradingPattern(config);\nconst result = await pattern.execute();\n\n// Add privacy to transactions\nfor (const tx of result.transactions) {\n  const optimized = FabricCore.optimize(tx, {\n    enablePrivacy: true,\n    privacyProvider: 'arbor',\n  });\n}",
      "source": "docs/PATTERNS.md"
    },
    {
      "language": "bash",
      "code": "npm install @fabriquant/sdk",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "typescript",
      "code": "import { Fabriquant, Guard, FabricCore } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({ riskTolerance: \"moderate\" });\n\nconst tx = {\n    id: \"tx-private-001\",\n    status: \"pending\",\n    instructions: [],\n};\n\n// Execute as private transaction with ZK Compression via Privacy\nconst result = await Fabriquant.executePrivate(tx, {\n    with: guard,\n    privacy: {\n        provider: \"arbor\", // Note: 'arbor' is the provider identifier, represents Privacy\n        compression: true,\n    },\n});\n\nconsole.log(\"Status:\", result.status);\nconsole.log(\"Privacy Enabled:\", result.privacyMetadata?.requiresPrivacy);\nconsole.log(\"Compression Enabled:\", result.privacyMetadata?.compressionEnabled);",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "typescript",
      "code": "import { FabricCore } from \"@fabriquant/sdk\";\n\n// Estimate cost savings for 1000 transactions\nconst savings = FabricCore.estimateCompressionSavings(1000);\n\nconsole.log(\"Native Cost:\", savings.nativeCost, \"SOL\");\nconsole.log(\"Compressed Cost:\", savings.compressedCost, \"SOL\");\nconsole.log(\"Savings:\", savings.savings, \"SOL\");\nconsole.log(\"Savings Percentage:\", savings.savingsPercent.toFixed(2), \"%\");",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "typescript",
      "code": "import { FabricCore, Fabriquant } from \"@fabriquant/sdk\";\n\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    instructions: [],\n};\n\n// Optimize with privacy enabled via Privacy\nconst optimized = FabricCore.optimize(tx, {\n    enablePrivacy: true,\n    compressionLevel: \"high\",\n    privacyProvider: \"arbor\", // Note: 'arbor' is the provider identifier, represents Privacy\n});\n\n// Execute as private transaction\nconst result = await Fabriquant.executePrivate(optimized, {\n    privacy: {\n        provider: \"arbor\",\n        compression: true,\n    },\n});",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "typescript",
      "code": "interface PrivacyConfig {\n    enabled?: boolean; // Enable privacy features\n    provider?: \"arbor\" | \"light\"; // Privacy provider ('arbor' = Privacy)\n    compressionLevel?: \"low\" | \"medium\" | \"high\"; // Compression level\n    requirePrivacy?: boolean; // Require privacy for execution\n}",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "typescript",
      "code": "import { Fabriquant } from \"@fabriquant/sdk\";\n\nconst fabriquant = new Fabriquant({\n    network: \"mainnet-beta\",\n    privacy: {\n        enabled: true,\n        provider: \"arbor\", // Privacy\n        compressionLevel: \"high\",\n    },\n});",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "typescript",
      "code": "static async executePrivate(\n  tx: Transaction,\n  options: {\n    with?: Guard;\n    privacy?: {\n      provider?: 'arbor' | 'light';\n      compression?: boolean;\n    };\n  }\n): Promise<Transaction>",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "typescript",
      "code": "static optimize(\n  transaction: Transaction,\n  options: OptimizeOptions\n): Transaction",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "typescript",
      "code": "static async compressWithArbor(\n  transaction: Transaction,\n  config?: PrivacyConfig\n): Promise<Transaction>",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "typescript",
      "code": "static estimateCompressionSavings(\n  transactionCount: number\n): {\n  nativeCost: number;\n  compressedCost: number;\n  savings: number;\n  savingsPercent: number;\n}",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "typescript",
      "code": "import { Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard();\n\nconst privateTx = {\n    id: \"tx-private\",\n    status: \"pending\",\n    privacyMetadata: {\n        requiresPrivacy: true,\n        compressionEnabled: true,\n    },\n    instructions: [],\n};\n\n// Guard will validate privacy requirements\nconst result = await guard.validateTransaction(privateTx);\n\n// Guard warns if privacy is requested but compression is disabled\nif (!result.isValid) {\n    result.warnings.forEach((warning) => {\n        if (warning.message.includes(\"privacy\")) {\n            console.log(\"Privacy warning:\", warning.message);\n        }\n    });\n}",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "typescript",
      "code": "// Hide transaction amounts while allowing disclosure to authorities via Privacy\nconst payrollTx = await Fabriquant.executePrivate(payrollTransaction, {\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "typescript",
      "code": "// Mass airdrop to millions of users at minimal cost via Privacy\nconst airdropTx = await Fabriquant.executePrivate(airdropTransaction, {\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});\n\n// Estimate savings\nconst savings = FabricCore.estimateCompressionSavings(1000000);\nconsole.log(`Savings: ${savings.savingsPercent.toFixed(2)}%`);",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "typescript",
      "code": "// Hide order size and price until execution via Privacy\nconst orderTx = await Fabriquant.executePrivate(orderTransaction, {\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "typescript",
      "code": "// Blind voting with results revealed after period ends via Privacy\nconst voteTx = await Fabriquant.executePrivate(voteTransaction, {\n    privacy: {\n        provider: \"arbor\", // Privacy\n        compression: true,\n    },\n});",
      "source": "docs/PRIVACY.md"
    },
    {
      "language": "bash",
      "code": "npm install @fabriquant/sdk",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "import { Pulsar } from \"@fabriquant/sdk\";\n\n// Note: The class is still named 'Pulsar' in code, but represents Risk\n// Get risk metrics for a single asset\nconst metrics = await Pulsar.getRiskMetrics(\n    \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\n);\n\nconsole.log(\"Risk Score:\", metrics.riskScore);\nconsole.log(\"Compliance:\", metrics.complianceStatus);\nconsole.log(\"Counterparty Risk:\", metrics.counterpartyRisk);\nconsole.log(\"Oracle Integrity:\", metrics.oracleIntegrity);",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "import { Pulsar } from \"@fabriquant/sdk\"; // Risk\n\nconst assetAddresses = [\n    \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\",\n    \"So11111111111111111111111111111111111111112\",\n    \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n];\n\n// Get risk metrics for multiple assets\nconst riskMap = await Pulsar.getBatchRiskMetrics(assetAddresses);\n\nfor (const [address, metrics] of riskMap.entries()) {\n    console.log(`${address}: Risk Score = ${metrics.riskScore}`);\n}",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "interface PulsarConfig {\n    enabled?: boolean; // Enable Risk checks (default: true)\n    riskThreshold?: number; // 0-1 scale, block if exceeded (default: 0.7)\n    enableComplianceCheck?: boolean; // Check compliance status (default: true)\n    enableCounterpartyCheck?: boolean; // Check counterparty risk (default: true)\n    enableOracleCheck?: boolean; // Check oracle integrity (default: true)\n    cacheTTL?: number; // Cache TTL in milliseconds (default: 60000)\n    fallbackOnError?: boolean; // Allow transactions if API fails (default: true)\n}",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "interface RiskMetrics {\n    asset?: string; // Asset address\n    riskScore: number | null; // 0-1 scale, where 1 is highest risk\n    complianceStatus: \"compliant\" | \"non-compliant\" | \"unknown\" | null;\n    counterpartyRisk: number | null; // 0-1 scale\n    oracleIntegrity: number | null; // 0-1 scale, where 1 is highest integrity\n    timestamp?: number; // When metrics were fetched\n}",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "import { Pulsar } from \"@fabriquant/sdk\";\n\n// Get cache statistics\nconst stats = Pulsar.getCacheStats();\nconsole.log(\"Cache size:\", stats.size);\nconsole.log(\"Cached assets:\", stats.entries);\n\n// Clear cache\nPulsar.clearCache();",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "// Configure cache TTL (default: 60000ms = 1 minute)\nconst metrics = await Pulsar.getRiskMetrics(assetAddress, {\n    cacheTTL: 300000, // 5 minutes\n});",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "import { Guard } from \"@fabriquant/sdk\";\n\nconst guard = new Guard({\n    pulsar: {\n        enabled: true,\n        riskThreshold: 0.7,\n        enableComplianceCheck: true,\n        enableCounterpartyCheck: true,\n        enableOracleCheck: true,\n        cacheTTL: 60000,\n        fallbackOnError: true,\n    },\n    mode: \"block\",\n});\n\n// Transaction must include assetAddresses\nconst tx = {\n    id: \"tx-001\",\n    status: \"pending\",\n    assetAddresses: [\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"],\n    instructions: [],\n};\n\n// Guard will automatically check Risk metrics\nconst result = await guard.validateTransaction(tx);\n\nif (!result.isValid) {\n    // Check for Risk-related warnings\n    result.warnings.forEach((warning) => {\n        if (\n            warning.message.includes(\"risk\") ||\n            warning.message.includes(\"compliance\")\n        ) {\n            console.log(\"Risk warning:\", warning.message);\n        }\n    });\n}",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "const guard = new Guard({\n    pulsar: {\n        enabled: true,\n        fallbackOnError: true, // Allow transactions if API fails\n    },\n});\n\n// If Risk API fails, transaction will proceed (if fallbackOnError: true)\n// If fallbackOnError: false, transaction will be blocked",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "const guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        enableComplianceCheck: true,\n        riskThreshold: 0.5, // Stricter for RWA\n    },\n    mode: \"block\",\n});",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "// Use aggressive caching for high-frequency operations\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        cacheTTL: 10000, // 10 seconds for faster updates\n    },\n});",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "// Comprehensive risk assessment for institutional use\nconst guard = new Guard({\n    pulsar: {\n        // Risk configuration\n        enabled: true,\n        riskThreshold: 0.6,\n        enableComplianceCheck: true,\n        enableCounterpartyCheck: true,\n        enableOracleCheck: true,\n    },\n    riskTolerance: \"strict\",\n});",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "static async getRiskMetrics(\n  assetAddress?: string,\n  config?: PulsarConfig\n): Promise<RiskMetrics>",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "static async getBatchRiskMetrics(\n  assetAddresses: string[],\n  config?: PulsarConfig\n): Promise<Map<string, RiskMetrics>>",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "static clearCache(): void",
      "source": "docs/RISK.md"
    },
    {
      "language": "typescript",
      "code": "static getCacheStats(): { size: number; entries: string[] }",
      "source": "docs/RISK.md"
    }
  ],
  "quickFacts": {
    "purpose": "Precision execution stack for Solana - Engineered for Parallelism, Built for Autonomy",
    "targetAudience": [
      "Solana developers",
      "AI agent builders",
      "DeFi protocol developers",
      "Trading bot creators"
    ],
    "coreComponents": [
      "Loom (solfabric) - Parallel execution framework",
      "Guard (sol-ops-guard) - On-chain safety layer",
      "Flow (x-liquidity-engine) - Multi-DEX liquidity routing",
      "Risk (pulsar) - AI-driven risk assessment",
      "Privacy (arbor) - ZK Compression layer"
    ],
    "keyFeatures": [
      "Real Jupiter V6 DEX integration",
      "Pattern library for common use cases",
      "Parallel transaction optimization",
      "Built-in security and risk management",
      "Privacy via ZK Compression",
      "Cross-chain abstraction (in progress)"
    ],
    "installation": "npm install @fabriquant/sdk",
    "repository": "https://github.com/fabriquant-labs/fabriquant",
    "twitter": "@psyto",
    "license": "MIT - Open Source"
  }
}